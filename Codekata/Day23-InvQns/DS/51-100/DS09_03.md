# DATA STRUCTURES - BEGINNER LEVEL INTERVIEW ANSWERS (SET 2 - Part 9)

> **Target:** IT, CS, AI, ML, ECE candidates  
> **Level:** Beginner  
> **Companies:** Google, Amazon, Microsoft, Facebook, Zoho, etc.  
> **Category:** Data Structures (Extended Set) - Questions 35-36

## ðŸ“‹ Table of Contents
- [ðŸŒ³ Tree Operations & Types](#ðŸŒ³-tree-operations--types) (Questions 35-36)

---

## ðŸŒ³ Tree Operations & Types

### 35. **How do you check if a tree is a binary search tree?** *(Zoho, Facebook)*

**Binary Search Tree (BST) Property:** For every node in the tree, all values in the left subtree are less than the node's value, and all values in the right subtree are greater than the node's value.

**Key Validation Requirements:**
- **Left subtree** contains only values **< node.val**
- **Right subtree** contains only values **> node.val**
- **Both subtrees** are also valid BSTs
- **No duplicate values** (in standard BST)
- **Global constraint** must be maintained (not just local parent-child)

**Multiple Approaches to Validate BST:**

**Approach 1: Range-based Validation (Optimal)**
```python
class TreeNode:
    """Binary tree node definition"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
    
    def __repr__(self):
        return f"TreeNode({self.val})"

class BSTValidator:
    """
    Binary Search Tree validation with multiple approaches
    """
    
    def __init__(self):
        pass
    
    def is_valid_bst(self, root):
        """
        Range-based BST validation (Most Efficient)
        Time: O(n), Space: O(h) where h is height
        """
        def validate(node, min_val, max_val):
            # Empty tree is valid BST
            if node is None:
                return True
            
            # Check if current node violates BST property
            if node.val <= min_val or node.val >= max_val:
                return False
            
            # Recursively validate left and right subtrees with updated ranges
            return (validate(node.left, min_val, node.val) and
                    validate(node.right, node.val, max_val))
        
        return validate(root, float('-inf'), float('inf'))
    
    def is_valid_bst_inorder(self, root):
        """
        Inorder traversal approach
        Time: O(n), Space: O(h) + O(n) for result storage
        """
        if root is None:
            return True
        
        inorder_result = []
        self._inorder_traversal(root, inorder_result)
        
        # Check if inorder traversal gives sorted sequence
        for i in range(1, len(inorder_result)):
            if inorder_result[i] <= inorder_result[i-1]:
                return False
        
        return True
    
    def is_valid_bst_inorder_optimized(self, root):
        """
        Optimized inorder approach (no extra space for array)
        Time: O(n), Space: O(h)
        """
        self.prev_val = float('-inf')
        
        def inorder_check(node):
            if node is None:
                return True
            
            # Check left subtree
            if not inorder_check(node.left):
                return False
            
            # Check current node
            if node.val <= self.prev_val:
                return False
            self.prev_val = node.val
            
            # Check right subtree
            return inorder_check(node.right)
        
        return inorder_check(root)
    
    def is_valid_bst_postorder(self, root):
        """
        Postorder traversal approach
        Time: O(n), Space: O(h)
        """
        def validate_postorder(node):
            if node is None:
                return True, float('-inf'), float('inf')
            
            # Check left subtree
            left_valid, left_min, left_max = validate_postorder(node.left)
            if not left_valid:
                return False, 0, 0
            
            # Check right subtree
            right_valid, right_min, right_max = validate_postorder(node.right)
            if not right_valid:
                return False, 0, 0
            
            # Check current node constraints
            if (node.left and left_max >= node.val) or (node.right and right_min <= node.val):
                return False, 0, 0
            
            # Calculate min and max for current subtree
            subtree_min = left_min if node.left else node.val
            subtree_max = right_max if node.right else node.val
            
            return True, subtree_min, subtree_max
        
        valid, _, _ = validate_postorder(root)
        return valid
    
    def _inorder_traversal(self, root, result):
        """Helper method for inorder traversal"""
        if root:
            self._inorder_traversal(root.left, result)
            result.append(root.val)
            self._inorder_traversal(root.right, result)
    
    def find_bst_violations(self, root):
        """
        Find all nodes that violate BST property
        Returns list of violating nodes with reasons
        """
        violations = []
        
        def check_violations(node, min_val, max_val, path):
            if node is None:
                return
            
            violation_reasons = []
            
            # Check range violations
            if node.val <= min_val:
                violation_reasons.append(f"Value {node.val} <= min_bound {min_val}")
            if node.val >= max_val:
                violation_reasons.append(f"Value {node.val} >= max_bound {max_val}")
            
            # Check direct parent-child violations
            if node.left and node.left.val >= node.val:
                violation_reasons.append(f"Left child {node.left.val} >= parent {node.val}")
            if node.right and node.right.val <= node.val:
                violation_reasons.append(f"Right child {node.right.val} <= parent {node.val}")
            
            if violation_reasons:
                violations.append({
                    'node': node.val,
                    'path': path.copy(),
                    'violations': violation_reasons,
                    'valid_range': f"({min_val}, {max_val})"
                })
            
            # Continue checking subtrees
            path.append('L')
            check_violations(node.left, min_val, node.val, path)
            path.pop()
            
            path.append('R')
            check_violations(node.right, node.val, max_val, path)
            path.pop()
        
        check_violations(root, float('-inf'), float('inf'), [])
        return violations
    
    def get_bst_analysis(self, root):
        """
        Comprehensive BST analysis
        """
        if root is None:
            return {
                'is_valid': True,
                'validation_method_results': {},
                'violations': [],
                'tree_properties': {
                    'total_nodes': 0,
                    'height': -1,
                    'inorder_sequence': []
                }
            }
        
        # Test all validation methods
        validation_methods = {
            'range_based': self.is_valid_bst(root),
            'inorder_array': self.is_valid_bst_inorder(root),
            'inorder_optimized': self.is_valid_bst_inorder_optimized(root),
            'postorder': self.is_valid_bst_postorder(root)
        }
        
        # Get violations
        violations = self.find_bst_violations(root)
        
        # Get tree properties
        inorder_sequence = []
        self._inorder_traversal(root, inorder_sequence)
        
        return {
            'is_valid': all(validation_methods.values()),
            'validation_method_results': validation_methods,
            'violations': violations,
            'tree_properties': {
                'total_nodes': len(inorder_sequence),
                'height': self._calculate_height(root),
                'inorder_sequence': inorder_sequence,
                'is_sorted': inorder_sequence == sorted(inorder_sequence)
            }
        }
    
    def _calculate_height(self, root):
        """Calculate tree height"""
        if root is None:
            return -1
        return 1 + max(self._calculate_height(root.left), 
                      self._calculate_height(root.right))

# Test BST validation
def test_bst_validation():
    """Test BST validation with various tree structures"""
    
    validator = BSTValidator()
    
    # Test Case 1: Valid BST
    #       5
    #      / \
    #     3   8
    #    / \ / \
    #   2  4 7  9
    valid_bst = TreeNode(5)
    valid_bst.left = TreeNode(3)
    valid_bst.right = TreeNode(8)
    valid_bst.left.left = TreeNode(2)
    valid_bst.left.right = TreeNode(4)
    valid_bst.right.left = TreeNode(7)
    valid_bst.right.right = TreeNode(9)
    
    # Test Case 2: Invalid BST (violates range constraint)
    #       5
    #      / \
    #     3   8
    #    / \ / \
    #   2  6 7  9  (6 > 5, violates BST property)
    invalid_bst_range = TreeNode(5)
    invalid_bst_range.left = TreeNode(3)
    invalid_bst_range.right = TreeNode(8)
    invalid_bst_range.left.left = TreeNode(2)
    invalid_bst_range.left.right = TreeNode(6)  # This violates BST
    invalid_bst_range.right.left = TreeNode(7)
    invalid_bst_range.right.right = TreeNode(9)
    
    # Test Case 3: Invalid BST (direct parent-child violation)
    #       5
    #      / \
    #     3   8
    #    / \ / \
    #   4  2 7  9  (4 > 3, violates BST property)
    invalid_bst_direct = TreeNode(5)
    invalid_bst_direct.left = TreeNode(3)
    invalid_bst_direct.right = TreeNode(8)
    invalid_bst_direct.left.left = TreeNode(4)  # This violates BST
    invalid_bst_direct.left.right = TreeNode(2)  # This violates BST
    invalid_bst_direct.right.left = TreeNode(7)
    invalid_bst_direct.right.right = TreeNode(9)
    
    # Test Case 4: Edge case - duplicate values
    #       5
    #      / \
    #     3   5  (duplicate 5)
    duplicate_bst = TreeNode(5)
    duplicate_bst.left = TreeNode(3)
    duplicate_bst.right = TreeNode(5)  # Duplicate value
    
    test_cases = [
        ('Valid BST', valid_bst),
        ('Invalid BST (Range Violation)', invalid_bst_range),
        ('Invalid BST (Direct Violation)', invalid_bst_direct),
        ('Invalid BST (Duplicates)', duplicate_bst),
        ('Empty Tree', None),
        ('Single Node', TreeNode(10))
    ]
    
    print("BST Validation Analysis:")
    print("=" * 60)
    
    for name, tree in test_cases:
        print(f"\n{name}:")
        
        analysis = validator.get_bst_analysis(tree)
        
        print(f"  Is Valid BST: {analysis['is_valid']}")
        print(f"  Validation Methods: {analysis['validation_method_results']}")
        
        if analysis['violations']:
            print(f"  Violations Found: {len(analysis['violations'])}")
            for i, violation in enumerate(analysis['violations'][:3]):  # Show first 3
                print(f"    {i+1}. Node {violation['node']}: {violation['violations']}")
        
        print(f"  Tree Properties: {analysis['tree_properties']}")

test_bst_validation()
```

**Advanced BST Validation Scenarios:**
```python
class AdvancedBSTValidator:
    """
    Advanced BST validation for special cases
    """
    
    def __init__(self):
        pass
    
    def is_valid_bst_with_duplicates(self, root, allow_equal_left=False):
        """
        BST validation allowing duplicates with specific placement rules
        allow_equal_left: if True, equal values go to left; if False, to right
        """
        def validate_with_duplicates(node, min_val, max_val):
            if node is None:
                return True
            
            if allow_equal_left:
                # Equal values allowed in left subtree
                if node.val < min_val or node.val > max_val:
                    return False
                return (validate_with_duplicates(node.left, min_val, node.val) and
                        validate_with_duplicates(node.right, node.val, max_val))
            else:
                # Equal values allowed in right subtree
                if node.val < min_val or node.val > max_val:
                    return False
                return (validate_with_duplicates(node.left, min_val, node.val) and
                        validate_with_duplicates(node.right, node.val, max_val))
        
        return validate_with_duplicates(root, float('-inf'), float('inf'))
    
    def validate_bst_iterative(self, root):
        """
        Iterative BST validation using stack
        Time: O(n), Space: O(h)
        """
        if root is None:
            return True
        
        stack = [(root, float('-inf'), float('inf'))]
        
        while stack:
            node, min_val, max_val = stack.pop()
            
            if node.val <= min_val or node.val >= max_val:
                return False
            
            if node.right:
                stack.append((node.right, node.val, max_val))
            if node.left:
                stack.append((node.left, min_val, node.val))
        
        return True
    
    def find_invalid_nodes_count(self, root):
        """
        Count how many nodes violate BST property
        """
        violations = 0
        
        def count_violations(node, min_val, max_val):
            nonlocal violations
            if node is None:
                return
            
            if node.val <= min_val or node.val >= max_val:
                violations += 1
            
            count_violations(node.left, min_val, node.val)
            count_violations(node.right, node.val, max_val)
        
        count_violations(root, float('-inf'), float('inf'))
        return violations
    
    def get_bst_repair_suggestions(self, root):
        """
        Suggest how to repair an invalid BST
        """
        validator = BSTValidator()
        violations = validator.find_bst_violations(root)
        
        if not violations:
            return {"status": "valid", "suggestions": []}
        
        suggestions = []
        
        for violation in violations:
            node_val = violation['node']
            violation_types = violation['violations']
            
            for v_type in violation_types:
                if "Left child" in v_type and ">=" in v_type:
                    suggestions.append(f"Move left child of {node_val} to right subtree or remove it")
                elif "Right child" in v_type and "<=" in v_type:
                    suggestions.append(f"Move right child of {node_val} to left subtree or remove it")
                elif "min_bound" in v_type:
                    suggestions.append(f"Increase value of node {node_val} or restructure tree")
                elif "max_bound" in v_type:
                    suggestions.append(f"Decrease value of node {node_val} or restructure tree")
        
        return {
            "status": "invalid",
            "violation_count": len(violations),
            "suggestions": list(set(suggestions))  # Remove duplicates
        }

def test_advanced_bst_validation():
    """Test advanced BST validation scenarios"""
    
    advanced_validator = AdvancedBSTValidator()
    
    # Test Case: BST with specific duplicate handling
    #       5
    #      / \
    #     5   7
    #    /   / \
    #   3   6   8
    duplicate_tree = TreeNode(5)
    duplicate_tree.left = TreeNode(5)
    duplicate_tree.right = TreeNode(7)
    duplicate_tree.left.left = TreeNode(3)
    duplicate_tree.right.left = TreeNode(6)
    duplicate_tree.right.right = TreeNode(8)
    
    print("\nAdvanced BST Validation:")
    print("=" * 40)
    
    print(f"Duplicates in left: {advanced_validator.is_valid_bst_with_duplicates(duplicate_tree, True)}")
    print(f"Duplicates in right: {advanced_validator.is_valid_bst_with_duplicates(duplicate_tree, False)}")
    print(f"Iterative validation: {advanced_validator.validate_bst_iterative(duplicate_tree)}")
    
    # Test repair suggestions
    validator = BSTValidator()
    invalid_tree = validator.find_bst_violations(duplicate_tree)
    repair_suggestions = advanced_validator.get_bst_repair_suggestions(duplicate_tree)
    
    print(f"Repair suggestions: {repair_suggestions}")

test_advanced_bst_validation()
```

**Performance Comparison of Validation Methods:**
```python
class BSTValidationBenchmark:
    """
    Performance comparison of different BST validation approaches
    """
    
    def __init__(self):
        self.validator = BSTValidator()
    
    def create_test_trees(self):
        """Create various test trees for benchmarking"""
        
        # Perfect BST
        perfect_bst = self._create_perfect_bst(4)
        
        # Skewed BST (like linked list)
        skewed_bst = TreeNode(1)
        current = skewed_bst
        for i in range(2, 16):
            current.right = TreeNode(i)
            current = current.right
        
        # Invalid BST
        invalid_bst = TreeNode(5)
        invalid_bst.left = TreeNode(3)
        invalid_bst.right = TreeNode(8)
        invalid_bst.left.right = TreeNode(6)  # Violates BST
        
        return {
            'perfect_bst': perfect_bst,
            'skewed_bst': skewed_bst,
            'invalid_bst': invalid_bst
        }
    
    def _create_perfect_bst(self, height):
        """Create a perfect BST of given height"""
        def build_bst(start, end):
            if start > end:
                return None
            
            mid = (start + end) // 2
            node = TreeNode(mid)
            node.left = build_bst(start, mid - 1)
            node.right = build_bst(mid + 1, end)
            return node
        
        total_nodes = (2 ** (height + 1)) - 1
        return build_bst(1, total_nodes)
    
    def benchmark_validation_methods(self):
        """Benchmark different validation approaches"""
        import time
        
        test_trees = self.create_test_trees()
        methods = {
            'Range-based': self.validator.is_valid_bst,
            'Inorder Array': self.validator.is_valid_bst_inorder,
            'Inorder Optimized': self.validator.is_valid_bst_inorder_optimized,
            'Postorder': self.validator.is_valid_bst_postorder
        }
        
        print("BST Validation Performance Comparison:")
        print("=" * 60)
        print(f"{'Method':<18} {'Perfect BST':<12} {'Skewed BST':<12} {'Invalid BST':<12}")
        print("-" * 60)
        
        for method_name, method_func in methods.items():
            times = []
            
            for tree_name, tree in test_trees.items():
                start_time = time.time()
                
                # Run multiple times for better measurement
                for _ in range(1000):
                    result = method_func(tree)
                
                end_time = time.time()
                avg_time = (end_time - start_time) / 1000 * 1000  # Convert to ms
                times.append(f"{avg_time:.3f}ms")
            
            print(f"{method_name:<18} {times[0]:<12} {times[1]:<12} {times[2]:<12}")
    
    def analyze_space_complexity(self):
        """Analyze space complexity of different methods"""
        
        print("\nSpace Complexity Analysis:")
        print("=" * 40)
        print("Method                | Space Complexity | Notes")
        print("-" * 55)
        print("Range-based          | O(h)            | Recursion stack only")
        print("Inorder Array        | O(n + h)        | Array + recursion stack")
        print("Inorder Optimized    | O(h)            | Recursion stack only")
        print("Postorder            | O(h)            | Recursion stack only")
        print("Iterative            | O(h)            | Explicit stack")

def test_bst_benchmark():
    """Test BST validation benchmarking"""
    
    benchmark = BSTValidationBenchmark()
    benchmark.benchmark_validation_methods()
    benchmark.analyze_space_complexity()

test_bst_benchmark()
```

---

### 36. **What is the lowest common ancestor in a tree?** *(Google, Amazon)*

**Lowest Common Ancestor (LCA) Definition:** The lowest common ancestor of two nodes p and q in a tree is the deepest node that has both p and q as descendants (where a node can be a descendant of itself).

**Key Properties:**
- **Deepest node** that is an ancestor of both target nodes
- **Unique solution** for any two nodes in a tree
- **Node can be ancestor of itself**
- **Efficient algorithms** exist for different tree types
- **Foundation** for many tree algorithms

**Multiple Approaches for Finding LCA:**

**Approach 1: Binary Tree LCA (General Solution)**
```python
class TreeNode:
    """Binary tree node definition"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
    
    def __repr__(self):
        return f"TreeNode({self.val})"

class LowestCommonAncestor:
    """
    Lowest Common Ancestor implementations for different tree types
    """
    
    def __init__(self):
        pass
    
    def lca_binary_tree(self, root, p, q):
        """
        LCA in Binary Tree (Most General)
        Time: O(n), Space: O(h)
        """
        # Base case
        if root is None or root == p or root == q:
            return root
        
        # Recursively search in left and right subtrees
        left_lca = self.lca_binary_tree(root.left, p, q)
        right_lca = self.lca_binary_tree(root.right, p, q)
        
        # If both left and right return non-null, current node is LCA
        if left_lca and right_lca:
            return root
        
        # Otherwise, return the non-null value
        return left_lca if left_lca else right_lca
    
    def lca_bst(self, root, p, q):
        """
        LCA in Binary Search Tree (Optimized)
        Time: O(h), Space: O(h) - can be optimized to O(1) iteratively
        """
        # Base case
        if root is None:
            return None
        
        # If both p and q are smaller than root, LCA lies in left subtree
        if p.val < root.val and q.val < root.val:
            return self.lca_bst(root.left, p, q)
        
        # If both p and q are greater than root, LCA lies in right subtree
        if p.val > root.val and q.val > root.val:
            return self.lca_bst(root.right, p, q)
        
        # If p and q are on different sides, current node is LCA
        return root
    
    def lca_bst_iterative(self, root, p, q):
        """
        Iterative LCA for BST (Space Optimized)
        Time: O(h), Space: O(1)
        """
        current = root
        
        while current:
            # If both nodes are in left subtree
            if p.val < current.val and q.val < current.val:
                current = current.left
            # If both nodes are in right subtree
            elif p.val > current.val and q.val > current.val:
                current = current.right
            # Found the LCA
            else:
                return current
        
        return None
    
    def lca_with_path(self, root, p, q):
        """
        LCA using path finding approach
        Time: O(n), Space: O(h)
        """
        def find_path(node, target, path):
            if node is None:
                return False
            
            path.append(node)
            
            if node == target:
                return True
            
            if (find_path(node.left, target, path) or 
                find_path(node.right, target, path)):
                return True
            
            path.pop()
            return False
        
        path_p = []
        path_q = []
        
        if not find_path(root, p, path_p) or not find_path(root, q, path_q):
            return None
        
        # Find the last common node in both paths
        lca = None
        min_length = min(len(path_p), len(path_q))
        
        for i in range(min_length):
            if path_p[i] == path_q[i]:
                lca = path_p[i]
            else:
                break
        
        return lca
    
    def lca_with_parent_pointers(self, p, q):
        """
        LCA when nodes have parent pointers
        Time: O(h), Space: O(h)
        """
        # Get all ancestors of p
        ancestors = set()
        current = p
        while current:
            ancestors.add(current)
            current = current.parent if hasattr(current, 'parent') else None
        
        # Find first common ancestor in q's path
        current = q
        while current:
            if current in ancestors:
                return current
            current = current.parent if hasattr(current, 'parent') else None
        
        return None
    
    def multiple_lca(self, root, nodes):
        """
        Find LCA of multiple nodes
        Time: O(n * k), Space: O(h) where k is number of nodes
        """
        if not nodes:
            return None
        if len(nodes) == 1:
            return nodes[0]
        
        # Find LCA of first two nodes
        current_lca = self.lca_binary_tree(root, nodes[0], nodes[1])
        
        # Iteratively find LCA with remaining nodes
        for i in range(2, len(nodes)):
            current_lca = self.lca_binary_tree(root, current_lca, nodes[i])
            if current_lca is None:
                return None
        
        return current_lca
    
    def find_distance_via_lca(self, root, p, q):
        """
        Find distance between two nodes using LCA
        Time: O(n), Space: O(h)
        """
        lca_node = self.lca_binary_tree(root, p, q)
        if lca_node is None:
            return -1
        
        def find_distance(node, target, distance):
            if node is None:
                return -1
            if node == target:
                return distance
            
            left_dist = find_distance(node.left, target, distance + 1)
            if left_dist != -1:
                return left_dist
            
            return find_distance(node.right, target, distance + 1)
        
        dist_p = find_distance(lca_node, p, 0)
        dist_q = find_distance(lca_node, q, 0)
        
        return dist_p + dist_q if dist_p != -1 and dist_q != -1 else -1
    
    def lca_with_level_info(self, root, p, q):
        """
        LCA with additional level information
        """
        def find_lca_with_level(node, p, q, level):
            if node is None:
                return None, -1
            
            if node == p or node == q:
                return node, level
            
            left_lca, left_level = find_lca_with_level(node.left, p, q, level + 1)
            right_lca, right_level = find_lca_with_level(node.right, p, q, level + 1)
            
            if left_lca and right_lca:
                return node, level
            
            return (left_lca, left_level) if left_lca else (right_lca, right_level)
        
        lca_node, lca_level = find_lca_with_level(root, p, q, 0)
        return {
            'lca': lca_node,
            'level': lca_level,
            'depth_from_root': lca_level
        }

# Test LCA implementations
def test_lca_implementations():
    """Test LCA with various tree structures"""
    
    lca_finder = LowestCommonAncestor()
    
    # Create test tree:
    #           3
    #       /       \
    #      5         1
    #    /   \     /   \
    #   6     2   0     8
    #        / \
    #       7   4
    
    root = TreeNode(3)
    n5 = TreeNode(5)
    n1 = TreeNode(1)
    n6 = TreeNode(6)
    n2 = TreeNode(2)
    n0 = TreeNode(0)
    n8 = TreeNode(8)
    n7 = TreeNode(7)
    n4 = TreeNode(4)
    
    # Build tree structure
    root.left = n5
    root.right = n1
    n5.left = n6
    n5.right = n2
    n1.left = n0
    n1.right = n8
    n2.left = n7
    n2.right = n4
    
    # Test cases for LCA
    test_cases = [
        (n5, n1, "LCA(5,1) should be 3"),
        (n5, n4, "LCA(5,4) should be 5"),
        (n6, n7, "LCA(6,7) should be 5"),
        (n6, n2, "LCA(6,2) should be 5"),
        (n7, n4, "LCA(7,4) should be 2"),
        (n0, n8, "LCA(0,8) should be 1")
    ]
    
    print("LCA Test Results:")
    print("=" * 50)
    
    for p, q, description in test_cases:
        lca_result = lca_finder.lca_binary_tree(root, p, q)
        distance = lca_finder.find_distance_via_lca(root, p, q)
        level_info = lca_finder.lca_with_level_info(root, p, q)
        
        print(f"\n{description}")
        print(f"  LCA Node: {lca_result.val if lca_result else None}")
        print(f"  Distance between nodes: {distance}")
        print(f"  LCA Level: {level_info['level']}")

test_lca_implementations()
```

**BST-Specific LCA Optimizations:**
```python
class BSTLowestCommonAncestor:
    """
    Optimized LCA implementations specifically for BST
    """
    
    def __init__(self):
        pass
    
    def lca_bst_values(self, root, val1, val2):
        """
        Find LCA in BST using values instead of node references
        Time: O(h), Space: O(1) iterative or O(h) recursive
        """
        current = root
        
        while current:
            if val1 < current.val and val2 < current.val:
                current = current.left
            elif val1 > current.val and val2 > current.val:
                current = current.right
            else:
                return current
        
        return None
    
    def lca_bst_with_path_compression(self, root, p, q):
        """
        LCA with path compression for repeated queries
        """
        # For multiple LCA queries, we can preprocess the tree
        # This is a simplified version - full implementation would use
        # advanced data structures like Heavy-Light Decomposition
        
        def preprocess_levels(node, level=0):
            if node is None:
                return {}
            
            levels = {node.val: level}
            levels.update(preprocess_levels(node.left, level + 1))
            levels.update(preprocess_levels(node.right, level + 1))
            return levels
        
        levels = preprocess_levels(root)
        
        # Use standard BST LCA algorithm
        return self.lca_bst_values(root, p.val, q.val)
    
    def range_lca_queries(self, root, queries):
        """
        Handle multiple LCA queries efficiently
        Time: O(q * h) where q is number of queries
        """
        results = []
        
        for p_val, q_val in queries:
            # Create temporary nodes for the algorithm
            p = TreeNode(p_val)
            q = TreeNode(q_val)
            
            lca_result = self.lca_bst_values(root, p_val, q_val)
            results.append(lca_result.val if lca_result else None)
        
        return results
    
    def lca_in_bst_range(self, root, min_val, max_val):
        """
        Find all possible LCA nodes for any two nodes in given range
        """
        lca_candidates = []
        
        def collect_range_nodes(node):
            if node is None:
                return
            
            if min_val <= node.val <= max_val:
                lca_candidates.append(node)
            
            if node.val > min_val:
                collect_range_nodes(node.left)
            if node.val < max_val:
                collect_range_nodes(node.right)
        
        collect_range_nodes(root)
        return lca_candidates

def test_bst_lca():
    """Test BST-specific LCA implementations"""
    
    # Create BST:
    #       6
    #     /   \
    #    2     8
    #   / \   / \
    #  0   4 7   9
    #     / \
    #    3   5
    
    bst_root = TreeNode(6)
    bst_root.left = TreeNode(2)
    bst_root.right = TreeNode(8)
    bst_root.left.left = TreeNode(0)
    bst_root.left.right = TreeNode(4)
    bst_root.right.left = TreeNode(7)
    bst_root.right.right = TreeNode(9)
    bst_root.left.right.left = TreeNode(3)
    bst_root.left.right.right = TreeNode(5)
    
    bst_lca = BSTLowestCommonAncestor()
    
    # Test value-based LCA
    test_queries = [(2, 8), (2, 4), (3, 5), (0, 9), (7, 9)]
    
    print("\nBST LCA Test Results:")
    print("=" * 40)
    
    results = bst_lca.range_lca_queries(bst_root, test_queries)
    
    for i, (p, q) in enumerate(test_queries):
        print(f"LCA({p}, {q}) = {results[i]}")
    
    # Test range LCA
    range_nodes = bst_lca.lca_in_bst_range(bst_root, 3, 7)
    print(f"\nNodes in range [3,7]: {[node.val for node in range_nodes]}")

test_bst_lca()
```

**LCA Applications and Advanced Scenarios:**
```python
class LCAApplications:
    """
    Real-world applications of LCA algorithms
    """
    
    def __init__(self):
        self.lca_finder = LowestCommonAncestor()
    
    def organizational_hierarchy_lca(self, org_tree, employee1, employee2):
        """
        Find common manager in organizational hierarchy
        """
        lca_result = self.lca_finder.lca_binary_tree(org_tree, employee1, employee2)
        
        return {
            'common_manager': lca_result.val if lca_result else None,
            'employees': [employee1.val, employee2.val],
            'reporting_structure': self._get_reporting_path(org_tree, employee1, lca_result)
        }
    
    def _get_reporting_path(self, root, employee, manager):
        """Get reporting path from employee to manager"""
        path = []
        
        def find_path(node, target, current_path):
            if node is None:
                return False
            
            current_path.append(node.val)
            
            if node == target:
                return True
            
            if (find_path(node.left, target, current_path) or 
                find_path(node.right, target, current_path)):
                return True
            
            current_path.pop()
            return False
        
        find_path(root, manager, path)
        return path
    
    def file_system_common_directory(self, fs_tree, file1, file2):
        """
        Find common parent directory in file system tree
        """
        lca_dir = self.lca_finder.lca_binary_tree(fs_tree, file1, file2)
        
        return {
            'common_directory': lca_dir.val if lca_dir else None,
            'relative_path_file1': self._get_relative_path(lca_dir, file1),
            'relative_path_file2': self._get_relative_path(lca_dir, file2)
        }
    
    def _get_relative_path(self, root, target):
        """Get relative path from root to target"""
        # Simplified implementation
        return f"path/to/{target.val}"
    
    def network_routing_common_node(self, network_tree, node1, node2):
        """
        Find common routing node in network topology
        """
        lca_router = self.lca_finder.lca_binary_tree(network_tree, node1, node2)
        distance = self.lca_finder.find_distance_via_lca(network_tree, node1, node2)
        
        return {
            'common_router': lca_router.val if lca_router else None,
            'routing_distance': distance,
            'optimal_path_exists': distance != -1
        }
    
    def taxonomy_classification_lca(self, taxonomy_tree, species1, species2):
        """
        Find common taxonomic classification
        """
        lca_classification = self.lca_finder.lca_binary_tree(taxonomy_tree, species1, species2)
        level_info = self.lca_finder.lca_with_level_info(taxonomy_tree, species1, species2)
        
        classification_levels = ['Kingdom', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species']
        
        return {
            'common_classification': lca_classification.val if lca_classification else None,
            'classification_level': classification_levels[level_info['level']] if level_info['level'] < len(classification_levels) else 'Unknown',
            'taxonomic_distance': self.lca_finder.find_distance_via_lca(taxonomy_tree, species1, species2)
        }

def test_lca_applications():
    """Test real-world LCA applications"""
    
    # Create organizational hierarchy
    #       CEO
    #      /   \
    #    CTO    CFO
    #   /  \    /
    #  Dev QA  Acc
    
    ceo = TreeNode("CEO")
    cto = TreeNode("CTO")
    cfo = TreeNode("CFO")
    dev = TreeNode("Developer")
    qa = TreeNode("QA")
    acc = TreeNode("Accountant")
    
    ceo.left = cto
    ceo.right = cfo
    cto.left = dev
    cto.right = qa
    cfo.left = acc
    
    apps = LCAApplications()
    
    # Test organizational hierarchy
    org_result = apps.organizational_hierarchy_lca(ceo, dev, qa)
    print("Organizational Hierarchy LCA:")
    print(f"Common manager of Developer and QA: {org_result}")
    
    # Test network routing
    network_result = apps.network_routing_common_node(ceo, dev, acc)
    print(f"\nNetwork routing result: {network_result}")

test_lca_applications()
```

**Performance Analysis and Optimization:**
```python
class LCAPerformanceAnalyzer:
    """
    Analyze performance of different LCA algorithms
    """
    
    def __init__(self):
        pass
    
    def compare_lca_algorithms(self):
        """Compare time and space complexity of LCA algorithms"""
        
        algorithms = {
            'Binary Tree LCA': {
                'time': 'O(n)',
                'space': 'O(h)',
                'best_case': 'Balanced tree',
                'worst_case': 'Skewed tree',
                'use_case': 'General binary trees'
            },
            'BST LCA': {
                'time': 'O(h)',
                'space': 'O(h) recursive, O(1) iterative',
                'best_case': 'Balanced BST',
                'worst_case': 'Skewed BST',
                'use_case': 'Binary search trees'
            },
            'Path-based LCA': {
                'time': 'O(n)',
                'space': 'O(h)',
                'best_case': 'Short paths',
                'worst_case': 'Long paths',
                'use_case': 'When paths are needed'
            },
            'Parent Pointer LCA': {
                'time': 'O(h)',
                'space': 'O(h)',
                'best_case': 'Balanced tree',
                'worst_case': 'Skewed tree',
                'use_case': 'Nodes have parent pointers'
            }
        }
        
        print("LCA Algorithm Comparison:")
        print("=" * 80)
        print(f"{'Algorithm':<20} {'Time':<15} {'Space':<20} {'Best Use Case':<25}")
        print("-" * 80)
        
        for name, props in algorithms.items():
            print(f"{name:<20} {props['time']:<15} {props['space']:<20} {props['use_case']:<25}")
    
    def memory_usage_analysis(self):
        """Analyze memory usage patterns"""
        
        print("\nMemory Usage Analysis:")
        print("=" * 40)
        print("Stack depth (worst case):")
        print("- Balanced tree: O(log n)")
        print("- Skewed tree: O(n)")
        print("\nAuxiliary space:")
        print("- Path storage: O(h)")
        print("- Parent tracking: O(h)")
        print("- Iterative approach: O(1)")

def test_lca_performance():
    """Test LCA performance analysis"""
    
    analyzer = LCAPerformanceAnalyzer()
    analyzer.compare_lca_algorithms()
    analyzer.memory_usage_analysis()

test_lca_performance()
```

**Key Insights:**

| Scenario | Best Algorithm | Time Complexity | Space Complexity | Notes |
|----------|---------------|-----------------|------------------|-------|
| **Binary Tree** | Recursive LCA | O(n) | O(h) | Most general solution |
| **Binary Search Tree** | BST LCA | O(h) | O(1) iterative | Leverages BST property |
| **Multiple Queries** | Preprocessing + LCA | O(log n) per query | O(n) preprocessing | Use LCA with preprocessing |
| **Parent Pointers** | Parent Pointer LCA | O(h) | O(h) | Efficient when available |
| **Distance Calculation** | LCA + Distance | O(n) | O(h) | Combines LCA with path finding |

**Important Properties:**
1. **LCA is unique** for any two nodes in a tree
2. **LCA(x,y) = LCA(y,x)** (commutative property)
3. **LCA(x,x) = x** (node is ancestor of itself)
4. **In BST**, LCA can be found in O(h) time
5. **LCA applications** include routing, file systems, organizational charts

Lowest Common Ancestor is a fundamental tree algorithm with many practical applications! ðŸŒ³

---

*These comprehensive answers cover advanced BST validation and LCA algorithms with multiple approaches, real-world applications, and performance analysis. Perfect for understanding both theoretical concepts and production implementations! ðŸš€*
