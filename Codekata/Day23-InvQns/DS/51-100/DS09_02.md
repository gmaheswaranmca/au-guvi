# DATA STRUCTURES - BEGINNER LEVEL INTERVIEW ANSWERS (SET 2 - Part 8)

> **Target:** IT, CS, AI, ML, ECE candidates  
> **Level:** Beginner  
> **Companies:** Google, Amazon, Microsoft, Facebook, Zoho, etc.  
> **Category:** Data Structures (Extended Set) - Questions 33-34

## ðŸ“‹ Table of Contents
- [ðŸŒ³ Tree Operations & Types](#ðŸŒ³-tree-operations--types) (Questions 33-34)

---

## ðŸŒ³ Tree Operations & Types

### 33. **What is a perfect binary tree?** *(Facebook, Google)*

**Perfect Binary Tree Definition:** A binary tree in which all internal nodes have exactly two children and all leaf nodes are at the same level.

**Key Characteristics:**
- **All levels completely filled** with maximum possible nodes
- **All leaf nodes at same level** (deepest level)
- **Every internal node has exactly 2 children**
- **Most balanced** form of binary tree
- **Optimal height** for given number of nodes

**Properties of Perfect Binary Tree:**
```python
class TreeNode:
    """Binary tree node definition"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
    
    def __repr__(self):
        return f"TreeNode({self.val})"

class PerfectBinaryTree:
    """
    Perfect Binary Tree implementation and analysis
    """
    
    def __init__(self):
        pass
    
    def is_perfect_tree(self, root):
        """
        Check if a binary tree is perfect
        Time: O(n), Space: O(h)
        """
        if root is None:
            return True
        
        def get_height(node):
            """Calculate height of tree"""
            if node is None:
                return -1
            return 1 + max(get_height(node.left), get_height(node.right))
        
        def is_perfect_helper(node, height, current_level=0):
            """Helper function to check perfect tree property"""
            if node is None:
                return current_level == height
            
            # Leaf node check
            if node.left is None and node.right is None:
                return current_level == height
            
            # Internal node must have both children
            if node.left is None or node.right is None:
                return False
            
            # Recursively check both subtrees
            return (is_perfect_helper(node.left, height, current_level + 1) and
                    is_perfect_helper(node.right, height, current_level + 1))
        
        height = get_height(root)
        return is_perfect_helper(root, height)
    
    def is_perfect_tree_optimized(self, root):
        """
        Optimized version using node count validation
        Time: O(n), Space: O(h)
        """
        def count_nodes(node):
            if node is None:
                return 0
            return 1 + count_nodes(node.left) + count_nodes(node.right)
        
        def get_height(node):
            if node is None:
                return -1
            return 1 + max(get_height(node.left), get_height(node.right))
        
        if root is None:
            return True
        
        height = get_height(root)
        node_count = count_nodes(root)
        expected_nodes = (2 ** (height + 1)) - 1
        
        # Perfect tree must have exact number of nodes for its height
        if node_count != expected_nodes:
            return False
        
        # Additional validation using structure check
        return self._check_perfect_structure(root, height, 0)
    
    def _check_perfect_structure(self, node, height, level):
        """Check if tree maintains perfect structure"""
        if node is None:
            return level == height
        
        if level == height:
            return node.left is None and node.right is None
        
        return (node.left is not None and node.right is not None and
                self._check_perfect_structure(node.left, height, level + 1) and
                self._check_perfect_structure(node.right, height, level + 1))
    
    def build_perfect_tree(self, height):
        """
        Build a perfect binary tree of given height
        Time: O(n), Space: O(n) where n = 2^(height+1) - 1
        """
        if height < 0:
            return None
        
        node_counter = [1]  # Use list for mutable counter
        
        def build_recursive(current_height):
            if current_height < 0:
                return None
            
            node = TreeNode(node_counter[0])
            node_counter[0] += 1
            
            if current_height > 0:
                node.left = build_recursive(current_height - 1)
                node.right = build_recursive(current_height - 1)
            
            return node
        
        return build_recursive(height)
    
    def build_perfect_tree_from_array(self, height):
        """
        Build perfect tree from array representation
        """
        if height < 0:
            return None
        
        total_nodes = (2 ** (height + 1)) - 1
        values = list(range(1, total_nodes + 1))
        
        def build_from_array(index):
            if index >= len(values):
                return None
            
            node = TreeNode(values[index])
            node.left = build_from_array(2 * index + 1)
            node.right = build_from_array(2 * index + 2)
            return node
        
        return build_from_array(0)
    
    def get_perfect_tree_properties(self, root):
        """
        Analyze properties of perfect binary tree
        """
        if root is None:
            return {
                'is_perfect': True,
                'height': -1,
                'total_nodes': 0,
                'leaf_nodes': 0,
                'internal_nodes': 0,
                'levels': 0,
                'max_width': 0,
                'space_efficiency': 1.0
            }
        
        is_perfect = self.is_perfect_tree(root)
        height = self._calculate_height(root)
        total_nodes = self._count_nodes(root)
        leaf_nodes = self._count_leaves(root)
        internal_nodes = total_nodes - leaf_nodes
        levels = height + 1
        max_width = 2 ** height if height >= 0 else 0
        expected_nodes = (2 ** (height + 1)) - 1 if height >= 0 else 0
        space_efficiency = total_nodes / expected_nodes if expected_nodes > 0 else 1.0
        
        return {
            'is_perfect': is_perfect,
            'height': height,
            'total_nodes': total_nodes,
            'leaf_nodes': leaf_nodes,
            'internal_nodes': internal_nodes,
            'levels': levels,
            'max_width': max_width,
            'space_efficiency': space_efficiency
        }
    
    def _calculate_height(self, root):
        """Calculate tree height"""
        if root is None:
            return -1
        return 1 + max(self._calculate_height(root.left), 
                      self._calculate_height(root.right))
    
    def _count_nodes(self, root):
        """Count total nodes"""
        if root is None:
            return 0
        return 1 + self._count_nodes(root.left) + self._count_nodes(root.right)
    
    def _count_leaves(self, root):
        """Count leaf nodes"""
        if root is None:
            return 0
        if root.left is None and root.right is None:
            return 1
        return self._count_leaves(root.left) + self._count_leaves(root.right)

# Test perfect binary tree operations
def test_perfect_binary_tree():
    """Test perfect binary tree identification and properties"""
    
    pbt = PerfectBinaryTree()
    
    # Test Case 1: Perfect binary tree (height 2)
    #       1
    #      / \
    #     2   3
    #    / \ / \
    #   4  5 6  7
    perfect_tree = TreeNode(1)
    perfect_tree.left = TreeNode(2)
    perfect_tree.right = TreeNode(3)
    perfect_tree.left.left = TreeNode(4)
    perfect_tree.left.right = TreeNode(5)
    perfect_tree.right.left = TreeNode(6)
    perfect_tree.right.right = TreeNode(7)
    
    # Test Case 2: Complete but not perfect
    #       1
    #      / \
    #     2   3
    #    / \ /
    #   4  5 6
    complete_tree = TreeNode(1)
    complete_tree.left = TreeNode(2)
    complete_tree.right = TreeNode(3)
    complete_tree.left.left = TreeNode(4)
    complete_tree.left.right = TreeNode(5)
    complete_tree.right.left = TreeNode(6)
    
    # Test Case 3: Full but not perfect
    #       1
    #      / \
    #     2   3
    #        / \
    #       6   7
    #      / \
    #     12 13
    full_tree = TreeNode(1)
    full_tree.left = TreeNode(2)
    full_tree.right = TreeNode(3)
    full_tree.right.left = TreeNode(6)
    full_tree.right.right = TreeNode(7)
    full_tree.right.left.left = TreeNode(12)
    full_tree.right.left.right = TreeNode(13)
    
    # Test Case 4: Generated perfect trees
    generated_perfect_h1 = pbt.build_perfect_tree(1)
    generated_perfect_h2 = pbt.build_perfect_tree_from_array(2)
    
    test_cases = [
        ('Perfect Tree (Manual)', perfect_tree),
        ('Complete Tree (Not Perfect)', complete_tree),
        ('Full Tree (Not Perfect)', full_tree),
        ('Generated Perfect H=1', generated_perfect_h1),
        ('Generated Perfect H=2', generated_perfect_h2),
        ('Empty Tree', None),
        ('Single Node', TreeNode(1))
    ]
    
    print("Perfect Binary Tree Analysis:")
    print("=" * 50)
    
    for name, tree in test_cases:
        print(f"\n{name}:")
        
        # Check if perfect using both methods
        is_perfect_basic = pbt.is_perfect_tree(tree)
        is_perfect_optimized = pbt.is_perfect_tree_optimized(tree)
        
        print(f"  Is Perfect (Basic): {is_perfect_basic}")
        print(f"  Is Perfect (Optimized): {is_perfect_optimized}")
        print(f"  Methods Match: {'âœ“' if is_perfect_basic == is_perfect_optimized else 'âœ—'}")
        
        # Get detailed properties
        properties = pbt.get_perfect_tree_properties(tree)
        print(f"  Properties: {properties}")

test_perfect_binary_tree()
```

**Mathematical Properties of Perfect Binary Trees:**
```python
class PerfectTreeMath:
    """Mathematical analysis of perfect binary trees"""
    
    def __init__(self):
        pass
    
    def calculate_perfect_tree_metrics(self, height):
        """
        Calculate all mathematical properties of perfect tree
        """
        if height < 0:
            return {
                'height': -1,
                'total_nodes': 0,
                'leaf_nodes': 0,
                'internal_nodes': 0,
                'levels': 0,
                'max_width': 0,
                'sum_of_nodes_formula': 0
            }
        
        total_nodes = (2 ** (height + 1)) - 1
        leaf_nodes = 2 ** height
        internal_nodes = total_nodes - leaf_nodes
        levels = height + 1
        max_width = leaf_nodes
        
        # Sum of nodes if values are 1, 2, 3, ..., n
        sum_of_nodes = total_nodes * (total_nodes + 1) // 2
        
        return {
            'height': height,
            'total_nodes': total_nodes,
            'leaf_nodes': leaf_nodes,
            'internal_nodes': internal_nodes,
            'levels': levels,
            'max_width': max_width,
            'sum_of_nodes_formula': sum_of_nodes
        }
    
    def verify_perfect_tree_formulas(self, max_height=5):
        """Verify mathematical formulas for perfect trees"""
        
        print("Perfect Binary Tree Mathematical Properties:")
        print("=" * 60)
        print(f"{'Height':<8} {'Nodes':<8} {'Leaves':<8} {'Internal':<10} {'Levels':<8} {'Width':<8}")
        print("-" * 60)
        
        for h in range(max_height + 1):
            metrics = self.calculate_perfect_tree_metrics(h)
            print(f"{h:<8} {metrics['total_nodes']:<8} {metrics['leaf_nodes']:<8} "
                  f"{metrics['internal_nodes']:<10} {metrics['levels']:<8} {metrics['max_width']:<8}")
        
        print("\nFormulas Verification:")
        print("â€¢ Total nodes = 2^(h+1) - 1")
        print("â€¢ Leaf nodes = 2^h")
        print("â€¢ Internal nodes = 2^h - 1")
        print("â€¢ Levels = h + 1")
        print("â€¢ Max width = 2^h")
    
    def compare_tree_types_efficiency(self):
        """Compare space efficiency of different tree types"""
        
        heights = [1, 2, 3, 4, 5]
        
        print("\nTree Type Efficiency Comparison:")
        print("=" * 50)
        print(f"{'Height':<8} {'Perfect':<10} {'Complete':<10} {'Efficiency':<12}")
        print("-" * 50)
        
        for h in range(1, 6):
            perfect_nodes = (2 ** (h + 1)) - 1
            # For comparison: worst case complete tree (missing only last leaf)
            complete_nodes = perfect_nodes - 1
            efficiency = (complete_nodes / perfect_nodes) * 100
            
            print(f"{h:<8} {perfect_nodes:<10} {complete_nodes:<10} {efficiency:.1f}%")

def test_perfect_tree_math():
    """Test mathematical properties of perfect trees"""
    
    math_analyzer = PerfectTreeMath()
    math_analyzer.verify_perfect_tree_formulas()
    math_analyzer.compare_tree_types_efficiency()

test_perfect_tree_math()
```

**Real-world Applications:**

**Application 1: Tournament Bracket System**
```python
class TournamentBracket:
    """Tournament bracket using perfect binary tree"""
    
    def __init__(self, num_players):
        self.num_players = num_players
        self.height = self._calculate_tournament_height(num_players)
        self.bracket = None
        self.matches_played = set()
    
    def _calculate_tournament_height(self, players):
        """Calculate height needed for tournament"""
        import math
        if players <= 1:
            return 0
        return math.ceil(math.log2(players))
    
    def create_bracket(self, player_names):
        """Create tournament bracket"""
        if len(player_names) != self.num_players:
            raise ValueError("Number of players doesn't match")
        
        # Pad to perfect tree size
        perfect_size = 2 ** self.height
        padded_players = player_names + [None] * (perfect_size - len(player_names))
        
        self.bracket = self._build_tournament_tree(padded_players)
        return self.bracket
    
    def _build_tournament_tree(self, players):
        """Build tournament tree from players"""
        if len(players) == 1:
            return TournamentNode(players[0] if players[0] else "BYE")
        
        mid = len(players) // 2
        left_players = players[:mid]
        right_players = players[mid:]
        
        root = TournamentNode("TBD")
        root.left = self._build_tournament_tree(left_players)
        root.right = self._build_tournament_tree(right_players)
        
        return root
    
    def simulate_match(self, winner, match_id):
        """Simulate a match result"""
        # Implementation would update tournament tree
        self.matches_played.add(match_id)
        return f"Match {match_id}: {winner} wins"
    
    def get_tournament_status(self):
        """Get current tournament status"""
        pbt = PerfectBinaryTree()
        properties = pbt.get_perfect_tree_properties(self.bracket)
        
        total_matches = self.num_players - 1  # In elimination tournament
        matches_remaining = total_matches - len(self.matches_played)
        
        return {
            'total_players': self.num_players,
            'bracket_height': self.height,
            'total_matches': total_matches,
            'matches_played': len(self.matches_played),
            'matches_remaining': matches_remaining,
            'is_perfect_bracket': properties['is_perfect']
        }

class TournamentNode:
    """Node for tournament bracket"""
    def __init__(self, player_or_result):
        self.val = player_or_result
        self.left = None
        self.right = None

def test_tournament_bracket():
    """Test tournament bracket implementation"""
    
    players = ["Alice", "Bob", "Charlie", "David", "Eve", "Frank"]
    tournament = TournamentBracket(len(players))
    
    bracket = tournament.create_bracket(players)
    status = tournament.get_tournament_status()
    
    print("Tournament Bracket Analysis:")
    print("=" * 40)
    for key, value in status.items():
        print(f"{key}: {value}")

test_tournament_bracket()
```

**Application 2: Memory Allocation Tree**
```python
class MemoryAllocationTree:
    """Memory allocation using perfect binary tree structure"""
    
    def __init__(self, total_memory_size):
        self.total_size = total_memory_size
        self.height = self._calculate_height_for_size(total_memory_size)
        self.memory_tree = self._initialize_memory_tree()
        self.allocated_blocks = {}
    
    def _calculate_height_for_size(self, size):
        """Calculate tree height needed for memory size"""
        import math
        if size <= 1:
            return 0
        return math.ceil(math.log2(size))
    
    def _initialize_memory_tree(self):
        """Initialize memory allocation tree"""
        pbt = PerfectBinaryTree()
        tree = pbt.build_perfect_tree(self.height)
        self._annotate_memory_blocks(tree, 0, self.total_size)
        return tree
    
    def _annotate_memory_blocks(self, node, start_addr, size):
        """Annotate each node with memory block information"""
        if node is None:
            return
        
        node.start_addr = start_addr
        node.size = size
        node.is_allocated = False
        
        if node.left or node.right:
            mid_size = size // 2
            if node.left:
                self._annotate_memory_blocks(node.left, start_addr, mid_size)
            if node.right:
                self._annotate_memory_blocks(node.right, start_addr + mid_size, mid_size)
    
    def allocate_memory(self, requested_size, block_id):
        """Allocate memory block"""
        allocated_node = self._find_suitable_block(self.memory_tree, requested_size)
        
        if allocated_node:
            allocated_node.is_allocated = True
            self.allocated_blocks[block_id] = allocated_node
            return {
                'success': True,
                'start_address': allocated_node.start_addr,
                'allocated_size': allocated_node.size,
                'block_id': block_id
            }
        
        return {'success': False, 'reason': 'No suitable block found'}
    
    def _find_suitable_block(self, node, requested_size):
        """Find suitable memory block for allocation"""
        if node is None or node.is_allocated:
            return None
        
        if node.size >= requested_size and (node.left is None or node.size <= requested_size * 2):
            return node
        
        # Try left subtree first (smaller blocks)
        left_result = self._find_suitable_block(node.left, requested_size)
        if left_result:
            return left_result
        
        # Try right subtree
        return self._find_suitable_block(node.right, requested_size)
    
    def deallocate_memory(self, block_id):
        """Deallocate memory block"""
        if block_id in self.allocated_blocks:
            node = self.allocated_blocks[block_id]
            node.is_allocated = False
            del self.allocated_blocks[block_id]
            return {'success': True, 'deallocated_size': node.size}
        
        return {'success': False, 'reason': 'Block not found'}
    
    def get_memory_status(self):
        """Get current memory allocation status"""
        total_allocated = sum(node.size for node in self.allocated_blocks.values())
        free_memory = self.total_size - total_allocated
        fragmentation = self._calculate_fragmentation()
        
        return {
            'total_memory': self.total_size,
            'allocated_memory': total_allocated,
            'free_memory': free_memory,
            'utilization_percent': (total_allocated / self.total_size) * 100,
            'fragmentation_percent': fragmentation,
            'active_blocks': len(self.allocated_blocks)
        }
    
    def _calculate_fragmentation(self):
        """Calculate memory fragmentation percentage"""
        # Simplified fragmentation calculation
        free_blocks = self._count_free_blocks(self.memory_tree)
        max_possible_blocks = (2 ** (self.height + 1)) - 1
        return (free_blocks / max_possible_blocks) * 100 if max_possible_blocks > 0 else 0
    
    def _count_free_blocks(self, node):
        """Count free memory blocks"""
        if node is None:
            return 0
        
        count = 0 if node.is_allocated else 1
        
        if node.left:
            count += self._count_free_blocks(node.left)
        if node.right:
            count += self._count_free_blocks(node.right)
        
        return count

def test_memory_allocation():
    """Test memory allocation system"""
    
    memory_system = MemoryAllocationTree(1024)  # 1KB total memory
    
    # Allocate some blocks
    allocations = [
        (128, "block1"),
        (256, "block2"),
        (64, "block3"),
        (512, "block4")
    ]
    
    print("Memory Allocation Test:")
    print("=" * 40)
    
    for size, block_id in allocations:
        result = memory_system.allocate_memory(size, block_id)
        print(f"Allocate {size}B as {block_id}: {result}")
    
    status = memory_system.get_memory_status()
    print(f"\nMemory Status: {status}")
    
    # Deallocate some blocks
    memory_system.deallocate_memory("block2")
    memory_system.deallocate_memory("block3")
    
    final_status = memory_system.get_memory_status()
    print(f"\nFinal Memory Status: {final_status}")

test_memory_allocation()
```

---

### 34. **What is a balanced binary tree?** *(Amazon, Microsoft)*

**Balanced Binary Tree Definition:** A binary tree in which the height difference between left and right subtrees of any node is at most 1.

**Key Characteristics:**
- **Height difference â‰¤ 1** for every node
- **Maintains O(log n) height** for n nodes
- **Efficient operations** due to balanced structure
- **Self-balancing variants** exist (AVL, Red-Black)
- **Good performance** for search, insertion, deletion

**Types of Balanced Trees:**
```python
class BalancedBinaryTree:
    """
    Balanced Binary Tree implementation and analysis
    """
    
    def __init__(self):
        pass
    
    def is_balanced_tree(self, root):
        """
        Check if a binary tree is balanced
        Time: O(n), Space: O(h)
        """
        def check_balance(node):
            """
            Returns (is_balanced, height)
            """
            if node is None:
                return True, -1
            
            # Check left subtree
            left_balanced, left_height = check_balance(node.left)
            if not left_balanced:
                return False, -1
            
            # Check right subtree
            right_balanced, right_height = check_balance(node.right)
            if not right_balanced:
                return False, -1
            
            # Check current node balance
            height_diff = abs(left_height - right_height)
            is_balanced = height_diff <= 1
            current_height = 1 + max(left_height, right_height)
            
            return is_balanced, current_height
        
        balanced, _ = check_balance(root)
        return balanced
    
    def get_balance_factor(self, root):
        """
        Get balance factor for each node
        Balance factor = height(left) - height(right)
        """
        if root is None:
            return {}
        
        balance_factors = {}
        
        def calculate_balance_factors(node):
            if node is None:
                return -1
            
            left_height = calculate_balance_factors(node.left)
            right_height = calculate_balance_factors(node.right)
            
            balance_factor = left_height - right_height
            balance_factors[node.val] = balance_factor
            
            return 1 + max(left_height, right_height)
        
        calculate_balance_factors(root)
        return balance_factors
    
    def analyze_tree_balance(self, root):
        """
        Comprehensive balance analysis
        """
        if root is None:
            return {
                'is_balanced': True,
                'height': -1,
                'total_nodes': 0,
                'balance_factors': {},
                'max_balance_factor': 0,
                'imbalanced_nodes': [],
                'balance_score': 1.0
            }
        
        is_balanced = self.is_balanced_tree(root)
        height = self._calculate_height(root)
        total_nodes = self._count_nodes(root)
        balance_factors = self.get_balance_factor(root)
        
        # Find imbalanced nodes
        imbalanced_nodes = [
            node for node, bf in balance_factors.items() 
            if abs(bf) > 1
        ]
        
        max_balance_factor = max(abs(bf) for bf in balance_factors.values()) if balance_factors else 0
        
        # Calculate balance score (0 = worst, 1 = perfect)
        ideal_height = self._calculate_ideal_height(total_nodes)
        balance_score = ideal_height / height if height > 0 else 1.0
        
        return {
            'is_balanced': is_balanced,
            'height': height,
            'total_nodes': total_nodes,
            'balance_factors': balance_factors,
            'max_balance_factor': max_balance_factor,
            'imbalanced_nodes': imbalanced_nodes,
            'balance_score': min(balance_score, 1.0)
        }
    
    def _calculate_height(self, root):
        """Calculate tree height"""
        if root is None:
            return -1
        return 1 + max(self._calculate_height(root.left), 
                      self._calculate_height(root.right))
    
    def _count_nodes(self, root):
        """Count total nodes"""
        if root is None:
            return 0
        return 1 + self._count_nodes(root.left) + self._count_nodes(root.right)
    
    def _calculate_ideal_height(self, n):
        """Calculate ideal height for n nodes"""
        import math
        if n <= 0:
            return -1
        return math.floor(math.log2(n))
    
    def balance_tree_simple(self, root):
        """
        Simple tree balancing using sorted array approach
        Time: O(n), Space: O(n)
        """
        if root is None:
            return None
        
        # Get sorted array of values
        values = []
        self._inorder_traversal(root, values)
        
        # Build balanced tree from sorted array
        return self._build_balanced_from_sorted(values, 0, len(values) - 1)
    
    def _inorder_traversal(self, root, values):
        """Inorder traversal to get sorted values"""
        if root:
            self._inorder_traversal(root.left, values)
            values.append(root.val)
            self._inorder_traversal(root.right, values)
    
    def _build_balanced_from_sorted(self, values, start, end):
        """Build balanced tree from sorted array"""
        if start > end:
            return None
        
        mid = (start + end) // 2
        node = TreeNode(values[mid])
        
        node.left = self._build_balanced_from_sorted(values, start, mid - 1)
        node.right = self._build_balanced_from_sorted(values, mid + 1, end)
        
        return node

# Test balanced binary tree operations
def test_balanced_binary_tree():
    """Test balanced binary tree identification and analysis"""
    
    bbt = BalancedBinaryTree()
    
    # Test Case 1: Balanced tree
    #       4
    #      / \
    #     2   6
    #    / \ / \
    #   1  3 5  7
    balanced_tree = TreeNode(4)
    balanced_tree.left = TreeNode(2)
    balanced_tree.right = TreeNode(6)
    balanced_tree.left.left = TreeNode(1)
    balanced_tree.left.right = TreeNode(3)
    balanced_tree.right.left = TreeNode(5)
    balanced_tree.right.right = TreeNode(7)
    
    # Test Case 2: Unbalanced tree (skewed)
    #   1
    #    \
    #     2
    #      \
    #       3
    #        \
    #         4
    #          \
    #           5
    unbalanced_tree = TreeNode(1)
    unbalanced_tree.right = TreeNode(2)
    unbalanced_tree.right.right = TreeNode(3)
    unbalanced_tree.right.right.right = TreeNode(4)
    unbalanced_tree.right.right.right.right = TreeNode(5)
    
    # Test Case 3: Slightly unbalanced
    #       4
    #      / \
    #     2   6
    #    / \   \
    #   1   3   7
    #          /
    #         5
    #        /
    #       4.5
    slightly_unbalanced = TreeNode(4)
    slightly_unbalanced.left = TreeNode(2)
    slightly_unbalanced.right = TreeNode(6)
    slightly_unbalanced.left.left = TreeNode(1)
    slightly_unbalanced.left.right = TreeNode(3)
    slightly_unbalanced.right.right = TreeNode(7)
    slightly_unbalanced.right.right.left = TreeNode(5)
    slightly_unbalanced.right.right.left.left = TreeNode(4.5)
    
    test_cases = [
        ('Balanced Tree', balanced_tree),
        ('Unbalanced Tree (Skewed)', unbalanced_tree),
        ('Slightly Unbalanced', slightly_unbalanced),
        ('Empty Tree', None),
        ('Single Node', TreeNode(1))
    ]
    
    print("Balanced Binary Tree Analysis:")
    print("=" * 50)
    
    for name, tree in test_cases:
        print(f"\n{name}:")
        
        analysis = bbt.analyze_tree_balance(tree)
        
        print(f"  Is Balanced: {analysis['is_balanced']}")
        print(f"  Height: {analysis['height']}")
        print(f"  Total Nodes: {analysis['total_nodes']}")
        print(f"  Max Balance Factor: {analysis['max_balance_factor']}")
        print(f"  Balance Score: {analysis['balance_score']:.3f}")
        
        if analysis['imbalanced_nodes']:
            print(f"  Imbalanced Nodes: {analysis['imbalanced_nodes']}")
        
        if analysis['balance_factors']:
            print(f"  Balance Factors: {analysis['balance_factors']}")

test_balanced_binary_tree()
```

**AVL Tree Implementation (Self-Balancing):**
```python
class AVLNode:
    """AVL Tree node with height tracking"""
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None
        self.height = 0

class AVLTree:
    """
    AVL Tree (Self-balancing binary search tree)
    Maintains balance factor of -1, 0, or 1 for all nodes
    """
    
    def __init__(self):
        self.root = None
    
    def insert(self, val):
        """Insert value while maintaining balance"""
        self.root = self._insert_recursive(self.root, val)
    
    def _insert_recursive(self, node, val):
        """Recursive insertion with balancing"""
        # Step 1: Normal BST insertion
        if node is None:
            return AVLNode(val)
        
        if val < node.val:
            node.left = self._insert_recursive(node.left, val)
        elif val > node.val:
            node.right = self._insert_recursive(node.right, val)
        else:
            return node  # Duplicate values not allowed
        
        # Step 2: Update height
        node.height = 1 + max(self._get_height(node.left), 
                             self._get_height(node.right))
        
        # Step 3: Get balance factor
        balance = self._get_balance_factor(node)
        
        # Step 4: Perform rotations if unbalanced
        # Left Left Case
        if balance > 1 and val < node.left.val:
            return self._rotate_right(node)
        
        # Right Right Case
        if balance < -1 and val > node.right.val:
            return self._rotate_left(node)
        
        # Left Right Case
        if balance > 1 and val > node.left.val:
            node.left = self._rotate_left(node.left)
            return self._rotate_right(node)
        
        # Right Left Case
        if balance < -1 and val < node.right.val:
            node.right = self._rotate_right(node.right)
            return self._rotate_left(node)
        
        return node
    
    def _get_height(self, node):
        """Get height of node"""
        if node is None:
            return -1
        return node.height
    
    def _get_balance_factor(self, node):
        """Get balance factor of node"""
        if node is None:
            return 0
        return self._get_height(node.left) - self._get_height(node.right)
    
    def _rotate_left(self, z):
        """Left rotation"""
        y = z.right
        T2 = y.left
        
        # Perform rotation
        y.left = z
        z.right = T2
        
        # Update heights
        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        
        return y
    
    def _rotate_right(self, z):
        """Right rotation"""
        y = z.left
        T3 = y.right
        
        # Perform rotation
        y.right = z
        z.left = T3
        
        # Update heights
        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        
        return y
    
    def search(self, val):
        """Search for value in AVL tree"""
        return self._search_recursive(self.root, val)
    
    def _search_recursive(self, node, val):
        """Recursive search"""
        if node is None or node.val == val:
            return node
        
        if val < node.val:
            return self._search_recursive(node.left, val)
        return self._search_recursive(node.right, val)
    
    def get_tree_properties(self):
        """Get comprehensive tree properties"""
        bbt = BalancedBinaryTree()
        
        # Convert AVL nodes to regular TreeNodes for analysis
        regular_tree = self._convert_to_tree_node(self.root)
        
        analysis = bbt.analyze_tree_balance(regular_tree)
        analysis['tree_type'] = 'AVL Tree'
        analysis['guaranteed_balanced'] = True
        
        return analysis
    
    def _convert_to_tree_node(self, avl_node):
        """Convert AVL node to regular TreeNode"""
        if avl_node is None:
            return None
        
        node = TreeNode(avl_node.val)
        node.left = self._convert_to_tree_node(avl_node.left)
        node.right = self._convert_to_tree_node(avl_node.right)
        return node
    
    def display_inorder(self):
        """Display tree in inorder (sorted)"""
        result = []
        self._inorder_traversal(self.root, result)
        return result
    
    def _inorder_traversal(self, node, result):
        """Inorder traversal"""
        if node:
            self._inorder_traversal(node.left, result)
            result.append(node.val)
            self._inorder_traversal(node.right, result)

def test_avl_tree():
    """Test AVL tree implementation"""
    
    avl = AVLTree()
    
    # Insert values that would create unbalanced tree
    values = [10, 20, 30, 40, 50, 25]
    
    print("AVL Tree Test:")
    print("=" * 30)
    print(f"Inserting values: {values}")
    
    for val in values:
        avl.insert(val)
        properties = avl.get_tree_properties()
        print(f"After inserting {val}: Balanced = {properties['is_balanced']}, "
              f"Height = {properties['height']}")
    
    print(f"\nFinal inorder traversal: {avl.display_inorder()}")
    
    final_properties = avl.get_tree_properties()
    print(f"Final tree properties: {final_properties}")

test_avl_tree()
```

**Comparison of Tree Balance Types:**
```python
class TreeBalanceComparator:
    """Compare different types of tree balance"""
    
    def __init__(self):
        self.bbt = BalancedBinaryTree()
    
    def compare_balance_definitions(self):
        """Compare different balance definitions"""
        
        # Create test trees
        trees = {
            'Perfect': self._create_perfect_tree(),
            'Complete': self._create_complete_tree(),
            'Height-Balanced': self._create_height_balanced_tree(),
            'AVL-Balanced': self._create_avl_balanced_tree(),
            'Unbalanced': self._create_unbalanced_tree()
        }
        
        print("Tree Balance Type Comparison:")
        print("=" * 60)
        print(f"{'Tree Type':<20} {'Height-Bal':<12} {'Height':<8} {'Nodes':<8} {'Score':<8}")
        print("-" * 60)
        
        for name, tree in trees.items():
            analysis = self.bbt.analyze_tree_balance(tree)
            
            print(f"{name:<20} {str(analysis['is_balanced']):<12} "
                  f"{analysis['height']:<8} {analysis['total_nodes']:<8} "
                  f"{analysis['balance_score']:.3f}")
    
    def _create_perfect_tree(self):
        """Create perfect binary tree"""
        #       4
        #      / \
        #     2   6
        #    / \ / \
        #   1  3 5  7
        root = TreeNode(4)
        root.left = TreeNode(2)
        root.right = TreeNode(6)
        root.left.left = TreeNode(1)
        root.left.right = TreeNode(3)
        root.right.left = TreeNode(5)
        root.right.right = TreeNode(7)
        return root
    
    def _create_complete_tree(self):
        """Create complete binary tree"""
        #       4
        #      / \
        #     2   6
        #    / \ /
        #   1  3 5
        root = TreeNode(4)
        root.left = TreeNode(2)
        root.right = TreeNode(6)
        root.left.left = TreeNode(1)
        root.left.right = TreeNode(3)
        root.right.left = TreeNode(5)
        return root
    
    def _create_height_balanced_tree(self):
        """Create height-balanced tree"""
        #       4
        #      / \
        #     2   6
        #    /   / \
        #   1   5   7
        #            \
        #             8
        root = TreeNode(4)
        root.left = TreeNode(2)
        root.right = TreeNode(6)
        root.left.left = TreeNode(1)
        root.right.left = TreeNode(5)
        root.right.right = TreeNode(7)
        root.right.right.right = TreeNode(8)
        return root
    
    def _create_avl_balanced_tree(self):
        """Create AVL-balanced tree"""
        # Same as height-balanced for this example
        return self._create_height_balanced_tree()
    
    def _create_unbalanced_tree(self):
        """Create unbalanced tree"""
        #   1
        #    \
        #     2
        #      \
        #       3
        #        \
        #         4
        root = TreeNode(1)
        root.right = TreeNode(2)
        root.right.right = TreeNode(3)
        root.right.right.right = TreeNode(4)
        return root
    
    def analyze_balance_performance(self):
        """Analyze performance characteristics of different balance types"""
        
        node_counts = [7, 15, 31, 63, 127]
        
        print("\nBalance Performance Analysis:")
        print("=" * 50)
        print(f"{'Nodes':<8} {'Perfect H':<10} {'Balanced H':<12} {'Unbalanced H':<14}")
        print("-" * 50)
        
        for n in node_counts:
            import math
            perfect_height = math.floor(math.log2(n))
            balanced_height = math.ceil(math.log2(n + 1))
            unbalanced_height = n - 1  # Worst case (linear)
            
            print(f"{n:<8} {perfect_height:<10} {balanced_height:<12} {unbalanced_height:<14}")

def test_balance_comparator():
    """Test tree balance comparator"""
    
    comparator = TreeBalanceComparator()
    comparator.compare_balance_definitions()
    comparator.analyze_balance_performance()

test_balance_comparator()
```

**Key Properties Summary:**

| Tree Type | Definition | Height Guarantee | Use Cases | Time Complexity |
|-----------|------------|------------------|-----------|-----------------|
| **Perfect** | All levels completely filled | logâ‚‚(n) | Theoretical analysis, tournaments | O(log n) |
| **Complete** | All levels filled except last, last filled left-to-right | âŒŠlogâ‚‚(n)âŒ‹ | Heaps, priority queues | O(log n) |
| **Height-Balanced** | Height difference â‰¤ 1 at each node | O(log n) | General balanced operations | O(log n) |
| **AVL** | Balance factor âˆˆ {-1, 0, 1} at each node | 1.44 Ã— logâ‚‚(n) | Database indexing, frequent searches | O(log n) |
| **Red-Black** | Colored nodes with balance rules | 2 Ã— logâ‚‚(n) | Java TreeMap, C++ map | O(log n) |

**Key Insights:**
1. **Perfect trees are most balanced** but impractical for dynamic operations
2. **Height-balanced trees guarantee O(log n) operations** for search, insert, delete
3. **AVL trees are strictly balanced** with fast searches but slower insertions
4. **Balance factor** indicates how "lopsided" a node is
5. **Self-balancing trees** automatically maintain balance during modifications

Balanced binary trees are crucial for maintaining efficient operations in dynamic data structures! ðŸŒ³

---

*These comprehensive answers cover advanced tree balance concepts with multiple implementation approaches, real-world examples, and practical applications. Perfect for understanding both theoretical concepts and production-ready implementations! ðŸš€*
