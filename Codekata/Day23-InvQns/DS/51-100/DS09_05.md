# DATA STRUCTURES - BEGINNER LEVEL INTERVIEW ANSWERS (SET 2 - Part 11)

> **Target:** IT, CS, AI, ML, ECE candidates  
> **Level:** Beginner  
> **Companies:** Google, Amazon, Microsoft, Facebook, Zoho, etc.  
> **Category:** Data Structures (Extended Set) - Questions 39-40

## üìã Table of Contents
- [üèîÔ∏è Heap Data Structure](#üèîÔ∏è-heap-data-structure) (Questions 39-40)

---

## üèîÔ∏è Heap Data Structure

### 39. **What is a heap data structure?** *(Amazon, Microsoft)*

**Heap Definition:** A heap is a specialized tree-based data structure that satisfies the heap property, where the value of each parent node has a specific ordering relationship with its children (either greater than or less than).

**Key Characteristics:**
- **Complete Binary Tree**: All levels are filled except possibly the last level, which is filled from left to right
- **Heap Property**: Parent-child relationship follows specific ordering rules
- **Array Representation**: Efficiently implemented using arrays with index-based parent-child relationships
- **Efficient Operations**: Insert and extract operations in O(log n) time
- **Priority Queue Implementation**: Primary use case for implementing priority queues

**Heap Properties and Types:**
```python
class HeapNode:
    """Node representation for heap visualization"""
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
    
    def __repr__(self):
        return f"HeapNode({self.val})"

class Heap:
    """
    Generic Heap Data Structure Implementation
    Supports both min-heap and max-heap operations
    """
    
    def __init__(self, heap_type='min'):
        """
        Initialize heap
        Args:
            heap_type: 'min' for min-heap, 'max' for max-heap
        """
        self.heap = []
        self.heap_type = heap_type.lower()
        self.size = 0
        
        # Comparison function based on heap type
        if self.heap_type == 'min':
            self.compare = lambda x, y: x < y
            self.heap_name = "Min-Heap"
        else:
            self.compare = lambda x, y: x > y
            self.heap_name = "Max-Heap"
    
    def _parent_index(self, index):
        """Get parent index for given node index"""
        return (index - 1) // 2
    
    def _left_child_index(self, index):
        """Get left child index for given node index"""
        return 2 * index + 1
    
    def _right_child_index(self, index):
        """Get right child index for given node index"""
        return 2 * index + 2
    
    def _has_parent(self, index):
        """Check if node has parent"""
        return self._parent_index(index) >= 0
    
    def _has_left_child(self, index):
        """Check if node has left child"""
        return self._left_child_index(index) < self.size
    
    def _has_right_child(self, index):
        """Check if node has right child"""
        return self._right_child_index(index) < self.size
    
    def _parent(self, index):
        """Get parent value"""
        return self.heap[self._parent_index(index)]
    
    def _left_child(self, index):
        """Get left child value"""
        return self.heap[self._left_child_index(index)]
    
    def _right_child(self, index):
        """Get right child value"""
        return self.heap[self._right_child_index(index)]
    
    def _swap(self, index1, index2):
        """Swap elements at two indices"""
        self.heap[index1], self.heap[index2] = self.heap[index2], self.heap[index1]
    
    def insert(self, value):
        """
        Insert element into heap
        Time: O(log n), Space: O(1)
        """
        # Add element at end
        self.heap.append(value)
        self.size += 1
        
        # Heapify up to maintain heap property
        self._heapify_up()
    
    def _heapify_up(self):
        """
        Heapify up operation to maintain heap property after insertion
        """
        index = self.size - 1
        
        # Keep moving up while heap property is violated
        while (self._has_parent(index) and 
               self.compare(self.heap[index], self._parent(index))):
            
            # Swap with parent
            parent_idx = self._parent_index(index)
            self._swap(index, parent_idx)
            index = parent_idx
    
    def extract_root(self):
        """
        Extract root element (min in min-heap, max in max-heap)
        Time: O(log n), Space: O(1)
        """
        if self.size == 0:
            raise IndexError("Heap is empty")
        
        # Store root value
        root = self.heap[0]
        
        # Move last element to root
        self.heap[0] = self.heap[self.size - 1]
        self.size -= 1
        self.heap.pop()
        
        # Heapify down to maintain heap property
        if self.size > 0:
            self._heapify_down()
        
        return root
    
    def _heapify_down(self):
        """
        Heapify down operation to maintain heap property after extraction
        """
        index = 0
        
        # Keep moving down while there are children
        while self._has_left_child(index):
            # Find the appropriate child to compare with
            smaller_child_index = self._left_child_index(index)
            
            # Compare with right child if it exists
            if (self._has_right_child(index) and 
                self.compare(self._right_child(index), self._left_child(index))):
                smaller_child_index = self._right_child_index(index)
            
            # If heap property is satisfied, stop
            if self.compare(self.heap[index], self.heap[smaller_child_index]):
                break
            
            # Swap with appropriate child
            self._swap(index, smaller_child_index)
            index = smaller_child_index
    
    def peek(self):
        """
        Get root element without removing it
        Time: O(1), Space: O(1)
        """
        if self.size == 0:
            raise IndexError("Heap is empty")
        return self.heap[0]
    
    def is_empty(self):
        """Check if heap is empty"""
        return self.size == 0
    
    def get_size(self):
        """Get heap size"""
        return self.size
    
    def build_heap(self, array):
        """
        Build heap from existing array
        Time: O(n), Space: O(1)
        """
        self.heap = array.copy()
        self.size = len(array)
        
        # Start from last non-leaf node and heapify down
        start_index = self._parent_index(self.size - 1)
        
        for i in range(start_index, -1, -1):
            self._heapify_down_at_index(i)
    
    def _heapify_down_at_index(self, index):
        """Heapify down starting from specific index"""
        while self._has_left_child(index):
            appropriate_child_index = self._left_child_index(index)
            
            if (self._has_right_child(index) and 
                self.compare(self._right_child(index), self._left_child(index))):
                appropriate_child_index = self._right_child_index(index)
            
            if self.compare(self.heap[index], self.heap[appropriate_child_index]):
                break
            
            self._swap(index, appropriate_child_index)
            index = appropriate_child_index
    
    def validate_heap_property(self):
        """
        Validate that heap property is maintained
        Returns: (is_valid, violations)
        """
        violations = []
        
        for i in range(self.size):
            # Check left child
            if self._has_left_child(i):
                left_idx = self._left_child_index(i)
                if not self.compare(self.heap[i], self.heap[left_idx]):
                    violations.append(f"Violation at {i}: parent={self.heap[i]}, left_child={self.heap[left_idx]}")
            
            # Check right child
            if self._has_right_child(i):
                right_idx = self._right_child_index(i)
                if not self.compare(self.heap[i], self.heap[right_idx]):
                    violations.append(f"Violation at {i}: parent={self.heap[i]}, right_child={self.heap[right_idx]}")
        
        return len(violations) == 0, violations
    
    def get_heap_levels(self):
        """Get heap elements organized by levels"""
        if self.size == 0:
            return []
        
        levels = []
        level = 0
        start_index = 0
        
        while start_index < self.size:
            level_size = min(2 ** level, self.size - start_index)
            level_elements = self.heap[start_index:start_index + level_size]
            levels.append(level_elements)
            
            start_index += level_size
            level += 1
        
        return levels
    
    def visualize_heap(self):
        """Create visual representation of heap"""
        if self.size == 0:
            return "Empty heap"
        
        levels = self.get_heap_levels()
        visualization = []
        
        visualization.append(f"\n{self.heap_name} Visualization:")
        visualization.append("=" * 40)
        
        for level_num, level in enumerate(levels):
            # Calculate spacing for centering
            max_width = 2 ** (len(levels) - 1) * 4
            level_width = len(level) * 4
            spacing = " " * ((max_width - level_width) // 2)
            
            level_str = spacing + "  ".join(f"{val:2}" for val in level)
            visualization.append(f"Level {level_num}: {level_str}")
        
        visualization.append(f"\nArray representation: {self.heap}")
        visualization.append(f"Heap type: {self.heap_name}")
        visualization.append(f"Size: {self.size}")
        
        return "\n".join(visualization)
    
    def to_list(self):
        """Convert heap to list (array representation)"""
        return self.heap.copy()

# Test basic heap operations
def test_basic_heap_operations():
    """Test fundamental heap operations"""
    
    print("Basic Heap Operations Test:")
    print("=" * 50)
    
    # Test Min-Heap
    print("Testing Min-Heap:")
    min_heap = Heap('min')
    
    # Insert elements
    elements = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]
    print(f"Inserting elements: {elements}")
    
    for element in elements:
        min_heap.insert(element)
        print(f"Inserted {element}, heap: {min_heap.to_list()}")
    
    print(min_heap.visualize_heap())
    
    # Validate heap property
    is_valid, violations = min_heap.validate_heap_property()
    print(f"\nHeap property valid: {is_valid}")
    if violations:
        for violation in violations[:3]:  # Show first 3 violations
            print(f"  {violation}")
    
    # Extract elements
    print(f"\nExtracting elements from min-heap:")
    extracted = []
    while not min_heap.is_empty():
        root = min_heap.extract_root()
        extracted.append(root)
        print(f"Extracted: {root}, heap: {min_heap.to_list()}")
    
    print(f"Extracted sequence: {extracted}")
    print(f"Is sorted (ascending): {extracted == sorted(extracted)}")
    
    print("\n" + "="*50)
    
    # Test Max-Heap
    print("Testing Max-Heap:")
    max_heap = Heap('max')
    
    # Insert same elements
    print(f"Inserting elements: {elements}")
    
    for element in elements:
        max_heap.insert(element)
    
    print(max_heap.visualize_heap())
    
    # Validate heap property
    is_valid, violations = max_heap.validate_heap_property()
    print(f"\nHeap property valid: {is_valid}")
    
    # Extract elements
    print(f"\nExtracting elements from max-heap:")
    extracted = []
    while not max_heap.is_empty():
        root = max_heap.extract_root()
        extracted.append(root)
        print(f"Extracted: {root}, heap: {max_heap.to_list()}")
    
    print(f"Extracted sequence: {extracted}")
    print(f"Is sorted (descending): {extracted == sorted(extracted, reverse=True)}")

test_basic_heap_operations()
```

**Advanced Heap Properties and Analysis:**
```python
class HeapAnalyzer:
    """
    Advanced heap analysis and properties
    """
    
    def __init__(self):
        pass
    
    def analyze_heap_properties(self, heap):
        """Analyze various heap properties"""
        if heap.size == 0:
            return {
                'height': -1,
                'total_nodes': 0,
                'leaf_nodes': 0,
                'internal_nodes': 0,
                'completeness': True,
                'balance_factor': 0
            }
        
        # Calculate height
        height = self._calculate_height(heap.size)
        
        # Count leaf and internal nodes
        leaf_count = self._count_leaf_nodes(heap)
        internal_count = heap.size - leaf_count
        
        # Check completeness
        is_complete = self._check_completeness(heap)
        
        # Calculate balance factor
        balance_factor = self._calculate_balance_factor(heap)
        
        return {
            'height': height,
            'total_nodes': heap.size,
            'leaf_nodes': leaf_count,
            'internal_nodes': internal_count,
            'completeness': is_complete,
            'balance_factor': balance_factor,
            'min_possible_height': self._min_height(heap.size),
            'max_possible_height': self._max_height(heap.size)
        }
    
    def _calculate_height(self, n):
        """Calculate height of complete binary tree with n nodes"""
        if n == 0:
            return -1
        return (n - 1).bit_length() - 1
    
    def _count_leaf_nodes(self, heap):
        """Count leaf nodes in heap"""
        if heap.size == 0:
            return 0
        
        # In a complete binary tree, leaves start from index floor(n/2)
        first_leaf_index = heap.size // 2
        return heap.size - first_leaf_index
    
    def _check_completeness(self, heap):
        """Check if heap maintains complete binary tree property"""
        # For array representation, completeness is guaranteed
        # but we can check for logical completeness
        
        for i in range(heap.size):
            left_child_idx = 2 * i + 1
            right_child_idx = 2 * i + 2
            
            # Right child exists but left doesn't
            if right_child_idx < heap.size and left_child_idx >= heap.size:
                return False
            
            # Gap in array (should not happen in our implementation)
            if left_child_idx < heap.size and heap.heap[left_child_idx] is None:
                return False
        
        return True
    
    def _calculate_balance_factor(self, heap):
        """Calculate balance factor (difference between left and right subtree heights)"""
        if heap.size <= 1:
            return 0
        
        # For complete binary tree, balance factor is always 0 or 1
        height = self._calculate_height(heap.size)
        last_level_nodes = heap.size - (2**height - 1)
        max_last_level = 2**height
        
        return 1 if last_level_nodes < max_last_level // 2 else 0
    
    def _min_height(self, n):
        """Minimum possible height for n nodes"""
        if n == 0:
            return -1
        return (n - 1).bit_length() - 1
    
    def _max_height(self, n):
        """Maximum possible height for n nodes (for balanced tree)"""
        if n == 0:
            return -1
        return n - 1  # Completely unbalanced case
    
    def compare_heap_complexities(self):
        """Compare time complexities of heap operations"""
        
        operations = [
            ("Insert", "O(log n)", "Add element and heapify up"),
            ("Extract Root", "O(log n)", "Remove root and heapify down"),
            ("Peek/Top", "O(1)", "Get root element"),
            ("Build Heap", "O(n)", "Build heap from array"),
            ("Search", "O(n)", "Linear search (no order except heap property)"),
            ("Delete Arbitrary", "O(log n)", "Replace with last, then heapify"),
            ("Increase/Decrease Key", "O(log n)", "Update value and heapify"),
            ("Merge", "O(n + m)", "Combine two heaps")
        ]
        
        print("\nHeap Operation Complexities:")
        print("=" * 60)
        print(f"{'Operation':<20} {'Time Complexity':<15} {'Description':<25}")
        print("-" * 60)
        
        for operation, complexity, description in operations:
            print(f"{operation:<20} {complexity:<15} {description:<25}")
    
    def demonstrate_heap_applications(self):
        """Demonstrate real-world heap applications"""
        
        applications = [
            {
                'name': 'Priority Queue',
                'description': 'Task scheduling, Dijkstra\'s algorithm',
                'heap_type': 'Min/Max heap based on priority',
                'example': 'Hospital emergency room triage'
            },
            {
                'name': 'Heap Sort',
                'description': 'In-place sorting algorithm',
                'heap_type': 'Max heap for ascending sort',
                'example': 'Sorting large datasets efficiently'
            },
            {
                'name': 'K Largest/Smallest',
                'description': 'Find top K elements efficiently',
                'heap_type': 'Min heap for K largest',
                'example': 'Top K search results, leaderboards'
            },
            {
                'name': 'Median Finding',
                'description': 'Dynamic median in streaming data',
                'heap_type': 'Max heap + Min heap combination',
                'example': 'Real-time statistics, moving median'
            },
            {
                'name': 'Graph Algorithms',
                'description': 'Dijkstra, Prim\'s MST',
                'heap_type': 'Min heap for shortest paths',
                'example': 'GPS navigation, network routing'
            }
        ]
        
        print("\nReal-World Heap Applications:")
        print("=" * 80)
        
        for i, app in enumerate(applications, 1):
            print(f"{i}. {app['name']}")
            print(f"   Description: {app['description']}")
            print(f"   Heap Type: {app['heap_type']}")
            print(f"   Example: {app['example']}")
            print()

def test_heap_analysis():
    """Test heap analysis and properties"""
    
    # Create test heap
    heap = Heap('min')
    elements = [3, 1, 6, 5, 2, 4]
    
    for element in elements:
        heap.insert(element)
    
    analyzer = HeapAnalyzer()
    
    print("\nHeap Analysis Test:")
    print("=" * 40)
    
    # Analyze properties
    properties = analyzer.analyze_heap_properties(heap)
    
    print("Heap Properties:")
    for prop, value in properties.items():
        print(f"  {prop.replace('_', ' ').title()}: {value}")
    
    # Show complexities
    analyzer.compare_heap_complexities()
    
    # Show applications
    analyzer.demonstrate_heap_applications()

test_heap_analysis()
```

---

### 40. **What is the difference between min-heap and max-heap?** *(Zoho, Facebook)*

**Core Differences:** Min-heap and max-heap are two types of heaps that differ in their ordering property, determining whether the root contains the minimum or maximum element.

**Detailed Comparison:**

| **Aspect** | **Min-Heap** | **Max-Heap** |
|------------|--------------|--------------|
| **Heap Property** | Parent ‚â§ Children | Parent ‚â• Children |
| **Root Element** | Minimum element | Maximum element |
| **Parent-Child Rule** | Parent.value ‚â§ Child.value | Parent.value ‚â• Child.value |
| **Extract Operation** | Extract minimum | Extract maximum |
| **Priority Queue Use** | Low values = High priority | High values = High priority |
| **Sorting Result** | Ascending order | Descending order |

**Implementation Comparison:**
```python
class MinMaxHeapComparison:
    """
    Detailed comparison between Min-Heap and Max-Heap
    """
    
    def __init__(self):
        pass
    
    def create_comparison_example(self):
        """Create side-by-side comparison of min and max heaps"""
        
        # Same input data for both heaps
        data = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]
        
        print("Min-Heap vs Max-Heap Comparison:")
        print("=" * 60)
        print(f"Input data: {data}")
        print()
        
        # Create both heap types
        min_heap = Heap('min')
        max_heap = Heap('max')
        
        # Build heaps from same data
        min_heap.build_heap(data.copy())
        max_heap.build_heap(data.copy())
        
        print("After building heaps:")
        print(f"Min-Heap array: {min_heap.to_list()}")
        print(f"Max-Heap array: {max_heap.to_list()}")
        print()
        
        # Show heap visualizations
        print("Min-Heap Structure:")
        print(min_heap.visualize_heap())
        
        print("\nMax-Heap Structure:")
        print(max_heap.visualize_heap())
        
        # Compare root elements
        print(f"\nRoot Comparisons:")
        print(f"Min-Heap root (minimum): {min_heap.peek()}")
        print(f"Max-Heap root (maximum): {max_heap.peek()}")
        
        # Extract sequences
        min_sequence = []
        max_sequence = []
        
        # Make copies for extraction
        min_copy = Heap('min')
        max_copy = Heap('max')
        min_copy.build_heap(data.copy())
        max_copy.build_heap(data.copy())
        
        while not min_copy.is_empty():
            min_sequence.append(min_copy.extract_root())
        
        while not max_copy.is_empty():
            max_sequence.append(max_copy.extract_root())
        
        print(f"\nExtraction Sequences:")
        print(f"Min-Heap extractions: {min_sequence} (ascending order)")
        print(f"Max-Heap extractions: {max_sequence} (descending order)")
        
        return min_heap, max_heap
    
    def demonstrate_heap_property_differences(self):
        """Demonstrate how heap properties differ"""
        
        print("\n" + "="*60)
        print("Heap Property Demonstrations:")
        print("="*60)
        
        # Example tree structure for both heaps
        #     Min-Heap      Max-Heap
        #        1             16
        #      /   \         /    \
        #     2     3       14    10
        #   /  \   / \     / \   / \
        #  4   8  9  10   8  7  9  3
        
        print("Visual Property Comparison:")
        print()
        print("Min-Heap Property (Parent ‚â§ Children):")
        print("        1")
        print("      /   \\")
        print("     2     3      ‚úì 1 ‚â§ 2, 1 ‚â§ 3")
        print("   /  \\   / \\")
        print("  4   8  9  10    ‚úì 2 ‚â§ 4, 2 ‚â§ 8, 3 ‚â§ 9, 3 ‚â§ 10")
        print()
        
        print("Max-Heap Property (Parent ‚â• Children):")
        print("        16")
        print("      /    \\")
        print("     14    10     ‚úì 16 ‚â• 14, 16 ‚â• 10")
        print("   /  \\   / \\")
        print("  8   7  9   3    ‚úì 14 ‚â• 8, 14 ‚â• 7, 10 ‚â• 9, 10 ‚â• 3")
        print()
    
    def compare_insertion_processes(self):
        """Compare insertion process in both heap types"""
        
        print("Insertion Process Comparison:")
        print("="*50)
        
        values_to_insert = [5, 2, 8, 1, 9]
        
        min_heap = Heap('min')
        max_heap = Heap('max')
        
        for value in values_to_insert:
            print(f"\nInserting {value}:")
            
            # Insert in min-heap
            min_heap.insert(value)
            print(f"  Min-Heap after insert: {min_heap.to_list()}")
            
            # Insert in max-heap
            max_heap.insert(value)
            print(f"  Max-Heap after insert: {max_heap.to_list()}")
    
    def compare_extraction_processes(self):
        """Compare extraction process in both heap types"""
        
        print("\n" + "="*50)
        print("Extraction Process Comparison:")
        print("="*50)
        
        # Start with same data
        data = [5, 2, 8, 1, 9, 3, 7]
        
        min_heap = Heap('min')
        max_heap = Heap('max')
        
        min_heap.build_heap(data.copy())
        max_heap.build_heap(data.copy())
        
        print(f"Initial data: {data}")
        print(f"Min-Heap: {min_heap.to_list()}")
        print(f"Max-Heap: {max_heap.to_list()}")
        print()
        
        extraction_count = 3
        print(f"Extracting {extraction_count} elements:")
        
        for i in range(extraction_count):
            min_extracted = min_heap.extract_root()
            max_extracted = max_heap.extract_root()
            
            print(f"\nExtraction {i+1}:")
            print(f"  Min-Heap extracted: {min_extracted}, remaining: {min_heap.to_list()}")
            print(f"  Max-Heap extracted: {max_extracted}, remaining: {max_heap.to_list()}")
    
    def demonstrate_use_cases(self):
        """Demonstrate specific use cases for each heap type"""
        
        print("\n" + "="*60)
        print("Practical Use Cases:")
        print("="*60)
        
        use_cases = [
            {
                'scenario': 'Task Scheduling (Low Priority Number = High Priority)',
                'min_heap_use': 'Store tasks by priority number (1=highest, 10=lowest)',
                'max_heap_use': 'Not suitable - would prioritize low-priority tasks',
                'example': 'Emergency response: Priority 1 (critical) handled first'
            },
            {
                'scenario': 'Finding K Largest Elements',
                'min_heap_use': 'Use min-heap of size K, maintain K largest',
                'max_heap_use': 'Not efficient - would need to sort all elements',
                'example': 'Top K products by sales, K highest scores'
            },
            {
                'scenario': 'Finding K Smallest Elements',
                'min_heap_use': 'Not efficient - would need to sort all elements',
                'max_heap_use': 'Use max-heap of size K, maintain K smallest',
                'example': 'K shortest routes, K cheapest products'
            },
            {
                'scenario': 'Dijkstra\'s Shortest Path Algorithm',
                'min_heap_use': 'Perfect - always process shortest distance first',
                'max_heap_use': 'Wrong - would process longest distances first',
                'example': 'GPS navigation, network routing protocols'
            },
            {
                'scenario': 'Heap Sort (Ascending Order)',
                'min_heap_use': 'Inefficient - need to rebuild heap repeatedly',
                'max_heap_use': 'Perfect - extract max repeatedly for descending',
                'example': 'In-place sorting of large datasets'
            }
        ]
        
        for i, case in enumerate(use_cases, 1):
            print(f"{i}. {case['scenario']}")
            print(f"   Min-Heap: {case['min_heap_use']}")
            print(f"   Max-Heap: {case['max_heap_use']}")
            print(f"   Example: {case['example']}")
            print()

def test_min_max_heap_comparison():
    """Test comprehensive min-max heap comparison"""
    
    comparator = MinMaxHeapComparison()
    
    # Basic comparison
    min_heap, max_heap = comparator.create_comparison_example()
    
    # Property differences
    comparator.demonstrate_heap_property_differences()
    
    # Insertion comparison
    comparator.compare_insertion_processes()
    
    # Extraction comparison
    comparator.compare_extraction_processes()
    
    # Use cases
    comparator.demonstrate_use_cases()

test_min_max_heap_comparison()
```

**Advanced Heap Type Implementations:**
```python
class SpecializedHeaps:
    """
    Specialized heap implementations and variants
    """
    
    def __init__(self):
        pass
    
    def create_custom_priority_heap(self, priority_func):
        """
        Create heap with custom priority function
        Args:
            priority_func: Function that takes value and returns priority
        """
        
        class CustomPriorityHeap:
            def __init__(self, priority_func):
                self.heap = []
                self.priority_func = priority_func
                self.size = 0
            
            def insert(self, value):
                """Insert with custom priority"""
                priority = self.priority_func(value)
                self.heap.append((priority, value))
                self.size += 1
                self._heapify_up()
            
            def extract_root(self):
                """Extract highest priority element"""
                if self.size == 0:
                    raise IndexError("Heap is empty")
                
                root_priority, root_value = self.heap[0]
                
                # Move last element to root
                self.heap[0] = self.heap[self.size - 1]
                self.size -= 1
                self.heap.pop()
                
                if self.size > 0:
                    self._heapify_down()
                
                return root_value
            
            def _heapify_up(self):
                """Heapify up using custom priority"""
                index = self.size - 1
                
                while index > 0:
                    parent_index = (index - 1) // 2
                    
                    if self.heap[index][0] >= self.heap[parent_index][0]:
                        break
                    
                    self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]
                    index = parent_index
            
            def _heapify_down(self):
                """Heapify down using custom priority"""
                index = 0
                
                while 2 * index + 1 < self.size:
                    left_child = 2 * index + 1
                    right_child = 2 * index + 2
                    smallest = index
                    
                    if self.heap[left_child][0] < self.heap[smallest][0]:
                        smallest = left_child
                    
                    if (right_child < self.size and 
                        self.heap[right_child][0] < self.heap[smallest][0]):
                        smallest = right_child
                    
                    if smallest == index:
                        break
                    
                    self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
                    index = smallest
            
            def to_list(self):
                return [(priority, value) for priority, value in self.heap]
        
        return CustomPriorityHeap(priority_func)
    
    def demonstrate_dual_heap_median_finder(self):
        """
        Demonstrate using both min and max heap to find median
        """
        
        class MedianFinder:
            def __init__(self):
                # Max heap for smaller half (store negatives for max behavior)
                self.small_half = []  # Max heap (negate values)
                # Min heap for larger half
                self.large_half = []  # Min heap
            
            def add_number(self, num):
                """Add number and maintain median property"""
                import heapq
                
                # Add to appropriate heap
                if not self.small_half or num <= -self.small_half[0]:
                    heapq.heappush(self.small_half, -num)  # Negate for max heap
                else:
                    heapq.heappush(self.large_half, num)
                
                # Balance heaps
                self._balance_heaps()
            
            def _balance_heaps(self):
                """Balance heap sizes"""
                import heapq
                
                # Ensure size difference is at most 1
                if len(self.small_half) > len(self.large_half) + 1:
                    val = -heapq.heappop(self.small_half)
                    heapq.heappush(self.large_half, val)
                elif len(self.large_half) > len(self.small_half) + 1:
                    val = heapq.heappop(self.large_half)
                    heapq.heappush(self.small_half, -val)
            
            def find_median(self):
                """Find current median"""
                if len(self.small_half) > len(self.large_half):
                    return -self.small_half[0]  # Un-negate max heap top
                elif len(self.large_half) > len(self.small_half):
                    return self.large_half[0]
                else:
                    # Equal sizes - average of tops
                    return (-self.small_half[0] + self.large_half[0]) / 2.0
            
            def get_state(self):
                """Get current state of both heaps"""
                small_values = [-x for x in self.small_half]  # Un-negate for display
                return {
                    'small_half_max_heap': small_values,
                    'large_half_min_heap': self.large_half.copy(),
                    'median': self.find_median()
                }
        
        print("Dual-Heap Median Finder Demonstration:")
        print("="*50)
        
        median_finder = MedianFinder()
        numbers = [5, 15, 1, 3, 8, 12, 2]
        
        for num in numbers:
            median_finder.add_number(num)
            state = median_finder.get_state()
            
            print(f"\nAfter adding {num}:")
            print(f"  Small half (max-heap): {state['small_half_max_heap']}")
            print(f"  Large half (min-heap): {state['large_half_min_heap']}")
            print(f"  Current median: {state['median']}")
    
    def demonstrate_k_way_merge_with_heaps(self):
        """
        Demonstrate K-way merge using min-heap
        """
        
        def k_way_merge(arrays):
            """
            Merge K sorted arrays using min-heap
            Time: O(n log k), Space: O(k)
            """
            import heapq
            
            # Min heap to store (value, array_index, element_index)
            heap = []
            result = []
            
            # Initialize heap with first element from each array
            for i, array in enumerate(arrays):
                if array:  # Non-empty array
                    heapq.heappush(heap, (array[0], i, 0))
            
            # Extract minimum and add next element from same array
            while heap:
                value, array_idx, element_idx = heapq.heappop(heap)
                result.append(value)
                
                # Add next element from same array if exists
                if element_idx + 1 < len(arrays[array_idx]):
                    next_val = arrays[array_idx][element_idx + 1]
                    heapq.heappush(heap, (next_val, array_idx, element_idx + 1))
            
            return result
        
        print("\nK-Way Merge with Min-Heap:")
        print("="*40)
        
        # Example: Merge 4 sorted arrays
        arrays = [
            [1, 4, 7, 10],
            [2, 5, 8, 11],
            [3, 6, 9, 12],
            [0, 13, 14, 15]
        ]
        
        print("Input arrays:")
        for i, array in enumerate(arrays):
            print(f"  Array {i+1}: {array}")
        
        merged = k_way_merge(arrays)
        print(f"\nMerged result: {merged}")
        print(f"Is sorted: {merged == sorted(merged)}")

def test_specialized_heaps():
    """Test specialized heap implementations"""
    
    specialized = SpecializedHeaps()
    
    print("Specialized Heap Implementations:")
    print("="*50)
    
    # Test custom priority heap
    print("1. Custom Priority Heap (Priority = Negative of Value):")
    priority_heap = specialized.create_custom_priority_heap(lambda x: -x)
    
    values = [3, 1, 4, 1, 5, 9, 2, 6]
    for val in values:
        priority_heap.insert(val)
    
    print(f"   Inserted: {values}")
    print(f"   Heap state: {priority_heap.to_list()}")
    
    extracted = []
    while priority_heap.size > 0:
        extracted.append(priority_heap.extract_root())
    print(f"   Extraction order: {extracted}")
    
    # Test median finder
    specialized.demonstrate_dual_heap_median_finder()
    
    # Test K-way merge
    specialized.demonstrate_k_way_merge_with_heaps()

test_specialized_heaps()
```

**Performance and Memory Analysis:**
```python
class HeapPerformanceAnalysis:
    """
    Performance analysis of Min-Heap vs Max-Heap
    """
    
    def __init__(self):
        pass
    
    def memory_usage_comparison(self):
        """Compare memory usage patterns"""
        
        print("\nMemory Usage Analysis:")
        print("="*40)
        
        memory_aspects = [
            {
                'aspect': 'Storage Structure',
                'min_heap': 'Array-based, same as max-heap',
                'max_heap': 'Array-based, same as min-heap',
                'difference': 'No difference'
            },
            {
                'aspect': 'Per Node Memory',
                'min_heap': 'One value per array element',
                'max_heap': 'One value per array element',
                'difference': 'Identical'
            },
            {
                'aspect': 'Comparison Overhead',
                'min_heap': 'Simple comparison (a < b)',
                'max_heap': 'Simple comparison (a > b)',
                'difference': 'Identical computational cost'
            },
            {
                'aspect': 'Cache Performance',
                'min_heap': 'Array layout provides good cache locality',
                'max_heap': 'Array layout provides good cache locality',
                'difference': 'Identical cache behavior'
            }
        ]
        
        print(f"{'Aspect':<20} {'Min-Heap':<30} {'Max-Heap':<30} {'Difference':<15}")
        print("-" * 95)
        
        for aspect in memory_aspects:
            print(f"{aspect['aspect']:<20} {aspect['min_heap']:<30} {aspect['max_heap']:<30} {aspect['difference']:<15}")
    
    def operation_performance_comparison(self):
        """Compare operation performance"""
        
        print("\nOperation Performance Analysis:")
        print("="*50)
        
        operations = [
            {
                'operation': 'Insert',
                'time_complexity': 'O(log n)',
                'min_heap_note': 'Heapify up to maintain min property',
                'max_heap_note': 'Heapify up to maintain max property',
                'performance_diff': 'Identical'
            },
            {
                'operation': 'Extract Root',
                'time_complexity': 'O(log n)',
                'min_heap_note': 'Heapify down from root (min removed)',
                'max_heap_note': 'Heapify down from root (max removed)',
                'performance_diff': 'Identical'
            },
            {
                'operation': 'Peek Root',
                'time_complexity': 'O(1)',
                'min_heap_note': 'Access minimum element',
                'max_heap_note': 'Access maximum element',
                'performance_diff': 'Identical'
            },
            {
                'operation': 'Build Heap',
                'time_complexity': 'O(n)',
                'min_heap_note': 'Bottom-up heapification',
                'max_heap_note': 'Bottom-up heapification',
                'performance_diff': 'Identical'
            }
        ]
        
        for op in operations:
            print(f"Operation: {op['operation']}")
            print(f"  Time Complexity: {op['time_complexity']}")
            print(f"  Min-Heap: {op['min_heap_note']}")
            print(f"  Max-Heap: {op['max_heap_note']}")
            print(f"  Performance: {op['performance_diff']}")
            print()
    
    def real_world_performance_scenarios(self):
        """Real-world performance scenarios"""
        
        print("Real-World Performance Scenarios:")
        print("="*45)
        
        scenarios = [
            {
                'scenario': 'Priority Queue for OS Task Scheduling',
                'best_choice': 'Min-Heap',
                'reason': 'Lower priority numbers = higher priority',
                'performance_impact': 'Direct mapping of priority values'
            },
            {
                'scenario': 'Finding Top K Elements from Stream',
                'best_choice': 'Min-Heap (size K)',
                'reason': 'Maintain K largest by replacing minimum',
                'performance_impact': 'O(log K) per element vs O(n log n) sorting'
            },
            {
                'scenario': 'Heap Sort Implementation',
                'best_choice': 'Max-Heap',
                'reason': 'Extract maximum for descending order',
                'performance_impact': 'In-place sorting with O(n log n) time'
            },
            {
                'scenario': 'Dijkstra\'s Shortest Path',
                'best_choice': 'Min-Heap',
                'reason': 'Always process shortest distance first',
                'performance_impact': 'O((V + E) log V) vs O(V¬≤) naive approach'
            },
            {
                'scenario': 'Median Maintenance in Data Stream',
                'best_choice': 'Both (Max + Min)',
                'reason': 'Max-heap for lower half, Min-heap for upper half',
                'performance_impact': 'O(log n) insertion vs O(n log n) sorting'
            }
        ]
        
        for i, scenario in enumerate(scenarios, 1):
            print(f"{i}. {scenario['scenario']}")
            print(f"   Best Choice: {scenario['best_choice']}")
            print(f"   Reason: {scenario['reason']}")
            print(f"   Impact: {scenario['performance_impact']}")
            print()

def test_performance_analysis():
    """Test heap performance analysis"""
    
    analyzer = HeapPerformanceAnalysis()
    
    # Memory comparison
    analyzer.memory_usage_comparison()
    
    # Operation performance
    analyzer.operation_performance_comparison()
    
    # Real-world scenarios
    analyzer.real_world_performance_scenarios()

test_performance_analysis()
```

**Key Differences Summary:**

| **Characteristic** | **Min-Heap** | **Max-Heap** |
|-------------------|--------------|--------------|
| **Root Property** | Always contains minimum | Always contains maximum |
| **Heapify Direction** | Smaller values bubble up | Larger values bubble up |
| **Extract Result** | Sorted ascending sequence | Sorted descending sequence |
| **Priority Queue** | Low value = High priority | High value = High priority |
| **Use Case Examples** | ‚Ä¢ Dijkstra's algorithm<br>‚Ä¢ Find K largest elements<br>‚Ä¢ Task scheduling (low numbers = high priority) | ‚Ä¢ Heap sort<br>‚Ä¢ Find K smallest elements<br>‚Ä¢ Task scheduling (high numbers = high priority) |
| **Time Complexities** | **Identical to Max-Heap** | **Identical to Min-Heap** |
| **Space Complexity** | **Identical to Max-Heap** | **Identical to Min-Heap** |

**When to Choose Which:**
- **Min-Heap**: When you need the smallest element frequently (shortest paths, smallest priorities, K largest problems)
- **Max-Heap**: When you need the largest element frequently (sorting, largest priorities, K smallest problems)
- **Both Together**: Advanced applications like median finding, range queries

The choice between min-heap and max-heap depends purely on your application's requirements - they have identical performance characteristics but opposite ordering semantics! üèîÔ∏è

---

*These comprehensive answers cover heap fundamentals, min-heap vs max-heap differences, implementation details, performance analysis, and real-world applications. Perfect for understanding heap data structures from both theoretical and practical perspectives! üöÄ*