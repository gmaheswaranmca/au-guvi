# DATA STRUCTURES - BEGINNER LEVEL INTERVIEW ANSWERS (SET 2 - Part 4)

> **Target:** IT, CS, AI, ML, ECE candidates  
> **Level:** Beginner  
> **Companies:** Google, Amazon, Microsoft, Facebook, Zoho, etc.  
> **Category:** Data Structures (Extended Set) - Questions 21-25

## ðŸ“‹ Table of Contents
- [ðŸ“š Stack Applications & Implementations](#ðŸ“š-stack-applications--implementations) (Questions 21-22)
- [ðŸš¶ Queue Applications & Implementations](#ðŸš¶-queue-applications--implementations) (Questions 23-25)

---

## ðŸ“š Stack Applications & Implementations

### 21. **What is the next greater element problem and how do you solve it?** *(Google, Amazon)*

**Problem:** For each element in an array, find the next greater element to its right. If no such element exists, return -1.

**Example:**
```
Input:  [4, 5, 2, 25, 7, 8]
Output: [5, 25, 25, -1, 8, -1]

Explanation:
- 4 â†’ 5 (next greater element)
- 5 â†’ 25 (next greater element)  
- 2 â†’ 25 (next greater element)
- 25 â†’ -1 (no greater element to the right)
- 7 â†’ 8 (next greater element)
- 8 â†’ -1 (no greater element to the right)
```

**Method 1: Brute Force Approach**
```python
def next_greater_brute_force(arr):
    """
    Find next greater element for each element (brute force)
    Time: O(nÂ²), Space: O(1)
    """
    n = len(arr)
    result = [-1] * n
    
    for i in range(n):
        for j in range(i + 1, n):
            if arr[j] > arr[i]:
                result[i] = arr[j]
                break
    
    return result
```

**Method 2: Stack-based Approach (Optimal)**
```python
def next_greater_element_stack(arr):
    """
    Find next greater element using stack
    Time: O(n), Space: O(n)
    """
    n = len(arr)
    result = [-1] * n
    stack = []  # Stack to store indices
    
    # Traverse array from right to left
    for i in range(n - 1, -1, -1):
        # Remove elements smaller than current element
        while stack and arr[stack[-1]] <= arr[i]:
            stack.pop()
        
        # If stack is not empty, top element is next greater
        if stack:
            result[i] = arr[stack[-1]]
        
        # Push current element index to stack
        stack.append(i)
    
    return result
```

**Method 3: Stack-based (Left to Right)**
```python
def next_greater_left_to_right(arr):
    """
    Find next greater element traversing left to right
    Time: O(n), Space: O(n)
    """
    n = len(arr)
    result = [-1] * n
    stack = []  # Stack to store indices
    
    for i in range(n):
        # While stack is not empty and current element is greater
        # than element at index stored in stack top
        while stack and arr[i] > arr[stack[-1]]:
            index = stack.pop()
            result[index] = arr[i]
        
        # Push current index to stack
        stack.append(i)
    
    return result
```

**Variations of the Problem:**

**1. Next Greater Element in Circular Array**
```python
def next_greater_circular(arr):
    """
    Next greater element in circular array
    Time: O(n), Space: O(n)
    """
    n = len(arr)
    result = [-1] * n
    stack = []
    
    # Process array twice to handle circular nature
    for i in range(2 * n):
        current_index = i % n
        
        while stack and arr[current_index] > arr[stack[-1]]:
            index = stack.pop()
            result[index] = arr[current_index]
        
        # Only push indices in first iteration
        if i < n:
            stack.append(current_index)
    
    return result
```

**2. Next Greater Element with Indices**
```python
def next_greater_with_indices(arr):
    """
    Return both next greater element and its index
    Time: O(n), Space: O(n)
    """
    n = len(arr)
    result = [(-1, -1)] * n  # (value, index)
    stack = []
    
    for i in range(n - 1, -1, -1):
        while stack and arr[stack[-1]] <= arr[i]:
            stack.pop()
        
        if stack:
            next_index = stack[-1]
            result[i] = (arr[next_index], next_index)
        
        stack.append(i)
    
    return result
```

**3. Previous Greater Element**
```python
def previous_greater_element(arr):
    """
    Find previous greater element for each element
    Time: O(n), Space: O(n)
    """
    n = len(arr)
    result = [-1] * n
    stack = []
    
    for i in range(n):
        while stack and arr[stack[-1]] <= arr[i]:
            stack.pop()
        
        if stack:
            result[i] = arr[stack[-1]]
        
        stack.append(i)
    
    return result
```

**4. Next Smaller Element**
```python
def next_smaller_element(arr):
    """
    Find next smaller element for each element
    Time: O(n), Space: O(n)
    """
    n = len(arr)
    result = [-1] * n
    stack = []
    
    for i in range(n - 1, -1, -1):
        while stack and arr[stack[-1]] >= arr[i]:  # >= instead of <=
            stack.pop()
        
        if stack:
            result[i] = arr[stack[-1]]
        
        stack.append(i)
    
    return result
```

**Complete Testing Example:**
```python
def test_next_greater_elements():
    """Test all variations of next greater element problem"""
    
    test_cases = [
        [4, 5, 2, 25, 7, 8],
        [13, 7, 6, 12],
        [11, 13, 21, 3],
        [1, 2, 3, 4, 5],
        [5, 4, 3, 2, 1],
        [1]
    ]
    
    for i, arr in enumerate(test_cases):
        print(f"\nTest Case {i + 1}: {arr}")
        print("-" * 40)
        
        # Test different methods
        result_stack = next_greater_element_stack(arr)
        result_brute = next_greater_brute_force(arr)
        result_circular = next_greater_circular(arr)
        
        print(f"Next Greater (Stack):    {result_stack}")
        print(f"Next Greater (Brute):    {result_brute}")
        print(f"Next Greater (Circular): {result_circular}")
        print(f"Previous Greater:        {previous_greater_element(arr)}")
        print(f"Next Smaller:           {next_smaller_element(arr)}")
        
        # Verify consistency
        assert result_stack == result_brute, "Methods should give same result"

# Visual example of stack operation:
"""
Array: [4, 5, 2, 25, 7, 8]
Processing right to left:

i=5 (element=8): stack=[], result[5]=-1, stack=[5]
i=4 (element=7): stack=[5], arr[5]=8 > 7, result[4]=8, stack=[5,4]  
i=3 (element=25): stack=[5,4], pop 4,5 (smaller), result[3]=-1, stack=[3]
i=2 (element=2): stack=[3], arr[3]=25 > 2, result[2]=25, stack=[3,2]
i=1 (element=5): stack=[3,2], pop 2 (smaller), result[1]=25, stack=[3,1]
i=0 (element=4): stack=[3,1], arr[1]=5 > 4, result[0]=5, stack=[3,1,0]

Final result: [5, 25, 25, -1, 8, -1]
"""
```

**Applications:**
1. **Stock span problem** - Days until next higher price
2. **Largest rectangle in histogram** - Building next smaller elements
3. **Celebrity problem** - Social network analysis
4. **Temperature monitoring** - Next warmer day prediction

---

### 22. **How do you implement browser back button functionality?** *(Microsoft, Zoho)*

**Problem:** Implement browser navigation with back/forward functionality using stacks.

**Method 1: Single Stack Approach**
```python
class BrowserHistory:
    """
    Simple browser history with back functionality only
    Uses single stack to store visited pages
    """
    
    def __init__(self, homepage=""):
        self.history = [homepage] if homepage else []
        self.current_index = 0 if homepage else -1
    
    def visit(self, url):
        """Visit a new page"""
        # Remove any forward history when visiting new page
        self.history = self.history[:self.current_index + 1]
        self.history.append(url)
        self.current_index += 1
    
    def back(self):
        """Go back to previous page"""
        if self.current_index > 0:
            self.current_index -= 1
            return self.history[self.current_index]
        return None  # Can't go back further
    
    def forward(self):
        """Go forward to next page"""
        if self.current_index < len(self.history) - 1:
            self.current_index += 1
            return self.history[self.current_index]
        return None  # Can't go forward
    
    def current_page(self):
        """Get current page"""
        if 0 <= self.current_index < len(self.history):
            return self.history[self.current_index]
        return None
    
    def get_history(self):
        """Get complete history"""
        return self.history.copy()
```

**Method 2: Two Stack Approach**
```python
class BrowserHistoryTwoStacks:
    """
    Browser history using two stacks
    One for back navigation, one for forward navigation
    """
    
    def __init__(self, homepage=""):
        self.back_stack = [homepage] if homepage else []
        self.forward_stack = []
        self.current_page = homepage
    
    def visit(self, url):
        """Visit a new page"""
        if self.current_page:
            self.back_stack.append(self.current_page)
        
        self.current_page = url
        self.forward_stack.clear()  # Clear forward history
    
    def back(self):
        """Go back to previous page"""
        if not self.back_stack:
            return None  # No pages to go back to
        
        # Move current page to forward stack
        self.forward_stack.append(self.current_page)
        
        # Get previous page from back stack
        self.current_page = self.back_stack.pop()
        
        return self.current_page
    
    def forward(self):
        """Go forward to next page"""
        if not self.forward_stack:
            return None  # No pages to go forward to
        
        # Move current page to back stack
        self.back_stack.append(self.current_page)
        
        # Get next page from forward stack
        self.current_page = self.forward_stack.pop()
        
        return self.current_page
    
    def can_go_back(self):
        """Check if back navigation is possible"""
        return len(self.back_stack) > 0
    
    def can_go_forward(self):
        """Check if forward navigation is possible"""
        return len(self.forward_stack) > 0
    
    def get_current_page(self):
        """Get current page"""
        return self.current_page
```

**Method 3: Advanced Browser with Features**
```python
class AdvancedBrowserHistory:
    """
    Advanced browser history with additional features
    """
    
    def __init__(self, homepage="", max_history=100):
        self.history = [homepage] if homepage else []
        self.current_index = 0 if homepage else -1
        self.max_history = max_history
        self.bookmarks = set()
        self.visit_count = {}
    
    def visit(self, url):
        """Visit a new page with visit counting"""
        # Trim forward history
        self.history = self.history[:self.current_index + 1]
        
        # Add new page
        self.history.append(url)
        self.current_index += 1
        
        # Track visit count
        self.visit_count[url] = self.visit_count.get(url, 0) + 1
        
        # Limit history size
        if len(self.history) > self.max_history:
            removed_page = self.history.pop(0)
            self.current_index -= 1
            if self.visit_count[removed_page] > 1:
                self.visit_count[removed_page] -= 1
            else:
                del self.visit_count[removed_page]
    
    def back(self, steps=1):
        """Go back specified number of steps"""
        if steps <= 0:
            return self.current_page()
        
        new_index = max(0, self.current_index - steps)
        self.current_index = new_index
        return self.current_page()
    
    def forward(self, steps=1):
        """Go forward specified number of steps"""
        if steps <= 0:
            return self.current_page()
        
        new_index = min(len(self.history) - 1, self.current_index + steps)
        self.current_index = new_index
        return self.current_page()
    
    def current_page(self):
        """Get current page"""
        if 0 <= self.current_index < len(self.history):
            return self.history[self.current_index]
        return None
    
    def add_bookmark(self, url=None):
        """Add current or specified page to bookmarks"""
        if url is None:
            url = self.current_page()
        if url:
            self.bookmarks.add(url)
    
    def get_bookmarks(self):
        """Get all bookmarks"""
        return list(self.bookmarks)
    
    def get_most_visited(self, n=5):
        """Get most visited pages"""
        sorted_pages = sorted(self.visit_count.items(), 
                            key=lambda x: x[1], reverse=True)
        return sorted_pages[:n]
    
    def search_history(self, query):
        """Search for pages in history containing query"""
        matching_pages = [page for page in self.history 
                         if query.lower() in page.lower()]
        return list(set(matching_pages))  # Remove duplicates
    
    def clear_history(self):
        """Clear browsing history"""
        current = self.current_page()
        self.history = [current] if current else []
        self.current_index = 0 if current else -1
        self.visit_count.clear()
        if current:
            self.visit_count[current] = 1
```

**Method 4: Browser with Tabs**
```python
class BrowserWithTabs:
    """
    Browser with multiple tab support
    Each tab has its own navigation history
    """
    
    def __init__(self):
        self.tabs = {}
        self.active_tab_id = None
        self.next_tab_id = 1
    
    def create_tab(self, homepage=""):
        """Create a new tab"""
        tab_id = self.next_tab_id
        self.next_tab_id += 1
        
        self.tabs[tab_id] = BrowserHistory(homepage)
        self.active_tab_id = tab_id
        return tab_id
    
    def close_tab(self, tab_id):
        """Close a tab"""
        if tab_id in self.tabs:
            del self.tabs[tab_id]
            
            # If closed tab was active, switch to another tab
            if self.active_tab_id == tab_id:
                if self.tabs:
                    self.active_tab_id = next(iter(self.tabs))
                else:
                    self.active_tab_id = None
    
    def switch_tab(self, tab_id):
        """Switch to specified tab"""
        if tab_id in self.tabs:
            self.active_tab_id = tab_id
            return True
        return False
    
    def visit(self, url):
        """Visit URL in active tab"""
        if self.active_tab_id and self.active_tab_id in self.tabs:
            self.tabs[self.active_tab_id].visit(url)
    
    def back(self):
        """Go back in active tab"""
        if self.active_tab_id and self.active_tab_id in self.tabs:
            return self.tabs[self.active_tab_id].back()
        return None
    
    def forward(self):
        """Go forward in active tab"""
        if self.active_tab_id and self.active_tab_id in self.tabs:
            return self.tabs[self.active_tab_id].forward()
        return None
    
    def get_current_page(self):
        """Get current page of active tab"""
        if self.active_tab_id and self.active_tab_id in self.tabs:
            return self.tabs[self.active_tab_id].current_page()
        return None
    
    def get_all_tabs(self):
        """Get information about all tabs"""
        tab_info = {}
        for tab_id, browser in self.tabs.items():
            tab_info[tab_id] = {
                'current_page': browser.current_page(),
                'history_length': len(browser.get_history()),
                'is_active': tab_id == self.active_tab_id
            }
        return tab_info
```

**Complete Testing Example:**
```python
def test_browser_implementations():
    """Test different browser implementations"""
    
    print("Testing Single Stack Browser:")
    print("=" * 40)
    browser1 = BrowserHistory("google.com")
    
    browser1.visit("facebook.com")
    browser1.visit("twitter.com")
    browser1.visit("linkedin.com")
    
    print(f"Current: {browser1.current_page()}")  # linkedin.com
    print(f"Back: {browser1.back()}")             # twitter.com
    print(f"Back: {browser1.back()}")             # facebook.com
    print(f"Forward: {browser1.forward()}")       # twitter.com
    browser1.visit("instagram.com")               # Clear forward history
    print(f"Forward: {browser1.forward()}")       # None (no forward history)
    print(f"History: {browser1.get_history()}")
    
    print("\nTesting Two Stack Browser:")
    print("=" * 40)
    browser2 = BrowserHistoryTwoStacks("home.com")
    
    browser2.visit("page1.com")
    browser2.visit("page2.com")
    print(f"Current: {browser2.get_current_page()}")  # page2.com
    print(f"Can go back: {browser2.can_go_back()}")   # True
    print(f"Back: {browser2.back()}")                 # page1.com
    print(f"Can go forward: {browser2.can_go_forward()}")  # True
    print(f"Forward: {browser2.forward()}")           # page2.com
    
    print("\nTesting Advanced Browser:")
    print("=" * 40)
    browser3 = AdvancedBrowserHistory("start.com")
    
    # Visit multiple pages
    pages = ["news.com", "sports.com", "news.com", "tech.com", "news.com"]
    for page in pages:
        browser3.visit(page)
    
    print(f"Current: {browser3.current_page()}")
    print(f"Most visited: {browser3.get_most_visited(3)}")
    
    browser3.add_bookmark("news.com")
    browser3.add_bookmark("tech.com")
    print(f"Bookmarks: {browser3.get_bookmarks()}")
    
    search_results = browser3.search_history("news")
    print(f"Search 'news': {search_results}")
    
    print("\nTesting Browser with Tabs:")
    print("=" * 40)
    browser4 = BrowserWithTabs()
    
    # Create tabs
    tab1 = browser4.create_tab("home.com")
    tab2 = browser4.create_tab("work.com")
    
    # Work with tab 1
    browser4.switch_tab(tab1)
    browser4.visit("social.com")
    browser4.visit("games.com")
    
    # Work with tab 2  
    browser4.switch_tab(tab2)
    browser4.visit("email.com")
    
    print(f"Tab info: {browser4.get_all_tabs()}")
    
    # Navigate in active tab (tab2)
    print(f"Current page: {browser4.get_current_page()}")  # email.com
    print(f"Back: {browser4.back()}")                      # work.com
```

**Real-world Applications:**
1. **Web browsers** - Chrome, Firefox, Safari navigation
2. **IDE editors** - File navigation history
3. **Mobile apps** - Screen navigation stacks
4. **Game development** - Scene/level navigation
5. **Document viewers** - Page navigation history

**Performance Comparison:**

| Implementation | Space | Back/Forward | Visit | Best For |
|---------------|-------|--------------|-------|----------|
| **Single Stack** | O(n) | O(1) | O(1) | Simple navigation |
| **Two Stacks** | O(n) | O(1) | O(1) | Clear separation |
| **Advanced** | O(n) | O(1) | O(1) | Feature-rich browser |
| **Multi-tab** | O(nm) | O(1) | O(1) | Modern browsers |

---

## ðŸš¶ Queue Applications & Implementations

### 23. **How do you implement a queue using two stacks?** *(Facebook, Google)*

**Problem:** Implement queue operations (enqueue, dequeue, front, empty) using only stack operations.

**Approach 1: Make Enqueue Expensive**
```python
class QueueUsingStacksEnqueueExpensive:
    """
    Queue implementation using two stacks
    Enqueue: O(n), Dequeue: O(1), Front: O(1)
    """
    
    def __init__(self):
        self.stack1 = []  # Main stack
        self.stack2 = []  # Helper stack
    
    def enqueue(self, item):
        """
        Add item to queue (expensive operation)
        Time: O(n) where n is number of elements
        """
        # Move all elements from stack1 to stack2
        while self.stack1:
            self.stack2.append(self.stack1.pop())
        
        # Add new item to stack1
        self.stack1.append(item)
        
        # Move all elements back from stack2 to stack1
        while self.stack2:
            self.stack1.append(self.stack2.pop())
    
    def dequeue(self):
        """
        Remove and return front element
        Time: O(1)
        """
        if self.is_empty():
            raise IndexError("dequeue from empty queue")
        return self.stack1.pop()
    
    def front(self):
        """
        Return front element without removing
        Time: O(1)
        """
        if self.is_empty():
            raise IndexError("front of empty queue")
        return self.stack1[-1]
    
    def is_empty(self):
        """Check if queue is empty"""
        return len(self.stack1) == 0
    
    def size(self):
        """Return number of elements in queue"""
        return len(self.stack1)
```

**Approach 2: Make Dequeue Expensive**
```python
class QueueUsingStacksDequeueExpensive:
    """
    Queue implementation with expensive dequeue operation
    Enqueue: O(1), Dequeue: O(n), Front: O(n)
    """
    
    def __init__(self):
        self.stack1 = []  # For enqueue operations
        self.stack2 = []  # For dequeue operations
    
    def enqueue(self, item):
        """
        Add item to queue (cheap operation)
        Time: O(1)
        """
        self.stack1.append(item)
    
    def dequeue(self):
        """
        Remove and return front element (expensive operation)
        Time: O(n)
        """
        if self.is_empty():
            raise IndexError("dequeue from empty queue")
        
        # Move all elements from stack1 to stack2
        while len(self.stack1) > 1:
            self.stack2.append(self.stack1.pop())
        
        # Get the front element (bottom of stack1)
        front_element = self.stack1.pop()
        
        # Move all elements back from stack2 to stack1
        while self.stack2:
            self.stack1.append(self.stack2.pop())
        
        return front_element
    
    def front(self):
        """
        Return front element without removing (expensive operation)
        Time: O(n)
        """
        if self.is_empty():
            raise IndexError("front of empty queue")
        
        # Move all elements to stack2
        while len(self.stack1) > 1:
            self.stack2.append(self.stack1.pop())
        
        # Get front element
        front_element = self.stack1[-1]
        
        # Move all elements back
        while self.stack2:
            self.stack1.append(self.stack2.pop())
        
        return front_element
    
    def is_empty(self):
        """Check if queue is empty"""
        return len(self.stack1) == 0
```

**Approach 3: Amortized O(1) Operations**
```python
class QueueUsingStacksAmortized:
    """
    Queue implementation with amortized O(1) operations
    Smart approach: transfer elements only when needed
    """
    
    def __init__(self):
        self.input_stack = []   # For enqueue operations
        self.output_stack = []  # For dequeue operations
    
    def enqueue(self, item):
        """
        Add item to queue
        Time: O(1)
        """
        self.input_stack.append(item)
    
    def _transfer_if_needed(self):
        """Transfer elements from input to output stack if output is empty"""
        if not self.output_stack:
            while self.input_stack:
                self.output_stack.append(self.input_stack.pop())
    
    def dequeue(self):
        """
        Remove and return front element
        Time: O(1) amortized
        """
        if self.is_empty():
            raise IndexError("dequeue from empty queue")
        
        self._transfer_if_needed()
        return self.output_stack.pop()
    
    def front(self):
        """
        Return front element without removing
        Time: O(1) amortized
        """
        if self.is_empty():
            raise IndexError("front of empty queue")
        
        self._transfer_if_needed()
        return self.output_stack[-1]
    
    def is_empty(self):
        """Check if queue is empty"""
        return len(self.input_stack) == 0 and len(self.output_stack) == 0
    
    def size(self):
        """Return number of elements in queue"""
        return len(self.input_stack) + len(self.output_stack)
```

**Visual Example of Amortized Approach:**
```python
def demonstrate_queue_operations():
    """Demonstrate how the amortized queue works"""
    
    queue = QueueUsingStacksAmortized()
    
    print("Queue Operations Demonstration:")
    print("=" * 40)
    
    # Enqueue operations
    operations = [
        ("enqueue", 1), ("enqueue", 2), ("enqueue", 3),
        ("dequeue", None), ("enqueue", 4), ("dequeue", None),
        ("front", None), ("dequeue", None), ("dequeue", None)
    ]
    
    for op, value in operations:
        print(f"\nOperation: {op}({value if value else ''})")
        print(f"Before - Input: {queue.input_stack}, Output: {queue.output_stack}")
        
        try:
            if op == "enqueue":
                queue.enqueue(value)
                result = f"Enqueued {value}"
            elif op == "dequeue":
                result = f"Dequeued {queue.dequeue()}"
            elif op == "front":
                result = f"Front is {queue.front()}"
            
            print(f"Result: {result}")
            print(f"After  - Input: {queue.input_stack}, Output: {queue.output_stack}")
            
        except IndexError as e:
            print(f"Error: {e}")

"""
Visual representation of amortized approach:

Initial: input_stack = [], output_stack = []

Enqueue(1): input_stack = [1], output_stack = []
Enqueue(2): input_stack = [1,2], output_stack = []
Enqueue(3): input_stack = [1,2,3], output_stack = []

Dequeue():
  - output_stack is empty, transfer from input_stack
  - Transfer: input_stack = [], output_stack = [3,2,1]
  - Pop from output_stack: return 1
  - Result: input_stack = [], output_stack = [3,2]

Enqueue(4): input_stack = [4], output_stack = [3,2]

Dequeue():
  - output_stack not empty, just pop
  - Pop from output_stack: return 2
  - Result: input_stack = [4], output_stack = [3]
"""
```

**Comparison of Approaches:**

| Approach | Enqueue | Dequeue | Front | Space | Best For |
|----------|---------|---------|-------|-------|----------|
| **Enqueue Expensive** | O(n) | O(1) | O(1) | O(n) | Frequent dequeue |
| **Dequeue Expensive** | O(1) | O(n) | O(n) | O(n) | Frequent enqueue |
| **Amortized** | O(1) | O(1)* | O(1)* | O(n) | Balanced operations |

*Amortized time complexity

---

### 24. **What is a monotonic queue and its applications?** *(Amazon, Microsoft)*

**Monotonic Queue:** A data structure where elements are stored in monotonic order (either increasing or decreasing). Elements that break the monotonic property are removed.

**Types:**
1. **Monotonic Increasing Queue** - Elements in increasing order
2. **Monotonic Decreasing Queue** - Elements in decreasing order

**Implementation using Deque:**
```python
from collections import deque

class MonotonicIncreasingQueue:
    """
    Monotonic queue maintaining increasing order
    Useful for finding minimum in sliding windows
    """
    
    def __init__(self):
        self.queue = deque()  # Store (value, index) pairs
    
    def push(self, value, index):
        """
        Add element while maintaining increasing order
        Time: O(1) amortized
        """
        # Remove elements from back that are >= current value
        while self.queue and self.queue[-1][0] >= value:
            self.queue.pop()
        
        self.queue.append((value, index))
    
    def pop_front(self):
        """Remove element from front"""
        if self.queue:
            return self.queue.popleft()
        return None
    
    def get_min(self):
        """Get minimum element"""
        if self.queue:
            return self.queue[0][0]
        return None
    
    def remove_old_elements(self, current_index, window_size):
        """Remove elements outside current window"""
        while (self.queue and 
               self.queue[0][1] <= current_index - window_size):
            self.queue.popleft()

class MonotonicDecreasingQueue:
    """
    Monotonic queue maintaining decreasing order
    Useful for finding maximum in sliding windows
    """
    
    def __init__(self):
        self.queue = deque()  # Store (value, index) pairs
    
    def push(self, value, index):
        """
        Add element while maintaining decreasing order
        Time: O(1) amortized
        """
        # Remove elements from back that are <= current value
        while self.queue and self.queue[-1][0] <= value:
            self.queue.pop()
        
        self.queue.append((value, index))
    
    def get_max(self):
        """Get maximum element"""
        if self.queue:
            return self.queue[0][0]
        return None
    
    def remove_old_elements(self, current_index, window_size):
        """Remove elements outside current window"""
        while (self.queue and 
               self.queue[0][1] <= current_index - window_size):
            self.queue.popleft()
```

**Application 1: Sliding Window Maximum**
```python
def sliding_window_maximum(arr, k):
    """
    Find maximum element in each sliding window of size k
    Time: O(n), Space: O(k)
    """
    if not arr or k <= 0:
        return []
    
    result = []
    mono_queue = MonotonicDecreasingQueue()
    
    for i in range(len(arr)):
        # Add current element
        mono_queue.push(arr[i], i)
        
        # Remove elements outside current window
        mono_queue.remove_old_elements(i, k)
        
        # If we have a complete window, record the maximum
        if i >= k - 1:
            result.append(mono_queue.get_max())
    
    return result

# Example usage:
arr = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
result = sliding_window_maximum(arr, k)
print(f"Array: {arr}")
print(f"Sliding window maximums (k={k}): {result}")
# Output: [3, 3, 5, 5, 6, 7]
```

**Application 2: Sliding Window Minimum**
```python
def sliding_window_minimum(arr, k):
    """
    Find minimum element in each sliding window of size k
    Time: O(n), Space: O(k)
    """
    if not arr or k <= 0:
        return []
    
    result = []
    mono_queue = MonotonicIncreasingQueue()
    
    for i in range(len(arr)):
        # Add current element
        mono_queue.push(arr[i], i)
        
        # Remove elements outside current window
        mono_queue.remove_old_elements(i, k)
        
        # If we have a complete window, record the minimum
        if i >= k - 1:
            result.append(mono_queue.get_min())
    
    return result
```

**Application 3: Largest Rectangle in Histogram**
```python
def largest_rectangle_histogram(heights):
    """
    Find area of largest rectangle in histogram
    Time: O(n), Space: O(n)
    """
    stack = []  # Monotonic increasing stack
    max_area = 0
    
    for i, height in enumerate(heights):
        # While current height is less than stack top
        while stack and heights[stack[-1]] > height:
            h = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * width)
        
        stack.append(i)
    
    # Process remaining elements in stack
    while stack:
        h = heights[stack.pop()]
        width = len(heights) if not stack else len(heights) - stack[-1] - 1
        max_area = max(max_area, h * width)
    
    return max_area
```

**Application 4: Next Greater Element (Revisited)**
```python
def next_greater_element_monotonic(arr):
    """
    Find next greater element using monotonic decreasing stack
    Time: O(n), Space: O(n)
    """
    result = [-1] * len(arr)
    stack = []  # Monotonic decreasing stack of indices
    
    for i in range(len(arr)):
        # While stack is not empty and current element is greater
        while stack and arr[i] > arr[stack[-1]]:
            index = stack.pop()
            result[index] = arr[i]
        
        stack.append(i)
    
    return result
```

**Advanced: Monotonic Queue with Custom Comparator**
```python
class MonotonicQueue:
    """
    Generic monotonic queue with custom comparator
    """
    
    def __init__(self, comparator=lambda a, b: a <= b):
        """
        comparator: function that returns True if first element
                   should be removed when second element is added
        """
        self.queue = deque()
        self.compare = comparator
    
    def push(self, value, index=None):
        """Add element maintaining monotonic property"""
        # Remove elements that violate monotonic property
        while self.queue:
            stored_value = self.queue[-1][0] if index is not None else self.queue[-1]
            if self.compare(stored_value, value):
                self.queue.pop()
            else:
                break
        
        if index is not None:
            self.queue.append((value, index))
        else:
            self.queue.append(value)
    
    def front(self):
        """Get front element"""
        if self.queue:
            return self.queue[0]
        return None
    
    def pop_front(self):
        """Remove front element"""
        if self.queue:
            return self.queue.popleft()
        return None
    
    def is_empty(self):
        """Check if queue is empty"""
        return len(self.queue) == 0

# Example: Custom monotonic queue for finding elements in range
def elements_in_range(arr, min_val, max_val):
    """Find all elements in given range using monotonic queue"""
    mono_queue = MonotonicQueue(lambda a, b: a < min_val or a > max_val)
    result = []
    
    for val in arr:
        if min_val <= val <= max_val:
            mono_queue.push(val)
            result.append(mono_queue.front())
    
    return result
```

**Testing Monotonic Queues:**
```python
def test_monotonic_queues():
    """Test various monotonic queue applications"""
    
    # Test sliding window maximum
    print("Sliding Window Maximum:")
    arr1 = [1, 3, -1, -3, 5, 3, 6, 7]
    k = 3
    max_result = sliding_window_maximum(arr1, k)
    min_result = sliding_window_minimum(arr1, k)
    print(f"Array: {arr1}")
    print(f"Max in windows of size {k}: {max_result}")
    print(f"Min in windows of size {k}: {min_result}")
    
    # Test largest rectangle in histogram
    print("\nLargest Rectangle in Histogram:")
    heights = [2, 1, 5, 6, 2, 3]
    area = largest_rectangle_histogram(heights)
    print(f"Heights: {heights}")
    print(f"Largest rectangle area: {area}")
    
    # Test next greater element
    print("\nNext Greater Element:")
    arr2 = [4, 5, 2, 25, 7, 8]
    nge = next_greater_element_monotonic(arr2)
    print(f"Array: {arr2}")
    print(f"Next greater elements: {nge}")
```

**Applications Summary:**

| Application | Queue Type | Time | Use Case |
|-------------|------------|------|----------|
| **Sliding Window Max** | Decreasing | O(n) | Stock prices, temperatures |
| **Sliding Window Min** | Increasing | O(n) | Resource monitoring |
| **Largest Rectangle** | Increasing | O(n) | Image processing, architecture |
| **Next Greater Element** | Decreasing | O(n) | Stack problems, parsing |

---

### 25. **How do you implement a circular buffer?** *(Zoho, Facebook)*

**Circular Buffer (Ring Buffer):** A fixed-size buffer that wraps around when it reaches the end, making it appear as if the buffer is circular.

**Method 1: Array-based Implementation**
```python
class CircularBuffer:
    """
    Circular buffer implementation using array
    Fixed size, overwrites old data when full
    """
    
    def __init__(self, capacity):
        if capacity <= 0:
            raise ValueError("Capacity must be positive")
        
        self.capacity = capacity
        self.buffer = [None] * capacity
        self.head = 0    # Points to next write position
        self.tail = 0    # Points to next read position
        self.size = 0    # Current number of elements
        self.is_full = False
    
    def put(self, item):
        """
        Add item to buffer
        Time: O(1)
        """
        self.buffer[self.head] = item
        
        if self.is_full:
            # Buffer is full, advance tail (overwrite old data)
            self.tail = (self.tail + 1) % self.capacity
        
        self.head = (self.head + 1) % self.capacity
        
        if not self.is_full:
            self.size += 1
            if self.head == self.tail:
                self.is_full = True
    
    def get(self):
        """
        Remove and return item from buffer
        Time: O(1)
        """
        if self.is_empty():
            raise IndexError("get from empty buffer")
        
        item = self.buffer[self.tail]
        self.buffer[self.tail] = None  # Clear reference
        self.tail = (self.tail + 1) % self.capacity
        
        self.is_full = False
        self.size -= 1
        
        return item
    
    def peek(self):
        """
        Return next item without removing it
        Time: O(1)
        """
        if self.is_empty():
            raise IndexError("peek from empty buffer")
        return self.buffer[self.tail]
    
    def is_empty(self):
        """Check if buffer is empty"""
        return self.size == 0
    
    def is_buffer_full(self):
        """Check if buffer is full"""
        return self.is_full
    
    def current_size(self):
        """Get current number of elements"""
        return self.size
    
    def get_capacity(self):
        """Get buffer capacity"""
        return self.capacity
    
    def clear(self):
        """Clear all elements from buffer"""
        self.buffer = [None] * self.capacity
        self.head = 0
        self.tail = 0
        self.size = 0
        self.is_full = False
    
    def to_list(self):
        """Convert buffer contents to list (for debugging)"""
        if self.is_empty():
            return []
        
        result = []
        index = self.tail
        for _ in range(self.size):
            result.append(self.buffer[index])
            index = (index + 1) % self.capacity
        
        return result
```

**Method 2: Circular Buffer with Overwrite Policy**
```python
class CircularBufferOverwrite:
    """
    Circular buffer that always accepts new data
    Automatically overwrites oldest data when full
    """
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.buffer = [None] * capacity
        self.head = 0
        self.count = 0
    
    def put(self, item):
        """Add item, overwriting oldest if necessary"""
        self.buffer[self.head] = item
        self.head = (self.head + 1) % self.capacity
        
        if self.count < self.capacity:
            self.count += 1
    
    def get(self):
        """Get oldest item"""
        if self.count == 0:
            raise IndexError("get from empty buffer")
        
        # Calculate tail position
        tail = (self.head - self.count) % self.capacity
        item = self.buffer[tail]
        
        # Shift all elements (inefficient but maintains order)
        for i in range(self.count - 1):
            old_index = (tail + i) % self.capacity
            new_index = (tail + i + 1) % self.capacity
            self.buffer[old_index] = self.buffer[new_index]
        
        self.count -= 1
        self.head = (self.head - 1) % self.capacity
        
        return item
    
    def peek(self):
        """Peek at oldest item"""
        if self.count == 0:
            raise IndexError("peek from empty buffer")
        
        tail = (self.head - self.count) % self.capacity
        return self.buffer[tail]
    
    def is_empty(self):
        return self.count == 0
    
    def is_full(self):
        return self.count == self.capacity
    
    def size(self):
        return self.count
```

**Method 3: Thread-Safe Circular Buffer**
```python
import threading

class ThreadSafeCircularBuffer:
    """
    Thread-safe circular buffer using locks
    Safe for producer-consumer scenarios
    """
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.buffer = [None] * capacity
        self.head = 0
        self.tail = 0
        self.size = 0
        self.lock = threading.Lock()
        self.not_empty = threading.Condition(self.lock)
        self.not_full = threading.Condition(self.lock)
    
    def put(self, item, timeout=None):
        """
        Add item to buffer with optional timeout
        Blocks if buffer is full
        """
        with self.not_full:
            # Wait until buffer is not full
            if not self.not_full.wait_for(
                lambda: self.size < self.capacity, timeout=timeout):
                raise TimeoutError("Buffer full, timeout exceeded")
            
            self.buffer[self.head] = item
            self.head = (self.head + 1) % self.capacity
            self.size += 1
            
            # Notify waiting consumers
            self.not_empty.notify()
    
    def get(self, timeout=None):
        """
        Remove and return item with optional timeout
        Blocks if buffer is empty
        """
        with self.not_empty:
            # Wait until buffer is not empty
            if not self.not_empty.wait_for(
                lambda: self.size > 0, timeout=timeout):
                raise TimeoutError("Buffer empty, timeout exceeded")
            
            item = self.buffer[self.tail]
            self.buffer[self.tail] = None
            self.tail = (self.tail + 1) % self.capacity
            self.size -= 1
            
            # Notify waiting producers
            self.not_full.notify()
            
            return item
    
    def try_put(self, item):
        """Try to add item without blocking"""
        with self.lock:
            if self.size >= self.capacity:
                return False
            
            self.buffer[self.head] = item
            self.head = (self.head + 1) % self.capacity
            self.size += 1
            return True
    
    def try_get(self):
        """Try to get item without blocking"""
        with self.lock:
            if self.size == 0:
                return None
            
            item = self.buffer[self.tail]
            self.buffer[self.tail] = None
            self.tail = (self.tail + 1) % self.capacity
            self.size -= 1
            return item
```

**Method 4: Circular Buffer with Statistics**
```python
import time
from collections import namedtuple

BufferStats = namedtuple('BufferStats', [
    'capacity', 'size', 'total_puts', 'total_gets', 
    'overwrites', 'peak_size', 'utilization'
])

class CircularBufferWithStats:
    """
    Circular buffer that tracks usage statistics
    Useful for performance monitoring
    """
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.buffer = [None] * capacity
        self.head = 0
        self.tail = 0
        self.size = 0
        
        # Statistics
        self.total_puts = 0
        self.total_gets = 0
        self.overwrites = 0
        self.peak_size = 0
        self.start_time = time.time()
    
    def put(self, item):
        """Add item and update statistics"""
        was_full = self.size == self.capacity
        
        self.buffer[self.head] = item
        self.head = (self.head + 1) % self.capacity
        
        if was_full:
            self.tail = (self.tail + 1) % self.capacity
            self.overwrites += 1
        else:
            self.size += 1
            self.peak_size = max(self.peak_size, self.size)
        
        self.total_puts += 1
    
    def get(self):
        """Get item and update statistics"""
        if self.size == 0:
            raise IndexError("get from empty buffer")
        
        item = self.buffer[self.tail]
        self.buffer[self.tail] = None
        self.tail = (self.tail + 1) % self.capacity
        self.size -= 1
        self.total_gets += 1
        
        return item
    
    def get_stats(self):
        """Get buffer statistics"""
        runtime = time.time() - self.start_time
        utilization = (self.total_puts * 100.0) / (self.capacity * max(1, runtime))
        
        return BufferStats(
            capacity=self.capacity,
            size=self.size,
            total_puts=self.total_puts,
            total_gets=self.total_gets,
            overwrites=self.overwrites,
            peak_size=self.peak_size,
            utilization=min(100.0, utilization)
        )
    
    def reset_stats(self):
        """Reset all statistics"""
        self.total_puts = 0
        self.total_gets = 0
        self.overwrites = 0
        self.peak_size = self.size
        self.start_time = time.time()
```

**Complete Testing Example:**
```python
def test_circular_buffers():
    """Test different circular buffer implementations"""
    
    print("Testing Basic Circular Buffer:")
    print("=" * 40)
    
    cb = CircularBuffer(3)
    
    # Test basic operations
    operations = [
        ("put", 1), ("put", 2), ("put", 3),    # Fill buffer
        ("get", None), ("put", 4),              # Replace oldest
        ("put", 5),                             # Overwrite
        ("get", None), ("get", None), ("get", None)  # Empty buffer
    ]
    
    for op, value in operations:
        try:
            print(f"\nOperation: {op}({value if value else ''})")
            print(f"Before: {cb.to_list()} (size: {cb.current_size()})")
            
            if op == "put":
                cb.put(value)
                result = f"Put {value}"
            elif op == "get":
                result = f"Got {cb.get()}"
            
            print(f"After:  {cb.to_list()} (size: {cb.current_size()})")
            print(f"Result: {result}")
            
        except IndexError as e:
            print(f"Error: {e}")
    
    print("\nTesting Buffer with Statistics:")
    print("=" * 40)
    
    stats_buffer = CircularBufferWithStats(5)
    
    # Perform operations
    for i in range(10):
        stats_buffer.put(f"item_{i}")
    
    for _ in range(3):
        stats_buffer.get()
    
    stats = stats_buffer.get_stats()
    print(f"Buffer Stats:")
    print(f"  Capacity: {stats.capacity}")
    print(f"  Current Size: {stats.size}")
    print(f"  Total Puts: {stats.total_puts}")
    print(f"  Total Gets: {stats.total_gets}")
    print(f"  Overwrites: {stats.overwrites}")
    print(f"  Peak Size: {stats.peak_size}")
    print(f"  Utilization: {stats.utilization:.2f}%")

def demonstrate_producer_consumer():
    """Demonstrate producer-consumer pattern with circular buffer"""
    import threading
    import time
    import random
    
    buffer = ThreadSafeCircularBuffer(5)
    
    def producer(name, items):
        """Producer function"""
        for i in range(items):
            item = f"{name}_item_{i}"
            try:
                buffer.put(item, timeout=1.0)
                print(f"Producer {name}: put {item}")
                time.sleep(random.uniform(0.1, 0.3))
            except TimeoutError:
                print(f"Producer {name}: timeout putting {item}")
    
    def consumer(name, items):
        """Consumer function"""
        for _ in range(items):
            try:
                item = buffer.get(timeout=1.0)
                print(f"Consumer {name}: got {item}")
                time.sleep(random.uniform(0.2, 0.4))
            except TimeoutError:
                print(f"Consumer {name}: timeout getting item")
    
    # Create and start threads
    threads = [
        threading.Thread(target=producer, args=("P1", 5)),
        threading.Thread(target=producer, args=("P2", 5)),
        threading.Thread(target=consumer, args=("C1", 5)),
        threading.Thread(target=consumer, args=("C2", 5))
    ]
    
    for thread in threads:
        thread.start()
    
    for thread in threads:
        thread.join()
    
    print("Producer-Consumer demo completed")

# Run tests
test_circular_buffers()
```

**Real-world Applications:**

| Application | Buffer Type | Use Case |
|-------------|-------------|----------|
| **Audio/Video Streaming** | Basic | Media buffering |
| **Logging Systems** | Overwrite | Recent log entries |
| **Producer-Consumer** | Thread-safe | Multi-threaded apps |
| **Network Protocols** | Statistics | Performance monitoring |
| **Embedded Systems** | All types | Resource-constrained environments |

**Performance Characteristics:**

| Operation | Time Complexity | Space Complexity |
|-----------|----------------|------------------|
| **Put** | O(1) | O(1) |
| **Get** | O(1) | O(1) |
| **Peek** | O(1) | O(1) |
| **Clear** | O(1) | O(1) |

Circular buffers are essential for efficient memory usage in streaming applications and real-time systems! ðŸŽ¯

---

*These comprehensive answers cover advanced stack and queue applications with multiple implementation approaches, real-world examples, and practical use cases. Perfect for understanding both theoretical concepts and practical implementations! ðŸš€*
