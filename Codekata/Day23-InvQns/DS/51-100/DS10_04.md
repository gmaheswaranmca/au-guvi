# DATA STRUCTURES - BEGINNER LEVEL INTERVIEW ANSWERS (SET 2 - Part 15)

> **Target:** IT, CS, AI, ML, ECE candidates  
> **Level:** Beginner  
> **Companies:** Microsoft, Zoho, Facebook, Google, etc.  
> **Category:** Data Structures (Extended Set) - Questions 47-48

## ðŸ“‹ Table of Contents
- [ðŸ—‚ï¸ Graph Representation Methods](#ðŸ—‚ï¸-graph-representation-methods) (Questions 47-48)

---

## ðŸ—‚ï¸ Graph Representation Methods

### 47. **What are the ways to represent a graph?** *(Microsoft, Zoho)*

**Graph Representation Overview:** There are several ways to represent graphs in memory, each with different trade-offs in terms of space complexity, time complexity for various operations, and implementation complexity. The choice depends on the specific use case and the operations you need to perform frequently.

**Main Graph Representation Methods:**

1. **Adjacency Matrix**
2. **Adjacency List**
3. **Edge List**
4. **Incidence Matrix**
5. **Adjacency Set**

**Complete Implementation of All Representation Methods:**
```python
class GraphRepresentations:
    """
    Comprehensive implementation of all graph representation methods
    with detailed comparison and analysis
    """
    
    def __init__(self, vertices, directed=False):
        """
        Initialize graph with all representation methods
        Args:
            vertices: List of vertex names/identifiers
            directed: True for directed graph, False for undirected
        """
        self.vertices = list(vertices)
        self.directed = directed
        self.vertex_count = len(vertices)
        
        # Create vertex to index mapping
        self.vertex_to_index = {v: i for i, v in enumerate(vertices)}
        self.index_to_vertex = {i: v for i, v in enumerate(vertices)}
        
        # Initialize all representations
        self._init_adjacency_matrix()
        self._init_adjacency_list()
        self._init_edge_list()
        self._init_incidence_matrix()
        self._init_adjacency_set()
        
        print(f"Initialized {'directed' if directed else 'undirected'} graph with {self.vertex_count} vertices")
        print(f"Available representations: Matrix, List, Edge List, Incidence Matrix, Set")
    
    def _init_adjacency_matrix(self):
        """Initialize adjacency matrix representation"""
        self.adjacency_matrix = [[0] * self.vertex_count for _ in range(self.vertex_count)]
    
    def _init_adjacency_list(self):
        """Initialize adjacency list representation"""
        self.adjacency_list = {vertex: [] for vertex in self.vertices}
    
    def _init_edge_list(self):
        """Initialize edge list representation"""
        self.edge_list = []
    
    def _init_incidence_matrix(self):
        """Initialize incidence matrix representation"""
        self.incidence_matrix = []  # Will grow as edges are added
        self.edge_names = []  # Track edge names for incidence matrix
    
    def _init_adjacency_set(self):
        """Initialize adjacency set representation"""
        self.adjacency_set = {vertex: set() for vertex in self.vertices}
    
    def add_edge(self, vertex1, vertex2, weight=1):
        """
        Add edge to all representations
        Args:
            vertex1: Source vertex
            vertex2: Target vertex
            weight: Edge weight (default 1)
        """
        if vertex1 not in self.vertices or vertex2 not in self.vertices:
            print(f"Error: One or both vertices not found")
            return False
        
        print(f"\nAdding edge: {vertex1} {'-->' if self.directed else '<-->'} {vertex2} (weight: {weight})")
        
        # Add to adjacency matrix
        self._add_edge_matrix(vertex1, vertex2, weight)
        
        # Add to adjacency list
        self._add_edge_list(vertex1, vertex2, weight)
        
        # Add to edge list
        self._add_edge_edge_list(vertex1, vertex2, weight)
        
        # Add to incidence matrix
        self._add_edge_incidence(vertex1, vertex2, weight)
        
        # Add to adjacency set
        self._add_edge_set(vertex1, vertex2, weight)
        
        print(f"Edge added to all representations")
        return True
    
    def _add_edge_matrix(self, vertex1, vertex2, weight):
        """Add edge to adjacency matrix"""
        i, j = self.vertex_to_index[vertex1], self.vertex_to_index[vertex2]
        self.adjacency_matrix[i][j] = weight
        
        if not self.directed:
            self.adjacency_matrix[j][i] = weight
    
    def _add_edge_list(self, vertex1, vertex2, weight):
        """Add edge to adjacency list"""
        self.adjacency_list[vertex1].append({'to': vertex2, 'weight': weight})
        
        if not self.directed:
            self.adjacency_list[vertex2].append({'to': vertex1, 'weight': weight})
    
    def _add_edge_edge_list(self, vertex1, vertex2, weight):
        """Add edge to edge list"""
        edge = {'from': vertex1, 'to': vertex2, 'weight': weight}
        self.edge_list.append(edge)
        
        # For undirected graphs, we could add reverse edge or handle in algorithms
        # Here we'll store one edge and handle direction in algorithms
    
    def _add_edge_incidence(self, vertex1, vertex2, weight):
        """Add edge to incidence matrix"""
        edge_name = f"e{len(self.edge_names)}"
        self.edge_names.append(edge_name)
        
        # Create new column for this edge
        new_column = [0] * self.vertex_count
        
        i, j = self.vertex_to_index[vertex1], self.vertex_to_index[vertex2]
        
        if self.directed:
            new_column[i] = 1   # Outgoing edge
            new_column[j] = -1  # Incoming edge
        else:
            new_column[i] = 1
            new_column[j] = 1
        
        # Add column to incidence matrix
        if not self.incidence_matrix:
            self.incidence_matrix = [[val] for val in new_column]
        else:
            for k in range(self.vertex_count):
                self.incidence_matrix[k].append(new_column[k])
    
    def _add_edge_set(self, vertex1, vertex2, weight):
        """Add edge to adjacency set"""
        # For weighted graphs, we can store tuples (vertex, weight)
        self.adjacency_set[vertex1].add((vertex2, weight))
        
        if not self.directed:
            self.adjacency_set[vertex2].add((vertex1, weight))
    
    def display_all_representations(self):
        """Display all graph representations"""
        print(f"\n{'='*80}")
        print(f"GRAPH REPRESENTATIONS COMPARISON")
        print(f"{'='*80}")
        
        self._display_adjacency_matrix()
        self._display_adjacency_list()
        self._display_edge_list()
        self._display_incidence_matrix()
        self._display_adjacency_set()
        
        # Show space complexity analysis
        self._analyze_space_complexity()
    
    def _display_adjacency_matrix(self):
        """Display adjacency matrix representation"""
        print(f"\n1. ADJACENCY MATRIX REPRESENTATION:")
        print(f"{'-'*50}")
        
        # Header
        print("     " + "  ".join(f"{v:3}" for v in self.vertices))
        
        # Matrix rows
        for i, vertex in enumerate(self.vertices):
            row_str = f"{vertex:3}: " + "  ".join(f"{self.adjacency_matrix[i][j]:3}" for j in range(self.vertex_count))
            print(row_str)
        
        print(f"Space Complexity: O(VÂ²) = O({self.vertex_count}Â²) = {self.vertex_count**2} cells")
        print(f"Edge lookup time: O(1)")
        print(f"Add edge time: O(1)")
        print(f"Memory usage: {self.vertex_count**2 * 4} bytes (assuming 4 bytes per integer)")
    
    def _display_adjacency_list(self):
        """Display adjacency list representation"""
        print(f"\n2. ADJACENCY LIST REPRESENTATION:")
        print(f"{'-'*50}")
        
        total_entries = 0
        for vertex in self.vertices:
            neighbors = self.adjacency_list[vertex]
            if neighbors:
                neighbor_str = ", ".join(f"{edge['to']}({edge['weight']})" for edge in neighbors)
                print(f"{vertex:3}: [{neighbor_str}]")
                total_entries += len(neighbors)
            else:
                print(f"{vertex:3}: []")
        
        print(f"Space Complexity: O(V + E) = O({self.vertex_count} + {total_entries}) = {self.vertex_count + total_entries} entries")
        print(f"Edge lookup time: O(degree of vertex)")
        print(f"Add edge time: O(1)")
        print(f"Memory usage: ~{(self.vertex_count + total_entries) * 16} bytes (estimated)")
    
    def _display_edge_list(self):
        """Display edge list representation"""
        print(f"\n3. EDGE LIST REPRESENTATION:")
        print(f"{'-'*50}")
        
        for i, edge in enumerate(self.edge_list):
            direction = "-->" if self.directed else "<-->"
            print(f"Edge {i:2}: {edge['from']} {direction} {edge['to']} (weight: {edge['weight']})")
        
        edge_count = len(self.edge_list)
        print(f"Space Complexity: O(E) = O({edge_count}) = {edge_count} edges")
        print(f"Edge lookup time: O(E)")
        print(f"Add edge time: O(1)")
        print(f"Memory usage: ~{edge_count * 24} bytes (estimated per edge)")
    
    def _display_incidence_matrix(self):
        """Display incidence matrix representation"""
        print(f"\n4. INCIDENCE MATRIX REPRESENTATION:")
        print(f"{'-'*50}")
        
        if not self.incidence_matrix:
            print("No edges added yet")
            return
        
        # Header with edge names
        print("     " + "  ".join(f"{edge:4}" for edge in self.edge_names))
        
        # Matrix rows
        for i, vertex in enumerate(self.vertices):
            row_str = f"{vertex:3}: " + "  ".join(f"{self.incidence_matrix[i][j]:4}" for j in range(len(self.edge_names)))
            print(row_str)
        
        edge_count = len(self.edge_names)
        cells = self.vertex_count * edge_count
        print(f"Space Complexity: O(V Ã— E) = O({self.vertex_count} Ã— {edge_count}) = {cells} cells")
        print(f"Edge lookup time: O(E)")
        print(f"Add edge time: O(V)")
        print(f"Memory usage: {cells * 4} bytes (assuming 4 bytes per integer)")
    
    def _display_adjacency_set(self):
        """Display adjacency set representation"""
        print(f"\n5. ADJACENCY SET REPRESENTATION:")
        print(f"{'-'*50}")
        
        total_entries = 0
        for vertex in self.vertices:
            neighbors = self.adjacency_set[vertex]
            if neighbors:
                neighbor_str = ", ".join(f"{neighbor[0]}({neighbor[1]})" for neighbor in neighbors)
                print(f"{vertex:3}: {{{neighbor_str}}}")
                total_entries += len(neighbors)
            else:
                print(f"{vertex:3}: {{}}")
        
        print(f"Space Complexity: O(V + E) = O({self.vertex_count} + {total_entries}) = {self.vertex_count + total_entries} entries")
        print(f"Edge lookup time: O(1) average")
        print(f"Add edge time: O(1) average")
        print(f"Memory usage: ~{(self.vertex_count + total_entries) * 20} bytes (estimated)")
    
    def _analyze_space_complexity(self):
        """Analyze space complexity of all representations"""
        print(f"\n{'='*80}")
        print(f"SPACE COMPLEXITY ANALYSIS")
        print(f"{'='*80}")
        
        V = self.vertex_count
        E = len(self.edge_list)
        
        complexities = [
            ("Adjacency Matrix", f"O(VÂ²)", f"O({V}Â²)", V**2),
            ("Adjacency List", f"O(V + E)", f"O({V} + {E})", V + E),
            ("Edge List", f"O(E)", f"O({E})", E),
            ("Incidence Matrix", f"O(V Ã— E)", f"O({V} Ã— {E})", V * E),
            ("Adjacency Set", f"O(V + E)", f"O({V} + {E})", V + E)
        ]
        
        print(f"{'Representation':<18} | {'General':<10} | {'Current':<15} | {'Actual Size':<12}")
        print(f"{'-'*70}")
        
        for name, general, current, actual in complexities:
            print(f"{name:<18} | {general:<10} | {current:<15} | {actual:<12}")
        
        # Recommendations
        print(f"\nRECOMMENDations:")
        print(f"â€¢ Dense graphs (E â‰ˆ VÂ²): Use Adjacency Matrix")
        print(f"â€¢ Sparse graphs (E << VÂ²): Use Adjacency List or Set")
        print(f"â€¢ Frequent edge queries: Use Adjacency Matrix or Set")
        print(f"â€¢ Memory constraints: Use Edge List")
        print(f"â€¢ Mathematical operations: Use Incidence Matrix")
    
    def compare_operations(self):
        """Compare time complexity of common operations"""
        print(f"\n{'='*80}")
        print(f"OPERATION TIME COMPLEXITY COMPARISON")
        print(f"{'='*80}")
        
        operations = [
            ("Add Vertex", "O(VÂ²)", "O(1)", "O(1)", "O(V)", "O(1)"),
            ("Add Edge", "O(1)", "O(1)", "O(1)", "O(V)", "O(1)"),
            ("Remove Edge", "O(1)", "O(V)", "O(E)", "O(V)", "O(1)"),
            ("Check Edge", "O(1)", "O(V)", "O(E)", "O(E)", "O(1)"),
            ("Get Neighbors", "O(V)", "O(1)", "O(E)", "O(E)", "O(1)"),
            ("Iterate Edges", "O(VÂ²)", "O(V+E)", "O(E)", "O(VE)", "O(V+E)")
        ]
        
        headers = ["Operation", "Adj Matrix", "Adj List", "Edge List", "Inc Matrix", "Adj Set"]
        
        # Print header
        header_line = " | ".join(f"{h:<12}" for h in headers)
        print(header_line)
        print("-" * len(header_line))
        
        # Print operations
        for op_data in operations:
            line = " | ".join(f"{item:<12}" for item in op_data)
            print(line)
    
    def demonstrate_real_world_usage(self):
        """Show when to use each representation"""
        print(f"\n{'='*80}")
        print(f"REAL-WORLD USAGE SCENARIOS")
        print(f"{'='*80}")
        
        scenarios = [
            {
                "representation": "Adjacency Matrix",
                "best_for": [
                    "Dense graphs (social networks with many connections)",
                    "Mathematical graph operations (matrix multiplication)",
                    "Algorithms requiring fast edge lookups",
                    "Small graphs where memory isn't a concern"
                ],
                "examples": [
                    "Flight route networks (complete connectivity)",
                    "Correlation matrices in data analysis",
                    "Game adjacency (chess, checkers)",
                    "Small social networks"
                ]
            },
            {
                "representation": "Adjacency List",
                "best_for": [
                    "Sparse graphs (most real-world networks)",
                    "Graph traversal algorithms (DFS, BFS)",
                    "Dynamic graphs with frequent additions",
                    "General-purpose graph representation"
                ],
                "examples": [
                    "Web page link structure",
                    "Social media follower networks",
                    "Computer network topology",
                    "File system directory structure"
                ]
            },
            {
                "representation": "Edge List",
                "best_for": [
                    "Storing graphs in files/databases",
                    "Algorithms that process edges sequentially",
                    "Minimal memory usage requirements",
                    "Graph input/output operations"
                ],
                "examples": [
                    "Network traffic data",
                    "Database relationship tables",
                    "GPS route data",
                    "Financial transaction networks"
                ]
            },
            {
                "representation": "Incidence Matrix",
                "best_for": [
                    "Mathematical graph theory research",
                    "Hypergraphs and multigraphs",
                    "Network flow problems",
                    "Specific algorithmic requirements"
                ],
                "examples": [
                    "Circuit analysis (electrical networks)",
                    "Chemical reaction networks",
                    "Project dependency analysis",
                    "Academic research applications"
                ]
            },
            {
                "representation": "Adjacency Set",
                "best_for": [
                    "Frequent edge existence queries",
                    "Dynamic graphs with edge additions/removals",
                    "Sparse graphs requiring fast lookups",
                    "Graph algorithms with set operations"
                ],
                "examples": [
                    "Real-time social networks",
                    "Online gaming networks",
                    "Dynamic routing tables",
                    "Live collaboration systems"
                ]
            }
        ]
        
        for i, scenario in enumerate(scenarios, 1):
            print(f"\n{i}. {scenario['representation'].upper()}")
            print(f"{'-' * (len(scenario['representation']) + 4)}")
            
            print(f"Best for:")
            for use_case in scenario['best_for']:
                print(f"  â€¢ {use_case}")
            
            print(f"Examples:")
            for example in scenario['examples']:
                print(f"  â€¢ {example}")

def test_graph_representations():
    """Comprehensive test of all graph representation methods"""
    
    print("COMPREHENSIVE GRAPH REPRESENTATIONS TEST")
    print("=" * 80)
    
    # Create test graph
    vertices = ['A', 'B', 'C', 'D']
    graph = GraphRepresentations(vertices, directed=False)
    
    # Add some edges
    edges = [
        ('A', 'B', 5),
        ('B', 'C', 3),
        ('C', 'D', 7),
        ('D', 'A', 2),
        ('A', 'C', 4)
    ]
    
    print(f"\nAdding edges to create a sample graph:")
    for v1, v2, weight in edges:
        graph.add_edge(v1, v2, weight)
    
    # Display all representations
    graph.display_all_representations()
    
    # Compare operations
    graph.compare_operations()
    
    # Show usage scenarios
    graph.demonstrate_real_world_usage()
    
    return graph

# Run comprehensive test
test_graph = test_graph_representations()
```

**Practical Implementation Examples:**
```python
class PracticalGraphRepresentations:
    """
    Practical implementations optimized for specific use cases
    """
    
    def __init__(self):
        pass
    
    def create_sparse_graph_representation(self):
        """Optimized representation for sparse graphs"""
        print("SPARSE GRAPH OPTIMIZATION EXAMPLE:")
        print("=" * 50)
        
        class SparseGraph:
            def __init__(self, expected_vertices=1000):
                # Use dictionary-based adjacency list for sparse graphs
                self.adjacency = {}
                self.vertex_count = 0
                self.edge_count = 0
            
            def add_vertex(self, vertex):
                if vertex not in self.adjacency:
                    self.adjacency[vertex] = []
                    self.vertex_count += 1
                    return True
                return False
            
            def add_edge(self, v1, v2, weight=1):
                self.add_vertex(v1)
                self.add_vertex(v2)
                
                # Check if edge already exists
                for edge in self.adjacency[v1]:
                    if edge['to'] == v2:
                        return False
                
                self.adjacency[v1].append({'to': v2, 'weight': weight})
                self.adjacency[v2].append({'to': v1, 'weight': weight})
                self.edge_count += 1
                return True
            
            def get_density(self):
                max_edges = self.vertex_count * (self.vertex_count - 1) // 2
                return self.edge_count / max_edges if max_edges > 0 else 0
            
            def memory_usage_estimate(self):
                # Rough estimate in bytes
                vertex_overhead = self.vertex_count * 40  # Dict overhead
                edge_storage = self.edge_count * 2 * 32   # Edge objects
                return vertex_overhead + edge_storage
        
        # Demonstrate sparse graph
        sparse = SparseGraph()
        
        # Add many vertices with few edges (typical sparse scenario)
        for i in range(100):
            sparse.add_vertex(f"V{i}")
        
        # Add only a few edges (sparse)
        sparse_edges = [(f"V{i}", f"V{i+1}") for i in range(0, 90, 10)]
        for v1, v2 in sparse_edges:
            sparse.add_edge(v1, v2)
        
        print(f"Sparse Graph Analysis:")
        print(f"Vertices: {sparse.vertex_count}")
        print(f"Edges: {sparse.edge_count}")
        print(f"Density: {sparse.get_density():.4f} ({sparse.get_density()*100:.2f}%)")
        print(f"Estimated memory: {sparse.memory_usage_estimate()} bytes")
        print(f"Adjacency matrix would need: {sparse.vertex_count**2 * 4} bytes")
        print(f"Space savings: {((sparse.vertex_count**2 * 4 - sparse.memory_usage_estimate()) / (sparse.vertex_count**2 * 4)) * 100:.1f}%")
    
    def create_dense_graph_representation(self):
        """Optimized representation for dense graphs"""
        print("\nDENSE GRAPH OPTIMIZATION EXAMPLE:")
        print("=" * 50)
        
        class DenseGraph:
            def __init__(self, vertices):
                self.vertices = list(vertices)
                self.vertex_count = len(vertices)
                self.vertex_to_index = {v: i for i, v in enumerate(vertices)}
                
                # Use bit matrix for unweighted dense graphs
                # Or regular matrix for weighted dense graphs
                self.matrix = [[0] * self.vertex_count for _ in range(self.vertex_count)]
                self.edge_count = 0
            
            def add_edge(self, v1, v2, weight=1):
                if v1 not in self.vertex_to_index or v2 not in self.vertex_to_index:
                    return False
                
                i, j = self.vertex_to_index[v1], self.vertex_to_index[v2]
                
                if self.matrix[i][j] == 0:  # New edge
                    self.edge_count += 1
                
                self.matrix[i][j] = weight
                self.matrix[j][i] = weight  # Undirected
                return True
            
            def has_edge(self, v1, v2):
                if v1 not in self.vertex_to_index or v2 not in self.vertex_to_index:
                    return False
                i, j = self.vertex_to_index[v1], self.vertex_to_index[v2]
                return self.matrix[i][j] != 0
            
            def get_density(self):
                max_edges = self.vertex_count * (self.vertex_count - 1) // 2
                return self.edge_count / max_edges if max_edges > 0 else 0
            
            def memory_usage(self):
                return self.vertex_count**2 * 4  # 4 bytes per integer
        
        # Demonstrate dense graph
        vertices = [f"V{i}" for i in range(20)]
        dense = DenseGraph(vertices)
        
        # Add many edges (dense scenario)
        import random
        random.seed(42)
        
        for i in range(len(vertices)):
            for j in range(i+1, len(vertices)):
                if random.random() < 0.7:  # 70% edge probability
                    dense.add_edge(vertices[i], vertices[j], random.randint(1, 10))
        
        print(f"Dense Graph Analysis:")
        print(f"Vertices: {dense.vertex_count}")
        print(f"Edges: {dense.edge_count}")
        print(f"Density: {dense.get_density():.4f} ({dense.get_density()*100:.2f}%)")
        print(f"Memory usage: {dense.memory_usage()} bytes")
        print(f"Matrix utilization: {(dense.edge_count / (dense.vertex_count**2 / 2)) * 100:.1f}%")
    
    def create_dynamic_graph_representation(self):
        """Optimized representation for frequently changing graphs"""
        print("\nDYNAMIC GRAPH OPTIMIZATION EXAMPLE:")
        print("=" * 50)
        
        class DynamicGraph:
            def __init__(self):
                # Use sets for O(1) edge operations
                self.adjacency = {}
                self.vertex_count = 0
                self.edge_count = 0
                self.operation_count = 0
            
            def add_vertex(self, vertex):
                if vertex not in self.adjacency:
                    self.adjacency[vertex] = set()
                    self.vertex_count += 1
                    self.operation_count += 1
                    return True
                return False
            
            def remove_vertex(self, vertex):
                if vertex not in self.adjacency:
                    return False
                
                # Remove all edges to this vertex
                for v in list(self.adjacency.keys()):
                    if v != vertex:
                        self.remove_edge(v, vertex)
                
                # Remove vertex
                del self.adjacency[vertex]
                self.vertex_count -= 1
                self.operation_count += 1
                return True
            
            def add_edge(self, v1, v2):
                self.add_vertex(v1)
                self.add_vertex(v2)
                
                if v2 not in self.adjacency[v1]:
                    self.adjacency[v1].add(v2)
                    self.adjacency[v2].add(v1)
                    self.edge_count += 1
                    self.operation_count += 1
                    return True
                return False
            
            def remove_edge(self, v1, v2):
                if (v1 in self.adjacency and v2 in self.adjacency[v1]):
                    self.adjacency[v1].remove(v2)
                    self.adjacency[v2].remove(v1)
                    self.edge_count -= 1
                    self.operation_count += 1
                    return True
                return False
            
            def has_edge(self, v1, v2):
                self.operation_count += 1
                return (v1 in self.adjacency and v2 in self.adjacency[v1])
            
            def get_stats(self):
                return {
                    'vertices': self.vertex_count,
                    'edges': self.edge_count,
                    'operations': self.operation_count,
                    'avg_degree': (2 * self.edge_count / self.vertex_count) if self.vertex_count > 0 else 0
                }
        
        # Demonstrate dynamic operations
        dynamic = DynamicGraph()
        
        print("Performing dynamic operations:")
        
        # Add vertices
        for i in range(10):
            dynamic.add_vertex(f"V{i}")
        
        # Add some edges
        for i in range(8):
            dynamic.add_edge(f"V{i}", f"V{i+1}")
        
        print(f"After initial setup: {dynamic.get_stats()}")
        
        # Dynamic modifications
        dynamic.add_edge("V0", "V5")
        dynamic.add_edge("V2", "V7")
        dynamic.remove_edge("V3", "V4")
        dynamic.add_vertex("V10")
        dynamic.add_edge("V10", "V0")
        
        print(f"After modifications: {dynamic.get_stats()}")
        
        # Test performance
        import time
        start_time = time.time()
        
        for i in range(1000):
            dynamic.has_edge("V0", "V5")
        
        end_time = time.time()
        print(f"1000 edge lookups took: {(end_time - start_time)*1000:.2f} ms")

def test_practical_representations():
    """Test practical graph representation implementations"""
    
    practical = PracticalGraphRepresentations()
    
    # Test different optimizations
    practical.create_sparse_graph_representation()
    practical.create_dense_graph_representation()
    practical.create_dynamic_graph_representation()

# Run practical tests
test_practical_representations()
```

---

### 48. **What is an adjacency matrix?** *(Facebook, Google)*

**Adjacency Matrix Definition:** An adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are connected by edges or not. For a graph with V vertices, the adjacency matrix is a VÃ—V matrix where each cell [i][j] represents the edge relationship between vertex i and vertex j.

**Key Characteristics:**
- **Size**: V Ã— V where V is the number of vertices
- **Space Complexity**: O(VÂ²)
- **Symmetry**: Symmetric for undirected graphs, not necessarily for directed graphs
- **Values**: 0 (no edge), 1 (edge exists), or weight value for weighted graphs

**Complete Adjacency Matrix Implementation:**
```python
class AdjacencyMatrix:
    """
    Comprehensive adjacency matrix implementation with detailed analysis
    """
    
    def __init__(self, vertices, directed=False):
        """
        Initialize adjacency matrix
        Args:
            vertices: List of vertex identifiers
            directed: True for directed graph, False for undirected
        """
        self.vertices = list(vertices)
        self.directed = directed
        self.vertex_count = len(vertices)
        
        # Create vertex to index mapping
        self.vertex_to_index = {v: i for i, v in enumerate(vertices)}
        self.index_to_vertex = {i: v for i, v in enumerate(vertices)}
        
        # Initialize matrix with zeros
        self.matrix = [[0] * self.vertex_count for _ in range(self.vertex_count)]
        
        # Statistics
        self.edge_count = 0
        self.operations_count = 0
        
        print(f"Created adjacency matrix for {'directed' if directed else 'undirected'} graph")
        print(f"Matrix size: {self.vertex_count} Ã— {self.vertex_count} = {self.vertex_count**2} cells")
        print(f"Memory usage: ~{self.vertex_count**2 * 4} bytes (4 bytes per integer)")
    
    def add_edge(self, vertex1, vertex2, weight=1):
        """
        Add edge to adjacency matrix
        Time: O(1), Space: O(1)
        """
        if vertex1 not in self.vertex_to_index or vertex2 not in self.vertex_to_index:
            print(f"Error: Vertex not found")
            return False
        
        i, j = self.vertex_to_index[vertex1], self.vertex_to_index[vertex2]
        
        # Check if edge already exists
        if self.matrix[i][j] != 0:
            print(f"Edge {vertex1} -> {vertex2} already exists with weight {self.matrix[i][j]}")
            return False
        
        # Add edge
        self.matrix[i][j] = weight
        
        # For undirected graphs, add symmetric edge
        if not self.directed:
            self.matrix[j][i] = weight
        
        self.edge_count += 1
        self.operations_count += 1
        
        direction = "<->" if not self.directed else "->"
        print(f"Added edge: {vertex1} {direction} {vertex2} (weight: {weight})")
        return True
    
    def remove_edge(self, vertex1, vertex2):
        """
        Remove edge from adjacency matrix
        Time: O(1), Space: O(1)
        """
        if vertex1 not in self.vertex_to_index or vertex2 not in self.vertex_to_index:
            print(f"Error: Vertex not found")
            return False
        
        i, j = self.vertex_to_index[vertex1], self.vertex_to_index[vertex2]
        
        if self.matrix[i][j] == 0:
            print(f"Edge {vertex1} -> {vertex2} does not exist")
            return False
        
        # Remove edge
        self.matrix[i][j] = 0
        
        # For undirected graphs, remove symmetric edge
        if not self.directed:
            self.matrix[j][i] = 0
        
        self.edge_count -= 1
        self.operations_count += 1
        
        print(f"Removed edge: {vertex1} -> {vertex2}")
        return True
    
    def has_edge(self, vertex1, vertex2):
        """
        Check if edge exists
        Time: O(1), Space: O(1)
        """
        if vertex1 not in self.vertex_to_index or vertex2 not in self.vertex_to_index:
            return False
        
        i, j = self.vertex_to_index[vertex1], self.vertex_to_index[vertex2]
        self.operations_count += 1
        return self.matrix[i][j] != 0
    
    def get_edge_weight(self, vertex1, vertex2):
        """
        Get weight of edge between two vertices
        Time: O(1), Space: O(1)
        """
        if vertex1 not in self.vertex_to_index or vertex2 not in self.vertex_to_index:
            return None
        
        i, j = self.vertex_to_index[vertex1], self.vertex_to_index[vertex2]
        self.operations_count += 1
        return self.matrix[i][j] if self.matrix[i][j] != 0 else None
    
    def get_neighbors(self, vertex):
        """
        Get all neighbors of a vertex
        Time: O(V), Space: O(V)
        """
        if vertex not in self.vertex_to_index:
            return []
        
        i = self.vertex_to_index[vertex]
        neighbors = []
        
        for j in range(self.vertex_count):
            if self.matrix[i][j] != 0:
                neighbors.append({
                    'vertex': self.index_to_vertex[j],
                    'weight': self.matrix[i][j]
                })
        
        self.operations_count += self.vertex_count
        return neighbors
    
    def get_in_neighbors(self, vertex):
        """
        Get all incoming neighbors (for directed graphs)
        Time: O(V), Space: O(V)
        """
        if not self.directed:
            return self.get_neighbors(vertex)
        
        if vertex not in self.vertex_to_index:
            return []
        
        j = self.vertex_to_index[vertex]
        in_neighbors = []
        
        for i in range(self.vertex_count):
            if self.matrix[i][j] != 0:
                in_neighbors.append({
                    'vertex': self.index_to_vertex[i],
                    'weight': self.matrix[i][j]
                })
        
        self.operations_count += self.vertex_count
        return in_neighbors
    
    def get_degree(self, vertex):
        """
        Get degree of vertex
        For directed: returns (in_degree, out_degree)
        For undirected: returns total degree
        """
        if vertex not in self.vertex_to_index:
            return None
        
        i = self.vertex_to_index[vertex]
        
        if self.directed:
            # Out-degree: count non-zero entries in row i
            out_degree = sum(1 for j in range(self.vertex_count) if self.matrix[i][j] != 0)
            
            # In-degree: count non-zero entries in column i
            in_degree = sum(1 for j in range(self.vertex_count) if self.matrix[j][i] != 0)
            
            self.operations_count += 2 * self.vertex_count
            return (in_degree, out_degree)
        else:
            # Total degree for undirected graph
            degree = sum(1 for j in range(self.vertex_count) if self.matrix[i][j] != 0)
            self.operations_count += self.vertex_count
            return degree
    
    def is_symmetric(self):
        """
        Check if matrix is symmetric (should be true for undirected graphs)
        Time: O(VÂ²), Space: O(1)
        """
        for i in range(self.vertex_count):
            for j in range(self.vertex_count):
                if self.matrix[i][j] != self.matrix[j][i]:
                    return False
        
        self.operations_count += self.vertex_count**2
        return True
    
    def get_density(self):
        """
        Calculate graph density
        Density = (actual edges) / (maximum possible edges)
        """
        if self.directed:
            max_edges = self.vertex_count * (self.vertex_count - 1)
        else:
            max_edges = self.vertex_count * (self.vertex_count - 1) // 2
        
        return self.edge_count / max_edges if max_edges > 0 else 0
    
    def matrix_multiply(self, other_matrix):
        """
        Multiply this adjacency matrix with another matrix
        Useful for finding paths of specific lengths
        Time: O(VÂ³), Space: O(VÂ²)
        """
        if not isinstance(other_matrix, AdjacencyMatrix):
            print("Error: Can only multiply with another AdjacencyMatrix")
            return None
        
        if self.vertex_count != other_matrix.vertex_count:
            print("Error: Matrix dimensions don't match")
            return None
        
        # Create result matrix
        result = AdjacencyMatrix(self.vertices, self.directed)
        
        # Matrix multiplication
        for i in range(self.vertex_count):
            for j in range(self.vertex_count):
                sum_val = 0
                for k in range(self.vertex_count):
                    sum_val += self.matrix[i][k] * other_matrix.matrix[k][j]
                result.matrix[i][j] = sum_val
        
        self.operations_count += self.vertex_count**3
        return result
    
    def find_paths_of_length(self, length):
        """
        Find number of paths of specific length between all pairs
        Uses matrix exponentiation
        Time: O(VÂ³ log length), Space: O(VÂ²)
        """
        if length <= 0:
            return None
        
        # Start with identity matrix for length 0
        result = AdjacencyMatrix(self.vertices, self.directed)
        
        # Set diagonal to 1 (identity matrix)
        for i in range(self.vertex_count):
            result.matrix[i][i] = 1
        
        # Current power of the matrix
        current_power = AdjacencyMatrix(self.vertices, self.directed)
        current_power.matrix = [row[:] for row in self.matrix]  # Copy matrix
        
        # Matrix exponentiation by repeated squaring
        remaining_length = length
        while remaining_length > 0:
            if remaining_length % 2 == 1:
                result = result.matrix_multiply(current_power)
            current_power = current_power.matrix_multiply(current_power)
            remaining_length //= 2
        
        return result
    
    def transpose(self):
        """
        Get transpose of adjacency matrix
        Time: O(VÂ²), Space: O(VÂ²)
        """
        transposed = AdjacencyMatrix(self.vertices, self.directed)
        
        for i in range(self.vertex_count):
            for j in range(self.vertex_count):
                transposed.matrix[i][j] = self.matrix[j][i]
        
        self.operations_count += self.vertex_count**2
        return transposed
    
    def display_matrix(self, title="Adjacency Matrix"):
        """Display the adjacency matrix in a formatted way"""
        print(f"\n{title}:")
        print("=" * (len(title) + 1))
        
        # Print column headers
        print("    " + "".join(f"{v:4}" for v in self.vertices))
        print("    " + "-" * (4 * self.vertex_count))
        
        # Print matrix rows
        for i, vertex in enumerate(self.vertices):
            row_str = f"{vertex:2}: " + "".join(f"{self.matrix[i][j]:4}" for j in range(self.vertex_count))
            print(row_str)
        
        print(f"\nMatrix Properties:")
        print(f"  Size: {self.vertex_count} Ã— {self.vertex_count}")
        print(f"  Edge count: {self.edge_count}")
        print(f"  Density: {self.get_density():.4f} ({self.get_density()*100:.2f}%)")
        print(f"  Is symmetric: {self.is_symmetric()}")
        print(f"  Memory usage: ~{self.vertex_count**2 * 4} bytes")
        print(f"  Operations performed: {self.operations_count}")
    
    def analyze_complexity(self):
        """Analyze time and space complexity of operations"""
        print(f"\nAdjacency Matrix Complexity Analysis:")
        print("=" * 45)
        
        complexities = [
            ("Space Complexity", "O(VÂ²)", f"O({self.vertex_count}Â²)", f"{self.vertex_count**2} cells"),
            ("Add Edge", "O(1)", "O(1)", "Constant time"),
            ("Remove Edge", "O(1)", "O(1)", "Constant time"),
            ("Check Edge", "O(1)", "O(1)", "Constant time"),
            ("Get Neighbors", "O(V)", f"O({self.vertex_count})", f"Check {self.vertex_count} cells"),
            ("Get Degree", "O(V)", f"O({self.vertex_count})", f"Check {self.vertex_count} cells"),
            ("Matrix Multiply", "O(VÂ³)", f"O({self.vertex_count}Â³)", f"{self.vertex_count**3} operations")
        ]
        
        print(f"{'Operation':<15} | {'General':<8} | {'Current':<12} | {'Description'}")
        print("-" * 60)
        
        for op, general, current, desc in complexities:
            print(f"{op:<15} | {general:<8} | {current:<12} | {desc}")
    
    def get_statistics(self):
        """Get comprehensive statistics about the matrix"""
        stats = {
            'vertices': self.vertex_count,
            'edges': self.edge_count,
            'density': self.get_density(),
            'is_symmetric': self.is_symmetric(),
            'memory_bytes': self.vertex_count**2 * 4,
            'operations_count': self.operations_count,
            'sparsity': 1 - self.get_density()
        }
        
        # Calculate degree distribution
        degrees = []
        for vertex in self.vertices:
            degree = self.get_degree(vertex)
            if self.directed:
                degrees.append(degree[0] + degree[1])  # Total degree
            else:
                degrees.append(degree)
        
        if degrees:
            stats['min_degree'] = min(degrees)
            stats['max_degree'] = max(degrees)
            stats['avg_degree'] = sum(degrees) / len(degrees)
        
        return stats

def test_adjacency_matrix():
    """Comprehensive test of adjacency matrix implementation"""
    
    print("ADJACENCY MATRIX COMPREHENSIVE TEST")
    print("=" * 50)
    
    # Test 1: Undirected graph
    print("Test 1: Undirected Graph")
    print("-" * 30)
    
    vertices = ['A', 'B', 'C', 'D']
    undirected_matrix = AdjacencyMatrix(vertices, directed=False)
    
    # Add edges
    edges = [('A', 'B', 5), ('B', 'C', 3), ('C', 'D', 7), ('D', 'A', 2)]
    for v1, v2, weight in edges:
        undirected_matrix.add_edge(v1, v2, weight)
    
    undirected_matrix.display_matrix("Undirected Graph Matrix")
    
    # Test operations
    print(f"\nOperation Tests:")
    print(f"Has edge A-B: {undirected_matrix.has_edge('A', 'B')}")
    print(f"Edge weight A-B: {undirected_matrix.get_edge_weight('A', 'B')}")
    print(f"Neighbors of A: {[n['vertex'] for n in undirected_matrix.get_neighbors('A')]}")
    print(f"Degree of A: {undirected_matrix.get_degree('A')}")
    
    # Test 2: Directed graph
    print(f"\n{'='*50}")
    print("Test 2: Directed Graph")
    print("-" * 30)
    
    directed_matrix = AdjacencyMatrix(vertices, directed=True)
    
    # Add directed edges
    directed_edges = [('A', 'B', 5), ('B', 'C', 3), ('C', 'A', 7), ('D', 'A', 2)]
    for v1, v2, weight in directed_edges:
        directed_matrix.add_edge(v1, v2, weight)
    
    directed_matrix.display_matrix("Directed Graph Matrix")
    
    # Test directed operations
    print(f"\nDirected Operation Tests:")
    print(f"Out-neighbors of A: {[n['vertex'] for n in directed_matrix.get_neighbors('A')]}")
    print(f"In-neighbors of A: {[n['vertex'] for n in directed_matrix.get_in_neighbors('A')]}")
    print(f"Degree of A (in, out): {directed_matrix.get_degree('A')}")
    
    # Test 3: Matrix operations
    print(f"\n{'='*50}")
    print("Test 3: Matrix Operations")
    print("-" * 30)
    
    # Matrix multiplication (paths of length 2)
    print("Finding paths of length 2:")
    paths_2 = directed_matrix.matrix_multiply(directed_matrix)
    if paths_2:
        paths_2.display_matrix("Paths of Length 2")
    
    # Transpose
    print("\nTranspose matrix:")
    transposed = directed_matrix.transpose()
    transposed.display_matrix("Transposed Matrix")
    
    # Complexity analysis
    directed_matrix.analyze_complexity()
    
    # Statistics
    print(f"\nStatistics:")
    stats = directed_matrix.get_statistics()
    for key, value in stats.items():
        print(f"  {key.replace('_', ' ').title()}: {value}")

def demonstrate_adjacency_matrix_applications():
    """Show practical applications of adjacency matrix"""
    
    print("\n" + "="*60)
    print("ADJACENCY MATRIX APPLICATIONS")
    print("="*60)
    
    applications = [
        {
            "title": "Social Network Analysis",
            "description": "Represent friendships/follows in social media",
            "matrix_benefit": "Fast lookup of connections, matrix operations for influence analysis",
            "example": "Facebook friend connections, Twitter follower network"
        },
        {
            "title": "Transportation Networks",
            "description": "Route networks with travel times/distances",
            "matrix_benefit": "Quick route existence checks, shortest path algorithms",
            "example": "Flight routes, public transit systems"
        },
        {
            "title": "Web Page Ranking",
            "description": "Link structure between web pages",
            "matrix_benefit": "PageRank algorithm uses matrix powers for ranking",
            "example": "Google's PageRank, link analysis"
        },
        {
            "title": "Game Theory",
            "description": "Player relationships and game states",
            "matrix_benefit": "Fast state transitions, strategy analysis",
            "example": "Chess positions, multiplayer game interactions"
        },
        {
            "title": "Circuit Analysis",
            "description": "Electrical component connections",
            "matrix_benefit": "Network equations, circuit simulation",
            "example": "Electronic circuit design, power grid analysis"
        },
        {
            "title": "Computer Networks",
            "description": "Network topology and connectivity",
            "matrix_benefit": "Routing table computation, network reliability",
            "example": "Internet backbone, LAN topology"
        }
    ]
    
    for i, app in enumerate(applications, 1):
        print(f"\n{i}. {app['title']}")
        print(f"   Description: {app['description']}")
        print(f"   Matrix Benefit: {app['matrix_benefit']}")
        print(f"   Example: {app['example']}")
    
    print(f"\nKey Advantages of Adjacency Matrix:")
    print(f"â€¢ O(1) edge lookup and modification")
    print(f"â€¢ Excellent for dense graphs")
    print(f"â€¢ Supports mathematical operations (multiplication, transpose)")
    print(f"â€¢ Simple and intuitive representation")
    print(f"â€¢ Cache-friendly for small graphs")
    
    print(f"\nKey Disadvantages:")
    print(f"â€¢ O(VÂ²) space complexity even for sparse graphs")
    print(f"â€¢ O(V) time to find all neighbors")
    print(f"â€¢ Wasteful for sparse graphs")
    print(f"â€¢ Fixed size (difficult to add vertices dynamically)")

# Run comprehensive tests
test_adjacency_matrix()
demonstrate_adjacency_matrix_applications()
```

**Adjacency Matrix Properties Summary:**

| **Property** | **Value** | **Explanation** |
|--------------|-----------|-----------------|
| **Space Complexity** | O(VÂ²) | Always VÃ—V matrix regardless of edge count |
| **Edge Lookup** | O(1) | Direct array access matrix[i][j] |
| **Add Edge** | O(1) | Direct assignment to matrix cell |
| **Remove Edge** | O(1) | Set matrix cell to 0 |
| **Find Neighbors** | O(V) | Scan entire row/column |
| **Memory Efficiency** | Poor for sparse graphs | Uses VÂ² space even with few edges |
| **Cache Performance** | Good for small graphs | Contiguous memory layout |
| **Mathematical Operations** | Excellent | Matrix multiplication, powers, transpose |

**When to Use Adjacency Matrix:**
- **Dense graphs** where most vertex pairs are connected
- **Small graphs** where memory isn't a constraint
- **Frequent edge lookups** are required
- **Mathematical graph operations** (matrix powers, analysis)
- **Fixed vertex set** with known size
- **Graph algorithms** that benefit from O(1) edge checks

**When NOT to Use Adjacency Matrix:**
- **Sparse graphs** with few edges relative to vertices
- **Large graphs** where memory is limited
- **Dynamic graphs** with frequent vertex additions
- **Memory-constrained environments**
- **Graphs where neighbor iteration is more common than edge lookup**

Understanding adjacency matrices is crucial for choosing the right graph representation based on your specific requirements and constraints! ðŸ—‚ï¸

---

*These comprehensive answers cover all major graph representation methods and provide detailed analysis of adjacency matrices with practical implementations, complexity analysis, and usage guidelines. Perfect for technical interviews requiring deep understanding of graph representations! ðŸš€*
