# DATA STRUCTURES - BEGINNER LEVEL INTERVIEW ANSWERS (SET 2 - Part 14)

> **Target:** IT, CS, AI, ML, ECE candidates  
> **Level:** Beginner  
> **Companies:** Zoho, Facebook, Google, Amazon, etc.  
> **Category:** Data Structures (Extended Set) - Questions 45-46

## 📋 Table of Contents
- [🕸️ Graph Data Structure Fundamentals](#🕸️-graph-data-structure-fundamentals) (Questions 45-46)

---

## 🕸️ Graph Data Structure Fundamentals

### 45. **What is a graph data structure?** *(Zoho, Facebook)*

**Graph Definition:** A graph is a non-linear data structure consisting of vertices (nodes) and edges that connect these vertices. It's used to represent relationships between different entities and is fundamental to solving many real-world problems like social networks, transportation systems, and computer networks.

**Core Components:**
- **Vertices (V)**: The fundamental units/nodes of a graph
- **Edges (E)**: Connections between vertices that represent relationships
- **Graph G = (V, E)**: Mathematical representation as a set of vertices and edges

**Complete Graph Implementation:**
```python
class Graph:
    """
    Comprehensive graph data structure implementation
    Supports both directed and undirected graphs with multiple representations
    """
    
    def __init__(self, directed=False):
        """
        Initialize graph
        Args:
            directed: True for directed graph, False for undirected
        """
        self.directed = directed
        self.vertices = set()
        self.adjacency_list = {}
        self.edge_count = 0
        
        print(f"Created {'directed' if directed else 'undirected'} graph")
    
    def add_vertex(self, vertex):
        """
        Add a vertex to the graph
        Time: O(1), Space: O(1)
        """
        if vertex not in self.vertices:
            self.vertices.add(vertex)
            self.adjacency_list[vertex] = []
            print(f"Added vertex: {vertex}")
            return True
        else:
            print(f"Vertex {vertex} already exists")
            return False
    
    def add_edge(self, vertex1, vertex2, weight=None):
        """
        Add an edge between two vertices
        Time: O(1), Space: O(1)
        """
        # Ensure both vertices exist
        self.add_vertex(vertex1)
        self.add_vertex(vertex2)
        
        # Create edge representation
        edge_info = {'to': vertex2, 'weight': weight} if weight is not None else vertex2
        
        # Add edge from vertex1 to vertex2
        if edge_info not in self.adjacency_list[vertex1]:
            self.adjacency_list[vertex1].append(edge_info)
            self.edge_count += 1
            
            # For undirected graphs, add reverse edge
            if not self.directed:
                reverse_edge = {'to': vertex1, 'weight': weight} if weight is not None else vertex1
                if reverse_edge not in self.adjacency_list[vertex2]:
                    self.adjacency_list[vertex2].append(reverse_edge)
            
            weight_str = f" (weight: {weight})" if weight is not None else ""
            direction = "->" if self.directed else "<->"
            print(f"Added edge: {vertex1} {direction} {vertex2}{weight_str}")
            return True
        else:
            print(f"Edge {vertex1} -> {vertex2} already exists")
            return False
    
    def remove_vertex(self, vertex):
        """
        Remove a vertex and all its edges
        Time: O(V + E), Space: O(1)
        """
        if vertex not in self.vertices:
            print(f"Vertex {vertex} does not exist")
            return False
        
        # Remove all edges to this vertex
        edges_removed = 0
        for v in self.vertices:
            if v != vertex:
                # Remove edges from other vertices to this vertex
                original_length = len(self.adjacency_list[v])
                self.adjacency_list[v] = [
                    edge for edge in self.adjacency_list[v] 
                    if (edge if isinstance(edge, str) else edge['to']) != vertex
                ]
                edges_removed += original_length - len(self.adjacency_list[v])
        
        # Remove vertex and its adjacency list
        edges_removed += len(self.adjacency_list[vertex])
        del self.adjacency_list[vertex]
        self.vertices.remove(vertex)
        self.edge_count -= edges_removed
        
        print(f"Removed vertex: {vertex} and {edges_removed} edges")
        return True
    
    def remove_edge(self, vertex1, vertex2):
        """
        Remove an edge between two vertices
        Time: O(V), Space: O(1)
        """
        if vertex1 not in self.vertices or vertex2 not in self.vertices:
            print(f"One or both vertices do not exist")
            return False
        
        # Remove edge from vertex1 to vertex2
        original_length = len(self.adjacency_list[vertex1])
        self.adjacency_list[vertex1] = [
            edge for edge in self.adjacency_list[vertex1]
            if (edge if isinstance(edge, str) else edge['to']) != vertex2
        ]
        
        edge_removed = original_length > len(self.adjacency_list[vertex1])
        
        # For undirected graphs, remove reverse edge
        if not self.directed and edge_removed:
            self.adjacency_list[vertex2] = [
                edge for edge in self.adjacency_list[vertex2]
                if (edge if isinstance(edge, str) else edge['to']) != vertex1
            ]
        
        if edge_removed:
            self.edge_count -= 1
            print(f"Removed edge: {vertex1} -> {vertex2}")
            return True
        else:
            print(f"Edge {vertex1} -> {vertex2} does not exist")
            return False
    
    def get_neighbors(self, vertex):
        """
        Get all neighbors of a vertex
        Time: O(1), Space: O(1)
        """
        if vertex not in self.vertices:
            return []
        
        neighbors = []
        for edge in self.adjacency_list[vertex]:
            if isinstance(edge, str):
                neighbors.append(edge)
            else:
                neighbors.append(edge['to'])
        
        return neighbors
    
    def has_edge(self, vertex1, vertex2):
        """
        Check if edge exists between two vertices
        Time: O(V), Space: O(1)
        """
        if vertex1 not in self.vertices or vertex2 not in self.vertices:
            return False
        
        for edge in self.adjacency_list[vertex1]:
            target = edge if isinstance(edge, str) else edge['to']
            if target == vertex2:
                return True
        return False
    
    def get_edge_weight(self, vertex1, vertex2):
        """
        Get weight of edge between two vertices
        Time: O(V), Space: O(1)
        """
        if vertex1 not in self.vertices or vertex2 not in self.vertices:
            return None
        
        for edge in self.adjacency_list[vertex1]:
            if isinstance(edge, dict) and edge['to'] == vertex2:
                return edge['weight']
            elif isinstance(edge, str) and edge == vertex2:
                return 1  # Default weight for unweighted edges
        
        return None
    
    def degree(self, vertex):
        """
        Get degree of a vertex
        For directed graphs: returns (in_degree, out_degree)
        For undirected graphs: returns total degree
        """
        if vertex not in self.vertices:
            return None
        
        out_degree = len(self.adjacency_list[vertex])
        
        if self.directed:
            # Calculate in-degree for directed graphs
            in_degree = 0
            for v in self.vertices:
                if v != vertex:
                    for edge in self.adjacency_list[v]:
                        target = edge if isinstance(edge, str) else edge['to']
                        if target == vertex:
                            in_degree += 1
            return (in_degree, out_degree)
        else:
            return out_degree
    
    def is_connected(self):
        """
        Check if graph is connected (for undirected) or strongly connected (for directed)
        Time: O(V + E), Space: O(V)
        """
        if len(self.vertices) == 0:
            return True
        
        # For undirected graphs, use simple DFS
        if not self.directed:
            return self._is_connected_undirected()
        else:
            # For directed graphs, check strong connectivity
            return self._is_strongly_connected()
    
    def _is_connected_undirected(self):
        """Check connectivity for undirected graph using DFS"""
        if not self.vertices:
            return True
        
        start_vertex = next(iter(self.vertices))
        visited = set()
        stack = [start_vertex]
        
        while stack:
            vertex = stack.pop()
            if vertex not in visited:
                visited.add(vertex)
                neighbors = self.get_neighbors(vertex)
                for neighbor in neighbors:
                    if neighbor not in visited:
                        stack.append(neighbor)
        
        return len(visited) == len(self.vertices)
    
    def _is_strongly_connected(self):
        """Check strong connectivity for directed graph using Kosaraju's algorithm"""
        # Simplified check - in practice would use Kosaraju's or Tarjan's algorithm
        # This is a basic version for educational purposes
        
        # Check if every vertex can reach every other vertex
        for start in self.vertices:
            visited = set()
            stack = [start]
            
            while stack:
                vertex = stack.pop()
                if vertex not in visited:
                    visited.add(vertex)
                    neighbors = self.get_neighbors(vertex)
                    for neighbor in neighbors:
                        if neighbor not in visited:
                            stack.append(neighbor)
            
            if len(visited) != len(self.vertices):
                return False
        
        return True
    
    def has_cycle(self):
        """
        Detect if graph has a cycle
        Time: O(V + E), Space: O(V)
        """
        if self.directed:
            return self._has_cycle_directed()
        else:
            return self._has_cycle_undirected()
    
    def _has_cycle_directed(self):
        """Detect cycle in directed graph using DFS with colors"""
        WHITE, GRAY, BLACK = 0, 1, 2
        colors = {vertex: WHITE for vertex in self.vertices}
        
        def dfs(vertex):
            colors[vertex] = GRAY
            
            neighbors = self.get_neighbors(vertex)
            for neighbor in neighbors:
                if colors[neighbor] == GRAY:  # Back edge found
                    return True
                elif colors[neighbor] == WHITE and dfs(neighbor):
                    return True
            
            colors[vertex] = BLACK
            return False
        
        for vertex in self.vertices:
            if colors[vertex] == WHITE:
                if dfs(vertex):
                    return True
        
        return False
    
    def _has_cycle_undirected(self):
        """Detect cycle in undirected graph using DFS"""
        visited = set()
        
        def dfs(vertex, parent):
            visited.add(vertex)
            
            neighbors = self.get_neighbors(vertex)
            for neighbor in neighbors:
                if neighbor == parent:  # Skip parent in undirected graph
                    continue
                
                if neighbor in visited:  # Back edge found
                    return True
                elif dfs(neighbor, vertex):
                    return True
            
            return False
        
        for vertex in self.vertices:
            if vertex not in visited:
                if dfs(vertex, None):
                    return True
        
        return False
    
    def get_graph_info(self):
        """Get comprehensive information about the graph"""
        info = {
            'type': 'Directed' if self.directed else 'Undirected',
            'vertices': len(self.vertices),
            'edges': self.edge_count,
            'density': self.edge_count / (len(self.vertices) * (len(self.vertices) - 1)) if len(self.vertices) > 1 else 0,
            'is_connected': self.is_connected(),
            'has_cycle': self.has_cycle()
        }
        
        # Calculate degree information
        if len(self.vertices) > 0:
            degrees = []
            for vertex in self.vertices:
                deg = self.degree(vertex)
                if self.directed:
                    degrees.append(deg[0] + deg[1])  # Total degree for directed
                else:
                    degrees.append(deg)
            
            info['min_degree'] = min(degrees)
            info['max_degree'] = max(degrees)
            info['avg_degree'] = sum(degrees) / len(degrees)
        
        return info
    
    def visualize(self):
        """Create a visual representation of the graph"""
        print(f"\n{self.get_graph_info()['type']} Graph Visualization:")
        print("=" * 50)
        print(f"Vertices: {sorted(list(self.vertices))}")
        print(f"Edges: {self.edge_count}")
        
        print(f"\nAdjacency List:")
        for vertex in sorted(self.vertices):
            neighbors = self.adjacency_list[vertex]
            if neighbors:
                neighbor_strs = []
                for edge in neighbors:
                    if isinstance(edge, str):
                        neighbor_strs.append(edge)
                    else:
                        weight_str = f"({edge['weight']})" if edge['weight'] is not None else ""
                        neighbor_strs.append(f"{edge['to']}{weight_str}")
                
                direction = " -> " if self.directed else " -- "
                print(f"  {vertex}{direction}{', '.join(neighbor_strs)}")
            else:
                print(f"  {vertex} (isolated)")
        
        # Show graph properties
        info = self.get_graph_info()
        print(f"\nGraph Properties:")
        for key, value in info.items():
            if key != 'type':
                print(f"  {key.replace('_', ' ').title()}: {value}")

def test_graph_fundamentals():
    """Test basic graph operations and concepts"""
    
    print("Graph Data Structure Fundamentals Test:")
    print("=" * 60)
    
    # Test 1: Undirected Graph
    print("Test 1: Undirected Graph")
    undirected = Graph(directed=False)
    
    # Add vertices and edges
    vertices = ['A', 'B', 'C', 'D', 'E']
    for vertex in vertices:
        undirected.add_vertex(vertex)
    
    # Add edges to create a connected graph
    edges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('A', 'E')]
    for v1, v2 in edges:
        undirected.add_edge(v1, v2)
    
    undirected.visualize()
    
    print("\n" + "="*60)
    
    # Test 2: Directed Graph
    print("Test 2: Directed Graph")
    directed = Graph(directed=True)
    
    # Add vertices and edges
    for vertex in vertices:
        directed.add_vertex(vertex)
    
    # Add directed edges
    directed_edges = [('A', 'B'), ('B', 'C'), ('C', 'A'), ('D', 'E')]
    for v1, v2 in directed_edges:
        directed.add_edge(v1, v2)
    
    directed.visualize()
    
    print("\n" + "="*60)
    
    # Test 3: Weighted Graph
    print("Test 3: Weighted Graph")
    weighted = Graph(directed=False)
    
    # Add weighted edges
    weighted_edges = [
        ('City1', 'City2', 100),
        ('City2', 'City3', 150),
        ('City3', 'City1', 120),
        ('City1', 'City4', 200)
    ]
    
    for v1, v2, weight in weighted_edges:
        weighted.add_edge(v1, v2, weight)
    
    weighted.visualize()
    
    print("\n" + "="*60)
    
    # Test 4: Graph Operations
    print("Test 4: Graph Operations")
    test_graph = Graph(directed=False)
    
    # Build a test graph
    test_vertices = [1, 2, 3, 4, 5]
    for v in test_vertices:
        test_graph.add_vertex(v)
    
    test_edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]
    for v1, v2 in test_edges:
        test_graph.add_edge(v1, v2)
    
    print("Testing graph operations:")
    print(f"Neighbors of vertex 2: {test_graph.get_neighbors(2)}")
    print(f"Degree of vertex 1: {test_graph.degree(1)}")
    print(f"Has edge 1-3: {test_graph.has_edge(1, 3)}")
    print(f"Has edge 1-2: {test_graph.has_edge(1, 2)}")
    
    # Test removal
    print(f"\nRemoving edge 1-2:")
    test_graph.remove_edge(1, 2)
    print(f"Has edge 1-2 after removal: {test_graph.has_edge(1, 2)}")
    
    test_graph.visualize()

test_graph_fundamentals()
```

**Graph Types and Classifications:**
```python
class GraphTypes:
    """
    Demonstrate different types of graphs and their characteristics
    """
    
    def __init__(self):
        pass
    
    def create_simple_graph(self):
        """
        Simple Graph: No loops, no multiple edges
        """
        print("Simple Graph Example:")
        simple = Graph(directed=False)
        
        vertices = ['A', 'B', 'C', 'D']
        edges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('A', 'D')]
        
        for v in vertices:
            simple.add_vertex(v)
        
        for v1, v2 in edges:
            simple.add_edge(v1, v2)
        
        simple.visualize()
        return simple
    
    def create_complete_graph(self, n):
        """
        Complete Graph: Every pair of vertices is connected
        """
        print(f"Complete Graph K{n} Example:")
        complete = Graph(directed=False)
        
        # Add vertices
        vertices = [f'V{i}' for i in range(1, n+1)]
        for v in vertices:
            complete.add_vertex(v)
        
        # Add all possible edges
        for i in range(len(vertices)):
            for j in range(i+1, len(vertices)):
                complete.add_edge(vertices[i], vertices[j])
        
        complete.visualize()
        
        # Verify complete graph properties
        info = complete.get_graph_info()
        expected_edges = n * (n - 1) // 2
        print(f"Expected edges in K{n}: {expected_edges}")
        print(f"Actual edges: {info['edges']}")
        print(f"Is complete: {info['edges'] == expected_edges}")
        
        return complete
    
    def create_bipartite_graph(self):
        """
        Bipartite Graph: Vertices can be divided into two disjoint sets
        """
        print("Bipartite Graph Example:")
        bipartite = Graph(directed=False)
        
        # Set A vertices
        set_a = ['A1', 'A2', 'A3']
        # Set B vertices
        set_b = ['B1', 'B2', 'B3']
        
        # Add all vertices
        for v in set_a + set_b:
            bipartite.add_vertex(v)
        
        # Add edges only between sets (not within sets)
        bipartite_edges = [
            ('A1', 'B1'), ('A1', 'B2'),
            ('A2', 'B2'), ('A2', 'B3'),
            ('A3', 'B1'), ('A3', 'B3')
        ]
        
        for v1, v2 in bipartite_edges:
            bipartite.add_edge(v1, v2)
        
        bipartite.visualize()
        
        # Verify bipartite property
        is_bipartite = self._check_bipartite(bipartite, set_a, set_b)
        print(f"Is bipartite: {is_bipartite}")
        
        return bipartite
    
    def create_tree_graph(self):
        """
        Tree Graph: Connected acyclic graph
        """
        print("Tree Graph Example:")
        tree = Graph(directed=False)
        
        # Create a tree structure
        vertices = ['Root', 'L1', 'R1', 'L2', 'R2', 'L3', 'R3']
        tree_edges = [
            ('Root', 'L1'), ('Root', 'R1'),
            ('L1', 'L2'), ('L1', 'R2'),
            ('R1', 'L3'), ('R1', 'R3')
        ]
        
        for v in vertices:
            tree.add_vertex(v)
        
        for v1, v2 in tree_edges:
            tree.add_edge(v1, v2)
        
        tree.visualize()
        
        # Verify tree properties
        info = tree.get_graph_info()
        is_tree = (info['is_connected'] and 
                  not info['has_cycle'] and 
                  info['edges'] == info['vertices'] - 1)
        print(f"Is tree: {is_tree}")
        print(f"Tree property: V - 1 = E → {info['vertices']} - 1 = {info['edges']}")
        
        return tree
    
    def create_cyclic_graph(self):
        """
        Graph with cycles
        """
        print("Cyclic Graph Example:")
        cyclic = Graph(directed=False)
        
        vertices = ['A', 'B', 'C', 'D', 'E']
        cyclic_edges = [
            ('A', 'B'), ('B', 'C'), ('C', 'D'), 
            ('D', 'A'),  # Forms a cycle
            ('C', 'E')   # Additional branch
        ]
        
        for v in vertices:
            cyclic.add_vertex(v)
        
        for v1, v2 in cyclic_edges:
            cyclic.add_edge(v1, v2)
        
        cyclic.visualize()
        return cyclic
    
    def create_directed_acyclic_graph(self):
        """
        DAG: Directed Acyclic Graph
        """
        print("Directed Acyclic Graph (DAG) Example:")
        dag = Graph(directed=True)
        
        vertices = ['Start', 'A', 'B', 'C', 'End']
        dag_edges = [
            ('Start', 'A'), ('Start', 'B'),
            ('A', 'C'), ('B', 'C'),
            ('A', 'End'), ('C', 'End')
        ]
        
        for v in vertices:
            dag.add_vertex(v)
        
        for v1, v2 in dag_edges:
            dag.add_edge(v1, v2)
        
        dag.visualize()
        
        # Verify DAG properties
        info = dag.get_graph_info()
        print(f"Is DAG (directed and acyclic): {not info['has_cycle']}")
        
        return dag
    
    def _check_bipartite(self, graph, set_a, set_b):
        """Check if graph maintains bipartite property"""
        # Check that edges only exist between sets, not within sets
        for vertex in set_a:
            neighbors = graph.get_neighbors(vertex)
            for neighbor in neighbors:
                if neighbor in set_a:  # Edge within set A
                    return False
        
        for vertex in set_b:
            neighbors = graph.get_neighbors(vertex)
            for neighbor in neighbors:
                if neighbor in set_b:  # Edge within set B
                    return False
        
        return True
    
    def demonstrate_graph_applications(self):
        """Show real-world applications of different graph types"""
        print("\nReal-World Graph Applications:")
        print("=" * 50)
        
        applications = [
            {
                "type": "Social Network",
                "graph_type": "Undirected",
                "description": "Friendships are mutual relationships",
                "example": "Facebook friends, LinkedIn connections"
            },
            {
                "type": "Web Pages",
                "graph_type": "Directed",
                "description": "Links from one page to another",
                "example": "Hyperlinks, PageRank algorithm"
            },
            {
                "type": "Transportation",
                "graph_type": "Weighted",
                "description": "Routes with distances/costs",
                "example": "GPS navigation, airline routes"
            },
            {
                "type": "Task Dependencies",
                "graph_type": "DAG",
                "description": "Tasks with prerequisites",
                "example": "Project management, course prerequisites"
            },
            {
                "type": "Computer Network",
                "graph_type": "Undirected",
                "description": "Bidirectional communication",
                "example": "Ethernet networks, peer-to-peer"
            },
            {
                "type": "File System",
                "graph_type": "Tree",
                "description": "Hierarchical organization",
                "example": "Directory structure, organizational chart"
            }
        ]
        
        for i, app in enumerate(applications, 1):
            print(f"{i}. {app['type']}")
            print(f"   Graph Type: {app['graph_type']}")
            print(f"   Description: {app['description']}")
            print(f"   Example: {app['example']}")
            print()

def test_graph_types():
    """Test different types of graphs"""
    
    print("Graph Types and Classifications Test:")
    print("=" * 60)
    
    graph_types = GraphTypes()
    
    # Test different graph types
    print("1. Simple Graph:")
    graph_types.create_simple_graph()
    print("\n" + "="*60)
    
    print("2. Complete Graph:")
    graph_types.create_complete_graph(4)
    print("\n" + "="*60)
    
    print("3. Bipartite Graph:")
    graph_types.create_bipartite_graph()
    print("\n" + "="*60)
    
    print("4. Tree Graph:")
    graph_types.create_tree_graph()
    print("\n" + "="*60)
    
    print("5. Cyclic Graph:")
    graph_types.create_cyclic_graph()
    print("\n" + "="*60)
    
    print("6. Directed Acyclic Graph:")
    graph_types.create_directed_acyclic_graph()
    print("\n" + "="*60)
    
    # Show applications
    graph_types.demonstrate_graph_applications()

test_graph_types()
```

---

### 46. **What is the difference between directed and undirected graphs?** *(Google, Amazon)*

**Core Difference:** The fundamental difference lies in whether edges have direction. In directed graphs, edges have a specific direction (one-way), while in undirected graphs, edges are bidirectional (two-way).

**Comprehensive Comparison:**

| **Aspect** | **Directed Graph** | **Undirected Graph** |
|------------|-------------------|---------------------|
| **Edge Direction** | One-way (A → B) | Two-way (A ↔ B) |
| **Edge Representation** | Ordered pair (u, v) | Unordered pair {u, v} |
| **Degree Types** | In-degree and Out-degree | Single degree |
| **Maximum Edges** | V × (V - 1) | V × (V - 1) / 2 |
| **Adjacency Matrix** | Not necessarily symmetric | Always symmetric |
| **Path Definition** | Must follow edge direction | Can traverse any edge |
| **Connectivity** | Strong/Weak connectivity | Simple connectivity |
| **Cycle Detection** | More complex (DFS with colors) | Simpler (DFS with parent) |

**Detailed Implementation Comparison:**
```python
class DirectedVsUndirectedComparison:
    """
    Comprehensive comparison between directed and undirected graphs
    """
    
    def __init__(self):
        pass
    
    def create_comparison_graphs(self):
        """Create identical structure as directed and undirected graphs"""
        
        print("Directed vs Undirected Graph Comparison:")
        print("=" * 60)
        
        # Same vertices and edges for both graphs
        vertices = ['A', 'B', 'C', 'D']
        edges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'A')]
        
        # Create directed graph
        directed = Graph(directed=True)
        for v in vertices:
            directed.add_vertex(v)
        for v1, v2 in edges:
            directed.add_edge(v1, v2)
        
        # Create undirected graph
        undirected = Graph(directed=False)
        for v in vertices:
            undirected.add_vertex(v)
        for v1, v2 in edges:
            undirected.add_edge(v1, v2)
        
        print("Directed Graph:")
        directed.visualize()
        
        print("\nUndirected Graph:")
        undirected.visualize()
        
        return directed, undirected
    
    def compare_adjacency_matrices(self, directed, undirected):
        """Compare adjacency matrix representations"""
        
        print("\nAdjacency Matrix Comparison:")
        print("=" * 40)
        
        vertices = sorted(list(directed.vertices))
        
        # Create adjacency matrices
        directed_matrix = self._create_adjacency_matrix(directed, vertices)
        undirected_matrix = self._create_adjacency_matrix(undirected, vertices)
        
        print("Directed Graph Adjacency Matrix:")
        self._print_matrix(directed_matrix, vertices)
        print(f"Matrix is symmetric: {self._is_symmetric(directed_matrix)}")
        
        print("\nUndirected Graph Adjacency Matrix:")
        self._print_matrix(undirected_matrix, vertices)
        print(f"Matrix is symmetric: {self._is_symmetric(undirected_matrix)}")
        
        # Count edges in matrices
        directed_edges = sum(sum(row) for row in directed_matrix)
        undirected_edges = sum(sum(row) for row in undirected_matrix) // 2  # Divide by 2 for undirected
        
        print(f"\nEdge count comparison:")
        print(f"Directed graph edges (from matrix): {directed_edges}")
        print(f"Undirected graph edges (from matrix): {undirected_edges}")
    
    def _create_adjacency_matrix(self, graph, vertices):
        """Create adjacency matrix for a graph"""
        n = len(vertices)
        matrix = [[0] * n for _ in range(n)]
        
        vertex_to_index = {v: i for i, v in enumerate(vertices)}
        
        for i, vertex in enumerate(vertices):
            neighbors = graph.get_neighbors(vertex)
            for neighbor in neighbors:
                j = vertex_to_index[neighbor]
                matrix[i][j] = 1
        
        return matrix
    
    def _print_matrix(self, matrix, vertices):
        """Print adjacency matrix with labels"""
        print("    " + "  ".join(f"{v:2}" for v in vertices))
        for i, row in enumerate(matrix):
            print(f"{vertices[i]:2}: " + "  ".join(f"{val:2}" for val in row))
    
    def _is_symmetric(self, matrix):
        """Check if matrix is symmetric"""
        n = len(matrix)
        for i in range(n):
            for j in range(n):
                if matrix[i][j] != matrix[j][i]:
                    return False
        return True
    
    def compare_degree_concepts(self, directed, undirected):
        """Compare degree concepts between directed and undirected graphs"""
        
        print("\nDegree Concepts Comparison:")
        print("=" * 40)
        
        vertices = sorted(list(directed.vertices))
        
        print("Vertex Degrees:")
        print("Vertex | Directed (In, Out) | Undirected (Total)")
        print("-" * 50)
        
        for vertex in vertices:
            dir_degree = directed.degree(vertex)
            undir_degree = undirected.degree(vertex)
            
            print(f"{vertex:6} | ({dir_degree[0]:2}, {dir_degree[1]:2})        | {undir_degree:2}")
        
        # Calculate total degrees
        total_directed_in = sum(directed.degree(v)[0] for v in vertices)
        total_directed_out = sum(directed.degree(v)[1] for v in vertices)
        total_undirected = sum(undirected.degree(v) for v in vertices)
        
        print(f"\nTotal Degree Sums:")
        print(f"Directed - In-degrees: {total_directed_in}")
        print(f"Directed - Out-degrees: {total_directed_out}")
        print(f"Undirected - Total degrees: {total_undirected}")
        print(f"Handshaking lemma verification:")
        print(f"  Directed: In-degree sum = Out-degree sum = {directed.edge_count}")
        print(f"  Undirected: Total degree sum = 2 × edges = {undirected.edge_count * 2}")
    
    def compare_path_reachability(self, directed, undirected):
        """Compare path and reachability concepts"""
        
        print("\nPath and Reachability Comparison:")
        print("=" * 40)
        
        def find_path_bfs(graph, start, end):
            """Find path using BFS"""
            if start == end:
                return [start]
            
            queue = [(start, [start])]
            visited = {start}
            
            while queue:
                vertex, path = queue.pop(0)
                neighbors = graph.get_neighbors(vertex)
                
                for neighbor in neighbors:
                    if neighbor == end:
                        return path + [neighbor]
                    
                    if neighbor not in visited:
                        visited.add(neighbor)
                        queue.append((neighbor, path + [neighbor]))
            
            return None  # No path found
        
        # Test reachability between all pairs
        vertices = sorted(list(directed.vertices))
        
        print("Reachability Matrix (1 = reachable, 0 = not reachable):")
        print("\nDirected Graph:")
        print("From\\To " + "  ".join(f"{v:2}" for v in vertices))
        
        for start in vertices:
            row = []
            for end in vertices:
                path = find_path_bfs(directed, start, end)
                row.append(1 if path else 0)
            print(f"{start:6}: " + "  ".join(f"{val:2}" for val in row))
        
        print("\nUndirected Graph:")
        print("From\\To " + "  ".join(f"{v:2}" for v in vertices))
        
        for start in vertices:
            row = []
            for end in vertices:
                path = find_path_bfs(undirected, start, end)
                row.append(1 if path else 0)
            print(f"{start:6}: " + "  ".join(f"{val:2}" for val in row))
        
        # Show specific path examples
        print(f"\nPath Examples:")
        test_pairs = [('A', 'C'), ('C', 'A'), ('B', 'D')]
        
        for start, end in test_pairs:
            dir_path = find_path_bfs(directed, start, end)
            undir_path = find_path_bfs(undirected, start, end)
            
            print(f"Path from {start} to {end}:")
            print(f"  Directed: {' -> '.join(dir_path) if dir_path else 'No path'}")
            print(f"  Undirected: {' -- '.join(undir_path) if undir_path else 'No path'}")
    
    def compare_connectivity_concepts(self, directed, undirected):
        """Compare connectivity concepts"""
        
        print("\nConnectivity Concepts Comparison:")
        print("=" * 40)
        
        # For directed graphs, we need to check strong connectivity
        dir_info = directed.get_graph_info()
        undir_info = undirected.get_graph_info()
        
        print("Connectivity Analysis:")
        print(f"Directed graph connectivity: {dir_info['is_connected']}")
        print(f"Undirected graph connectivity: {undir_info['is_connected']}")
        
        # Analyze weak connectivity for directed graph
        # (treat as undirected for weak connectivity)
        weak_connected = self._check_weak_connectivity(directed)
        print(f"Directed graph weak connectivity: {weak_connected}")
        
        print(f"\nConnectivity Types:")
        print(f"1. Undirected Graph:")
        print(f"   - Connected: All vertices reachable from any vertex")
        print(f"   - Result: {undir_info['is_connected']}")
        
        print(f"2. Directed Graph:")
        print(f"   - Strongly Connected: Every vertex reachable from every other vertex")
        print(f"   - Result: {dir_info['is_connected']}")
        print(f"   - Weakly Connected: Connected when treating edges as undirected")
        print(f"   - Result: {weak_connected}")
    
    def _check_weak_connectivity(self, directed_graph):
        """Check weak connectivity of directed graph"""
        # Create undirected version of directed graph
        temp_undirected = Graph(directed=False)
        
        # Add all vertices
        for vertex in directed_graph.vertices:
            temp_undirected.add_vertex(vertex)
        
        # Add all edges as undirected
        for vertex in directed_graph.vertices:
            neighbors = directed_graph.get_neighbors(vertex)
            for neighbor in neighbors:
                temp_undirected.add_edge(vertex, neighbor)
        
        return temp_undirected.is_connected()
    
    def compare_cycle_detection(self, directed, undirected):
        """Compare cycle detection methods"""
        
        print("\nCycle Detection Comparison:")
        print("=" * 40)
        
        dir_has_cycle = directed.has_cycle()
        undir_has_cycle = undirected.has_cycle()
        
        print(f"Cycle Detection Results:")
        print(f"Directed graph has cycle: {dir_has_cycle}")
        print(f"Undirected graph has cycle: {undir_has_cycle}")
        
        print(f"\nCycle Detection Methods:")
        print(f"1. Directed Graph:")
        print(f"   - Uses DFS with three colors (White, Gray, Black)")
        print(f"   - Gray vertices indicate back edge (cycle)")
        print(f"   - Must consider edge direction")
        
        print(f"2. Undirected Graph:")
        print(f"   - Uses DFS with visited tracking")
        print(f"   - Back edge to non-parent visited vertex indicates cycle")
        print(f"   - Simpler than directed version")
        
        # Demonstrate cycle types
        print(f"\nCycle Analysis:")
        if dir_has_cycle:
            print(f"   Directed cycle: A → B → C → D → A (directed cycle)")
        if undir_has_cycle:
            print(f"   Undirected cycle: A -- B -- C -- D -- A (undirected cycle)")

def test_directed_vs_undirected():
    """Comprehensive test of directed vs undirected graphs"""
    
    comparison = DirectedVsUndirectedComparison()
    
    # Create comparison graphs
    directed, undirected = comparison.create_comparison_graphs()
    
    # Run all comparisons
    comparison.compare_adjacency_matrices(directed, undirected)
    comparison.compare_degree_concepts(directed, undirected)
    comparison.compare_path_reachability(directed, undirected)
    comparison.compare_connectivity_concepts(directed, undirected)
    comparison.compare_cycle_detection(directed, undirected)
    
    # Summary of key differences
    print("\nKey Differences Summary:")
    print("=" * 40)
    
    differences = [
        ("Edge Interpretation", "One-way relationship", "Two-way relationship"),
        ("Matrix Symmetry", "Not necessarily symmetric", "Always symmetric"),
        ("Degree Types", "In-degree + Out-degree", "Single degree"),
        ("Reachability", "Direction matters", "Bidirectional paths"),
        ("Connectivity", "Strong vs Weak", "Simple connected"),
        ("Applications", "Web links, dependencies", "Friendships, networks"),
        ("Complexity", "Generally more complex", "Generally simpler")
    ]
    
    print("Aspect              | Directed Graph        | Undirected Graph")
    print("-" * 70)
    for aspect, directed_desc, undirected_desc in differences:
        print(f"{aspect:<18} | {directed_desc:<20} | {undirected_desc}")

# Run comprehensive comparison
test_directed_vs_undirected()
```

**Real-World Applications Comparison:**

| **Application Domain** | **Directed Graph Example** | **Undirected Graph Example** |
|------------------------|----------------------------|-------------------------------|
| **Social Networks** | Twitter follows (A follows B ≠ B follows A) | Facebook friends (mutual) |
| **Transportation** | One-way streets, flight routes | Highway connections, train tracks |
| **Web/Internet** | Hyperlinks between pages | Network cable connections |
| **Dependencies** | Software dependencies, task prerequisites | Collaboration networks |
| **Biological** | Food chain, evolutionary relationships | Protein interactions, gene networks |
| **Communication** | Email sending, command hierarchy | Phone calls, peer networks |

**Algorithm Complexity Differences:**

| **Algorithm** | **Directed Graph** | **Undirected Graph** |
|---------------|-------------------|---------------------|
| **DFS/BFS** | O(V + E) | O(V + E) |
| **Connectivity** | O(V + E) for strong connectivity | O(V + E) for connectivity |
| **Cycle Detection** | O(V + E) with colors | O(V + E) with parent tracking |
| **Shortest Path** | Dijkstra: O((V + E) log V) | Same, but bidirectional |
| **Topological Sort** | O(V + E) (only for DAGs) | Not applicable |
| **Strongly Connected Components** | O(V + E) | Not applicable (use connected components) |

Understanding the differences between directed and undirected graphs is crucial for choosing the right model for your problem domain and applying appropriate algorithms! 🕸️

---

*These comprehensive answers cover graph data structure fundamentals and the key differences between directed and undirected graphs with detailed implementations, comparisons, and real-world applications. Perfect for technical interviews at top companies! 🚀*
