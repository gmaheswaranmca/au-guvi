# DSA Questions 49-50 - Answers (Divide and Conquer Algorithms - Final)

## 49. How does quick sort use divide and conquer? (Amazon, Microsoft)

**Answer:** Quick sort is an excellent example of divide and conquer that differs from merge sort by doing most of the work in the divide step (partitioning) rather than the combine step. It achieves average O(n log n) performance through intelligent pivot selection and in-place partitioning.

**Quick Sort Divide and Conquer Breakdown:**

**1. DIVIDE Step - Partition Around Pivot:**
```python
def quick_sort_divide_analysis(arr, low=0, high=None):
    """
    Detailed analysis of quick sort's divide step (partitioning).
    """
    if high is None:
        high = len(arr) - 1
    
    print(f"DIVIDE: Partitioning array {arr[low:high+1]} (indices {low} to {high})")
    
    if low >= high:
        print("Base case: Subarray has ≤ 1 element")
        return low
    
    # Choose pivot (various strategies possible)
    pivot_index = choose_pivot_strategy(arr, low, high)
    pivot_value = arr[pivot_index]
    print(f"Chosen pivot: {pivot_value} at index {pivot_index}")
    
    # Move pivot to end for partitioning
    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]
    print(f"Moved pivot to end: {arr[low:high+1]}")
    
    # Partition around pivot
    final_pivot_pos = partition_detailed(arr, low, high)
    print(f"Pivot {pivot_value} final position: {final_pivot_pos}")
    print(f"After partitioning: {arr[low:high+1]}")
    print(f"Left partition: {arr[low:final_pivot_pos]} (≤ {pivot_value})")
    print(f"Right partition: {arr[final_pivot_pos+1:high+1]} (> {pivot_value})")
    
    return final_pivot_pos

def choose_pivot_strategy(arr, low, high):
    """
    Demonstrate different pivot selection strategies.
    """
    strategies = {
        'last_element': high,
        'first_element': low,
        'middle_element': (low + high) // 2,
        'random_element': low + (high - low) // 2,  # Simplified random
        'median_of_three': median_of_three_pivot(arr, low, high)
    }
    
    strategy = 'median_of_three'  # Best strategy for demo
    print(f"Using pivot strategy: {strategy}")
    return strategies[strategy]

def median_of_three_pivot(arr, low, high):
    """
    Select median of first, middle, and last elements as pivot.
    """
    mid = (low + high) // 2
    candidates = [(arr[low], low), (arr[mid], mid), (arr[high], high)]
    candidates.sort()
    median_index = candidates[1][1]  # Index of median value
    
    print(f"Median of three: arr[{low}]={arr[low]}, arr[{mid}]={arr[mid]}, arr[{high}]={arr[high]}")
    print(f"Median value: {arr[median_index]} at index {median_index}")
    
    return median_index

def partition_detailed(arr, low, high):
    """
    Detailed partitioning with step-by-step explanation.
    """
    pivot = arr[high]
    print(f"\nPartitioning with pivot: {pivot}")
    
    i = low - 1  # Index of smaller element
    
    print(f"Initial state: i={i}, scanning from {low} to {high-1}")
    
    for j in range(low, high):
        print(f"  Comparing arr[{j}]={arr[j]} with pivot {pivot}")
        
        if arr[j] <= pivot:
            i += 1
            if i != j:
                arr[i], arr[j] = arr[j], arr[i]
                print(f"    {arr[j]} ≤ {pivot}: Swap arr[{i}] and arr[{j}] → {arr[low:high+1]}")
            else:
                print(f"    {arr[j]} ≤ {pivot}: No swap needed")
        else:
            print(f"    {arr[j]} > {pivot}: No action")
    
    # Place pivot in correct position
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    print(f"Place pivot: Swap arr[{i+1}] and arr[{high}] → {arr[low:high+1]}")
    
    return i + 1

# Example partitioning
arr = [64, 34, 25, 12, 22, 11, 90, 88, 76]
print("Quick Sort Divide Step Example:")
pivot_pos = quick_sort_divide_analysis(arr.copy())
```

**2. CONQUER Step - Recursively Sort Partitions:**
```python
def quick_sort_with_detailed_trace(arr, low=0, high=None, depth=0):
    """
    Quick sort with detailed recursion trace showing conquer step.
    """
    if high is None:
        high = len(arr) - 1
    
    indent = "  " * depth
    print(f"{indent}CONQUER: quick_sort({arr[low:high+1]}, low={low}, high={high})")
    
    # Base case
    if low >= high:
        print(f"{indent}Base case: Subarray has ≤ 1 element")
        return
    
    # Divide: Partition around pivot
    print(f"{indent}DIVIDE: Partitioning subarray...")
    pivot_index = lomuto_partition_simple(arr, low, high)
    pivot_value = arr[pivot_index]
    print(f"{indent}Pivot {pivot_value} placed at index {pivot_index}")
    print(f"{indent}Array after partition: {arr[low:high+1]}")
    
    # Conquer: Recursively sort left partition
    if pivot_index - 1 >= low:
        print(f"{indent}CONQUER LEFT: Sort left partition [{low}:{pivot_index-1}]")
        quick_sort_with_detailed_trace(arr, low, pivot_index - 1, depth + 1)
        print(f"{indent}Left partition sorted: {arr[low:pivot_index]}")
    
    # Conquer: Recursively sort right partition
    if pivot_index + 1 <= high:
        print(f"{indent}CONQUER RIGHT: Sort right partition [{pivot_index+1}:{high}]")
        quick_sort_with_detailed_trace(arr, pivot_index + 1, high, depth + 1)
        print(f"{indent}Right partition sorted: {arr[pivot_index+1:high+1]}")
    
    # Combine: No explicit combining needed (in-place sorting)
    print(f"{indent}COMBINE: Subarray {arr[low:high+1]} is now sorted")

def lomuto_partition_simple(arr, low, high):
    """
    Simple Lomuto partition scheme.
    """
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# Complete example
print("\nComplete Quick Sort Trace:")
arr = [38, 27, 43, 3, 9, 82, 10]
print(f"Original array: {arr}")
quick_sort_with_detailed_trace(arr)
print(f"Final sorted array: {arr}")
```

**3. COMBINE Step - In-Place, No Explicit Combining:**
```python
def quick_sort_combine_analysis():
    """
    Analysis of quick sort's combine step (which is minimal).
    """
    print("QUICK SORT COMBINE STEP ANALYSIS:")
    print("- Operation: No explicit combining needed")
    print("- Reason: Partitioning is done in-place")
    print("- Time complexity: O(1)")
    print("- Space complexity: O(1)")
    print("- Key insight: Work is done in DIVIDE step, not COMBINE")
    
    print("\nComparison with Merge Sort:")
    print("Merge Sort:")
    print("  - Divide: O(1) - simple split")
    print("  - Combine: O(n) - merge sorted subarrays")
    print("Quick Sort:")
    print("  - Divide: O(n) - partition around pivot")
    print("  - Combine: O(1) - no work needed")
    
    print("\nWhy no combining is needed:")
    print("1. Partitioning ensures all elements in left ≤ pivot")
    print("2. All elements in right > pivot")
    print("3. After sorting left and right recursively,")
    print("   entire subarray is automatically sorted")
    print("4. No additional merging step required")

quick_sort_combine_analysis()
```

**Complete Quick Sort Implementation with Step Tracking:**
```python
class QuickSortTracker:
    """
    Quick sort implementation with comprehensive step tracking.
    """
    
    def __init__(self):
        self.divide_count = 0
        self.conquer_count = 0
        self.combine_count = 0
        self.comparisons = 0
        self.swaps = 0
        self.partition_count = 0
    
    def quick_sort(self, arr):
        """Main quick sort function with tracking."""
        self.reset_counters()
        self._quick_sort_helper(arr, 0, len(arr) - 1, 0)
        self.print_statistics(len(arr))
        return arr
    
    def _quick_sort_helper(self, arr, low, high, level):
        """Helper function for recursive quick sort."""
        if low >= high:
            return
        
        # DIVIDE step - partition
        self.divide_count += 1
        self.partition_count += 1
        print(f"{'  ' * level}DIVIDE #{self.divide_count}: Partition {arr[low:high+1]}")
        
        pivot_index = self._partition_with_tracking(arr, low, high, level)
        print(f"{'  ' * level}Pivot {arr[pivot_index]} at position {pivot_index}")
        
        # CONQUER step - recursive calls
        self.conquer_count += 1
        
        # Sort left partition
        if pivot_index - 1 >= low:
            print(f"{'  ' * level}CONQUER LEFT: Sort [{low}:{pivot_index-1}]")
            self._quick_sort_helper(arr, low, pivot_index - 1, level + 1)
        
        # Sort right partition
        if pivot_index + 1 <= high:
            print(f"{'  ' * level}CONQUER RIGHT: Sort [{pivot_index+1}:{high}]")
            self._quick_sort_helper(arr, pivot_index + 1, high, level + 1)
        
        # COMBINE step (no work needed)
        self.combine_count += 1
        print(f"{'  ' * level}COMBINE #{self.combine_count}: No work needed (in-place)")
    
    def _partition_with_tracking(self, arr, low, high, level):
        """Partition function with detailed tracking."""
        pivot = arr[high]
        i = low - 1
        
        for j in range(low, high):
            self.comparisons += 1
            if arr[j] <= pivot:
                i += 1
                if i != j:
                    arr[i], arr[j] = arr[j], arr[i]
                    self.swaps += 1
        
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        self.swaps += 1
        
        return i + 1
    
    def reset_counters(self):
        """Reset all tracking counters."""
        self.divide_count = 0
        self.conquer_count = 0
        self.combine_count = 0
        self.comparisons = 0
        self.swaps = 0
        self.partition_count = 0
    
    def print_statistics(self, n):
        """Print algorithm statistics."""
        print(f"\nQUICK SORT STATISTICS for n={n}:")
        print(f"Divide operations (partitions): {self.divide_count}")
        print(f"Conquer operations: {self.conquer_count}")
        print(f"Combine operations: {self.combine_count}")
        print(f"Total comparisons: {self.comparisons}")
        print(f"Total swaps: {self.swaps}")
        print(f"Average comparisons per partition: {self.comparisons / max(1, self.partition_count):.1f}")

# Example usage
tracker = QuickSortTracker()
arr = [64, 34, 25, 12, 22, 11, 90]
print(f"Original array: {arr}")
sorted_arr = tracker.quick_sort(arr)
print(f"Sorted array: {sorted_arr}")
```

**Different Partitioning Schemes:**

**1. Lomuto Partition Scheme:**
```python
def lomuto_partition_detailed(arr, low, high):
    """
    Lomuto partition scheme with detailed explanation.
    """
    print(f"LOMUTO PARTITION: {arr[low:high+1]}")
    
    pivot = arr[high]  # Always choose last element as pivot
    print(f"Pivot: {pivot} (last element)")
    
    i = low - 1  # Index of smaller element
    
    print("Scanning from left to right:")
    for j in range(low, high):
        print(f"  j={j}, arr[j]={arr[j]}, comparing with pivot {pivot}")
        
        if arr[j] <= pivot:
            i += 1
            if i != j:
                arr[i], arr[j] = arr[j], arr[i]
                print(f"    Swap: arr[{i}] ↔ arr[{j}] → {arr[low:high+1]}")
            else:
                print(f"    No swap needed")
    
    # Place pivot in correct position
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    print(f"Place pivot at position {i+1}: {arr[low:high+1]}")
    
    return i + 1

# Example
arr = [10, 80, 30, 90, 40, 50, 70]
print("Lomuto Partition Example:")
pivot_pos = lomuto_partition_detailed(arr)
print(f"Pivot final position: {pivot_pos}")
```

**2. Hoare Partition Scheme:**
```python
def hoare_partition_detailed(arr, low, high):
    """
    Hoare partition scheme with detailed explanation.
    """
    print(f"HOARE PARTITION: {arr[low:high+1]}")
    
    pivot = arr[low]  # Choose first element as pivot
    print(f"Pivot: {pivot} (first element)")
    
    i = low - 1
    j = high + 1
    
    print("Two-pointer approach:")
    while True:
        # Move left pointer right
        i += 1
        while i <= high and arr[i] < pivot:
            print(f"  Left pointer i={i}, arr[i]={arr[i]} < {pivot}, move right")
            i += 1
        
        # Move right pointer left
        j -= 1
        while j >= low and arr[j] > pivot:
            print(f"  Right pointer j={j}, arr[j]={arr[j]} > {pivot}, move left")
            j -= 1
        
        print(f"  Stopped at: i={i}, j={j}")
        
        if i >= j:
            print(f"  Pointers crossed, partition complete")
            break
        
        # Swap elements at i and j
        arr[i], arr[j] = arr[j], arr[i]
        print(f"  Swap: arr[{i}] ↔ arr[{j}] → {arr[low:high+1]}")
    
    return j

# Example
arr = [10, 80, 30, 90, 40, 50, 70]
print("Hoare Partition Example:")
partition_point = hoare_partition_detailed(arr.copy())
print(f"Partition point: {partition_point}")
```

**Complexity Analysis of Each Step:**

**1. Divide Step Complexity (Partitioning):**
```python
def analyze_quick_sort_divide_complexity():
    """
    Analyze the complexity of quick sort's divide step.
    """
    print("QUICK SORT DIVIDE STEP COMPLEXITY:")
    print("- Operation: Partition array around pivot")
    print("- Time: O(n) per partition")
    print("- Space: O(1) - in-place partitioning")
    print("- Work: Compare each element with pivot")
    print("- Comparisons: n-1 per partition")
    
    print("\nPartition complexity breakdown:")
    print("- Scan through entire subarray: O(n)")
    print("- Compare each element with pivot: n-1 comparisons")
    print("- Swap elements as needed: O(1) per swap")
    print("- Total swaps: varies (best: 0, worst: n/2)")
    
    def analyze_partition_work(n):
        print(f"\nFor array size {n}:")
        print(f"  Comparisons: {n-1}")
        print(f"  Best case swaps: 0 (already partitioned)")
        print(f"  Average case swaps: {n//4}")
        print(f"  Worst case swaps: {n//2}")
    
    for size in [8, 16, 32]:
        analyze_partition_work(size)

analyze_quick_sort_divide_complexity()
```

**2. Conquer Step Analysis:**
```python
def analyze_quick_sort_conquer_complexity():
    """
    Analyze the complexity of quick sort's conquer step.
    """
    print("\nQUICK SORT CONQUER STEP COMPLEXITY:")
    print("- Operation: Recursively sort partitions")
    print("- Depends on partition quality")
    print("- Best case: Balanced partitions")
    print("- Worst case: Unbalanced partitions")
    
    print("\nRecursion depth analysis:")
    print("Best case (balanced partitions):")
    print("  - Each partition roughly n/2")
    print("  - Recursion depth: O(log n)")
    print("  - Each level: O(n) work")
    print("  - Total: O(n log n)")
    
    print("\nWorst case (unbalanced partitions):")
    print("  - One partition has n-1 elements")
    print("  - Other partition has 0 elements")
    print("  - Recursion depth: O(n)")
    print("  - Total: O(n²)")
    
    def calculate_recursion_depth(n, case):
        if case == "best":
            return n.bit_length() - 1  # log₂(n)
        elif case == "worst":
            return n - 1
        else:  # average
            return int(1.39 * (n.bit_length() - 1))  # 1.39 * log₂(n)
    
    print("\nRecursion depth for different cases:")
    for size in [8, 16, 32, 64]:
        best = calculate_recursion_depth(size, "best")
        avg = calculate_recursion_depth(size, "average")
        worst = calculate_recursion_depth(size, "worst")
        print(f"n={size}: Best={best}, Average={avg}, Worst={worst}")

analyze_quick_sort_conquer_complexity()
```

**3. Combine Step Analysis:**
```python
def analyze_quick_sort_combine_complexity():
    """
    Analyze the (minimal) combine step in quick sort.
    """
    print("\nQUICK SORT COMBINE STEP COMPLEXITY:")
    print("- Operation: No explicit combining")
    print("- Time: O(1)")
    print("- Space: O(1)")
    print("- Reason: In-place partitioning")
    
    print("\nWhy combine step is trivial:")
    print("1. Partitioning creates the ordering:")
    print("   [elements ≤ pivot] [pivot] [elements > pivot]")
    print("2. After recursively sorting left and right:")
    print("   [sorted ≤ pivot] [pivot] [sorted > pivot]")
    print("3. Entire subarray is automatically sorted")
    print("4. No additional work needed")
    
    print("\nContrast with merge sort:")
    print("Merge Sort: Easy divide, complex combine")
    print("Quick Sort: Complex divide, trivial combine")

analyze_quick_sort_combine_complexity()
```

**Quick Sort Recursion Tree Visualization:**
```python
def visualize_quick_sort_tree(arr, low=0, high=None, level=0):
    """
    Visualize quick sort recursion tree.
    """
    if high is None:
        high = len(arr) - 1
    
    indent = "  " * level
    
    if low >= high:
        if low == high:
            print(f"{indent}[{arr[low]}] (single element)")
        else:
            print(f"{indent}[] (empty)")
        return
    
    print(f"{indent}{arr[low:high+1]} (indices {low}-{high})")
    
    # Partition for visualization (don't modify original)
    arr_copy = arr[:]
    pivot_index = lomuto_partition_simple(arr_copy, low, high)
    pivot_value = arr_copy[pivot_index]
    
    print(f"{indent}Pivot: {pivot_value} at position {pivot_index}")
    
    # Recursively visualize left and right partitions
    if pivot_index - 1 >= low:
        print(f"{indent}├─ Left: ", end="")
        visualize_quick_sort_tree(arr_copy, low, pivot_index - 1, level + 1)
    
    if pivot_index + 1 <= high:
        print(f"{indent}└─ Right: ", end="")
        visualize_quick_sort_tree(arr_copy, pivot_index + 1, high, level + 1)

print("Quick Sort Recursion Tree:")
arr = [38, 27, 43, 3, 9, 82]
visualize_quick_sort_tree(arr)
```

**Pivot Selection Strategies:**
```python
def compare_pivot_strategies():
    """
    Compare different pivot selection strategies.
    """
    strategies = {
        'First Element': {
            'implementation': 'pivot = arr[low]',
            'best_case': 'Random data',
            'worst_case': 'Sorted/reverse sorted data',
            'complexity': 'O(n log n) avg, O(n²) worst'
        },
        'Last Element': {
            'implementation': 'pivot = arr[high]',
            'best_case': 'Random data',
            'worst_case': 'Sorted/reverse sorted data',
            'complexity': 'O(n log n) avg, O(n²) worst'
        },
        'Random Element': {
            'implementation': 'pivot = arr[random(low, high)]',
            'best_case': 'Any data pattern',
            'worst_case': 'Very unlikely',
            'complexity': 'O(n log n) expected'
        },
        'Median of Three': {
            'implementation': 'median(arr[low], arr[mid], arr[high])',
            'best_case': 'Most data patterns',
            'worst_case': 'Specific adversarial inputs',
            'complexity': 'O(n log n) avg, improved worst case'
        },
        'True Median': {
            'implementation': 'Find actual median',
            'best_case': 'Always balanced partitions',
            'worst_case': 'None (always optimal)',
            'complexity': 'O(n log n) guaranteed'
        }
    }
    
    print("PIVOT SELECTION STRATEGIES:")
    print("-" * 80)
    
    for strategy, details in strategies.items():
        print(f"\n{strategy}:")
        for aspect, description in details.items():
            print(f"  {aspect.replace('_', ' ').title()}: {description}")

compare_pivot_strategies()
```

**Quick Sort vs Merge Sort Comparison:**
```python
def compare_quick_sort_merge_sort():
    """
    Detailed comparison of quick sort and merge sort divide-and-conquer approaches.
    """
    comparison = {
        'Aspect': ['Divide Strategy', 'Divide Complexity', 'Conquer Strategy', 
                  'Combine Strategy', 'Combine Complexity', 'Space Complexity',
                  'Stability', 'Best Case', 'Average Case', 'Worst Case'],
        'Quick Sort': [
            'Partition around pivot',
            'O(n) - significant work',
            'Recursively sort partitions',
            'No explicit combining',
            'O(1) - trivial',
            'O(log n) - call stack',
            'Not stable',
            'O(n log n)',
            'O(n log n)',
            'O(n²)'
        ],
        'Merge Sort': [
            'Split at middle',
            'O(1) - trivial',
            'Recursively sort halves',
            'Merge sorted halves',
            'O(n) - significant work',
            'O(n) - temporary arrays',
            'Stable',
            'O(n log n)',
            'O(n log n)',
            'O(n log n)'
        ]
    }
    
    print("QUICK SORT VS MERGE SORT COMPARISON:")
    print("-" * 70)
    print(f"{'Aspect':<20} {'Quick Sort':<25} {'Merge Sort':<25}")
    print("-" * 70)
    
    for i, aspect in enumerate(comparison['Aspect']):
        quick = comparison['Quick Sort'][i]
        merge = comparison['Merge Sort'][i]
        print(f"{aspect:<20} {quick:<25} {merge:<25}")

compare_quick_sort_merge_sort()
```

**Quick Sort Advantages and Best Practices:**
1. **In-place sorting**: Minimal memory usage
2. **Cache efficiency**: Good locality of reference
3. **Practical performance**: Often faster than merge sort in practice
4. **Tail recursion**: Can be optimized to reduce stack usage
5. **Hybrid approaches**: Switch to insertion sort for small subarrays

---

## 50. What is binary search as a divide and conquer algorithm? (Zoho, Facebook)

**Answer:** Binary search is a classic divide and conquer algorithm that efficiently searches for a target value in a sorted array by repeatedly dividing the search space in half. It demonstrates the power of divide and conquer in achieving O(log n) time complexity.

**Binary Search Divide and Conquer Breakdown:**

**1. DIVIDE Step - Split Search Space:**
```python
def binary_search_divide_analysis(arr, target, left=0, right=None):
    """
    Detailed analysis of binary search's divide step.
    """
    if right is None:
        right = len(arr) - 1
    
    print(f"DIVIDE: Search space {arr[left:right+1]} (indices {left} to {right})")
    print(f"Target: {target}, Search space size: {right - left + 1}")
    
    # Base case check
    if left > right:
        print("Base case: Search space is empty")
        return -1
    
    # Divide: Find middle point
    mid = left + (right - left) // 2  # Avoid overflow
    mid_value = arr[mid]
    
    print(f"Middle index: {mid}, Middle value: {mid_value}")
    print(f"Comparison: {target} vs {mid_value}")
    
    if target == mid_value:
        print(f"Target found at index {mid}!")
        return mid
    elif target < mid_value:
        print(f"{target} < {mid_value}: Search left half")
        new_right = mid - 1
        print(f"New search space: indices {left} to {new_right}")
        return 'search_left', left, new_right
    else:
        print(f"{target} > {mid_value}: Search right half")
        new_left = mid + 1
        print(f"New search space: indices {new_left} to {right}")
        return 'search_right', new_left, right

# Example divide step
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target = 7
print("Binary Search Divide Step Example:")
result = binary_search_divide_analysis(arr, target)
```

**2. CONQUER Step - Recursively Search Subspace:**
```python
def binary_search_with_detailed_trace(arr, target, left=0, right=None, depth=0):
    """
    Binary search with detailed recursion trace showing conquer step.
    """
    if right is None:
        right = len(arr) - 1
    
    indent = "  " * depth
    print(f"{indent}CONQUER: binary_search({target} in {arr[left:right+1]})")
    print(f"{indent}Search space: indices [{left}, {right}], size: {right - left + 1}")
    
    # Base case
    if left > right:
        print(f"{indent}Base case: Empty search space, target not found")
        return -1
    
    # Divide: Calculate middle point
    mid = left + (right - left) // 2
    mid_value = arr[mid]
    
    print(f"{indent}DIVIDE: mid = {mid}, arr[{mid}] = {mid_value}")
    print(f"{indent}Compare: {target} vs {mid_value}")
    
    if target == mid_value:
        print(f"{indent}Target found at index {mid}!")
        return mid
    elif target < mid_value:
        print(f"{indent}CONQUER LEFT: {target} < {mid_value}, search left half")
        result = binary_search_with_detailed_trace(arr, target, left, mid - 1, depth + 1)
    else:
        print(f"{indent}CONQUER RIGHT: {target} > {mid_value}, search right half")
        result = binary_search_with_detailed_trace(arr, target, mid + 1, right, depth + 1)
    
    print(f"{indent}Returning result: {result}")
    return result

# Complete example
print("\nComplete Binary Search Trace:")
arr = [2, 5, 8, 12, 16, 23, 38, 45, 56, 67, 78]
target = 23
print(f"Array: {arr}")
print(f"Target: {target}")
result = binary_search_with_detailed_trace(arr, target)
print(f"Final result: {result}")
```

**3. COMBINE Step - No Combining Needed:**
```python
def binary_search_combine_analysis():
    """
    Analysis of binary search's combine step (which is minimal).
    """
    print("BINARY SEARCH COMBINE STEP ANALYSIS:")
    print("- Operation: No explicit combining needed")
    print("- Time complexity: O(1)")
    print("- Space complexity: O(1)")
    print("- Reason: Result from subproblem is the final answer")
    
    print("\nWhy no combining is needed:")
    print("1. Each recursive call searches for the same target")
    print("2. Only one subproblem is created per recursive call")
    print("3. When target is found, return index immediately")
    print("4. When target is not found, return -1 immediately")
    print("5. No processing of subresults required")
    
    print("\nContrast with other divide-and-conquer algorithms:")
    print("Merge Sort: Must combine sorted subarrays")
    print("Quick Sort: No combining (in-place partitioning)")
    print("Binary Search: No combining (single path to answer)")
    print("Maximum Subarray: Must compare left, right, and crossing sums")

binary_search_combine_analysis()
```

**Complete Binary Search Implementation with Step Tracking:**
```python
class BinarySearchTracker:
    """
    Binary search implementation with comprehensive step tracking.
    """
    
    def __init__(self):
        self.divide_count = 0
        self.conquer_count = 0
        self.combine_count = 0
        self.comparisons = 0
        self.space_reductions = []
    
    def binary_search(self, arr, target):
        """Main binary search function with tracking."""
        self.reset_counters()
        result = self._binary_search_helper(arr, target, 0, len(arr) - 1, 0)
        self.print_statistics(len(arr))
        return result
    
    def _binary_search_helper(self, arr, target, left, right, level):
        """Helper function for recursive binary search."""
        current_size = right - left + 1
        self.space_reductions.append(current_size)
        
        print(f"{'  ' * level}Search space: {arr[left:right+1]} (size: {current_size})")
        
        # Base case
        if left > right:
            print(f"{'  ' * level}Base case: Target not found")
            return -1
        
        # DIVIDE step
        self.divide_count += 1
        mid = left + (right - left) // 2
        mid_value = arr[mid]
        
        print(f"{'  ' * level}DIVIDE #{self.divide_count}: mid = {mid}, value = {mid_value}")
        
        # CONQUER step
        self.conquer_count += 1
        self.comparisons += 1
        
        if target == mid_value:
            print(f"{'  ' * level}CONQUER: Target found at index {mid}")
            return mid
        elif target < mid_value:
            print(f"{'  ' * level}CONQUER: Search left half")
            result = self._binary_search_helper(arr, target, left, mid - 1, level + 1)
        else:
            print(f"{'  ' * level}CONQUER: Search right half")
            result = self._binary_search_helper(arr, target, mid + 1, right, level + 1)
        
        # COMBINE step (trivial)
        self.combine_count += 1
        print(f"{'  ' * level}COMBINE #{self.combine_count}: Return result {result}")
        
        return result
    
    def reset_counters(self):
        """Reset all tracking counters."""
        self.divide_count = 0
        self.conquer_count = 0
        self.combine_count = 0
        self.comparisons = 0
        self.space_reductions = []
    
    def print_statistics(self, n):
        """Print algorithm statistics."""
        print(f"\nBINARY SEARCH STATISTICS for n={n}:")
        print(f"Divide operations: {self.divide_count}")
        print(f"Conquer operations: {self.conquer_count}")
        print(f"Combine operations: {self.combine_count}")
        print(f"Total comparisons: {self.comparisons}")
        print(f"Theoretical max comparisons: {n.bit_length()}")
        print(f"Search space reductions: {self.space_reductions}")
        print(f"Space reduction pattern: {' → '.join(map(str, self.space_reductions))}")

# Example usage
tracker = BinarySearchTracker()
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]
target = 15
print(f"Array: {arr}")
print(f"Target: {target}")
result = tracker.binary_search(arr, target)
print(f"Result: Index {result}")
```

**Different Binary Search Variants:**

**1. Iterative Binary Search:**
```python
def iterative_binary_search_detailed(arr, target):
    """
    Iterative binary search with step-by-step explanation.
    """
    print(f"ITERATIVE BINARY SEARCH")
    print(f"Array: {arr}")
    print(f"Target: {target}")
    
    left, right = 0, len(arr) - 1
    step = 0
    
    while left <= right:
        step += 1
        current_size = right - left + 1
        
        print(f"\nStep {step}:")
        print(f"  Search space: {arr[left:right+1]} (indices {left}-{right})")
        print(f"  Size: {current_size}")
        
        mid = left + (right - left) // 2
        mid_value = arr[mid]
        
        print(f"  Mid index: {mid}, Mid value: {mid_value}")
        print(f"  Compare: {target} vs {mid_value}")
        
        if target == mid_value:
            print(f"  Target found at index {mid}!")
            return mid
        elif target < mid_value:
            print(f"  {target} < {mid_value}: Search left half")
            right = mid - 1
        else:
            print(f"  {target} > {mid_value}: Search right half")
            left = mid + 1
    
    print(f"\nTarget not found after {step} steps")
    return -1

# Example
arr = [1, 4, 7, 10, 13, 16, 19, 22, 25, 28]
target = 16
result = iterative_binary_search_detailed(arr, target)
```

**2. Binary Search for Insertion Point:**
```python
def binary_search_insertion_point(arr, target):
    """
    Binary search to find insertion point for target.
    """
    print(f"BINARY SEARCH FOR INSERTION POINT")
    print(f"Array: {arr}")
    print(f"Target: {target}")
    
    left, right = 0, len(arr)
    step = 0
    
    while left < right:
        step += 1
        mid = left + (right - left) // 2
        mid_value = arr[mid]
        
        print(f"\nStep {step}:")
        print(f"  Search space indices: [{left}, {right})")
        print(f"  Mid index: {mid}, Mid value: {mid_value}")
        
        if target <= mid_value:
            print(f"  {target} ≤ {mid_value}: Search left half")
            right = mid
        else:
            print(f"  {target} > {mid_value}: Search right half")
            left = mid + 1
    
    print(f"\nInsertion point: index {left}")
    print(f"Array after insertion: {arr[:left] + [target] + arr[left:]}")
    return left

# Example
arr = [1, 3, 5, 7, 9, 11, 13, 15]
target = 8
insertion_point = binary_search_insertion_point(arr, target)
```

**3. Binary Search in Rotated Array:**
```python
def binary_search_rotated_array(arr, target):
    """
    Binary search in rotated sorted array.
    """
    print(f"BINARY SEARCH IN ROTATED ARRAY")
    print(f"Rotated array: {arr}")
    print(f"Target: {target}")
    
    left, right = 0, len(arr) - 1
    step = 0
    
    while left <= right:
        step += 1
        mid = left + (right - left) // 2
        mid_value = arr[mid]
        
        print(f"\nStep {step}:")
        print(f"  Search space: {arr[left:right+1]} (indices {left}-{right})")
        print(f"  Mid index: {mid}, Mid value: {mid_value}")
        
        if target == mid_value:
            print(f"  Target found at index {mid}!")
            return mid
        
        # Determine which half is sorted
        if arr[left] <= mid_value:  # Left half is sorted
            print(f"  Left half [{left}-{mid}] is sorted")
            if arr[left] <= target < mid_value:
                print(f"  Target {target} is in sorted left half")
                right = mid - 1
            else:
                print(f"  Target {target} is in right half")
                left = mid + 1
        else:  # Right half is sorted
            print(f"  Right half [{mid}-{right}] is sorted")
            if mid_value < target <= arr[right]:
                print(f"  Target {target} is in sorted right half")
                left = mid + 1
            else:
                print(f"  Target {target} is in left half")
                right = mid - 1
    
    print(f"\nTarget not found after {step} steps")
    return -1

# Example
arr = [4, 5, 6, 7, 0, 1, 2]  # Rotated sorted array
target = 0
result = binary_search_rotated_array(arr, target)
```

**Complexity Analysis:**

**1. Time Complexity Analysis:**
```python
def analyze_binary_search_time_complexity():
    """
    Detailed analysis of binary search time complexity.
    """
    print("BINARY SEARCH TIME COMPLEXITY ANALYSIS:")
    
    print("\n1. Divide Step:")
    print("   - Calculate mid index: O(1)")
    print("   - Access arr[mid]: O(1)")
    print("   - Compare target with arr[mid]: O(1)")
    print("   - Total per step: O(1)")
    
    print("\n2. Conquer Step:")
    print("   - Only one recursive call made")
    print("   - Search space halved each time")
    print("   - Maximum recursive calls: log₂(n)")
    
    print("\n3. Combine Step:")
    print("   - No combining work: O(1)")
    
    print("\n4. Overall Complexity:")
    print("   - Steps: log₂(n)")
    print("   - Work per step: O(1)")
    print("   - Total: O(log n)")
    
    def demonstrate_complexity(n):
        import math
        max_steps = math.ceil(math.log2(n))
        print(f"\nFor array size {n}:")
        print(f"  Maximum steps needed: {max_steps}")
        print(f"  Theoretical log₂({n}) = {math.log2(n):.2f}")
        
        # Simulate worst case (target not found)
        steps = 0
        size = n
        while size > 0:
            steps += 1
            size //= 2
        print(f"  Actual steps in worst case: {steps}")
    
    for size in [8, 16, 32, 64, 128]:
        demonstrate_complexity(size)

analyze_binary_search_time_complexity()
```

**2. Space Complexity Analysis:**
```python
def analyze_binary_search_space_complexity():
    """
    Analyze space complexity of recursive vs iterative binary search.
    """
    print("BINARY SEARCH SPACE COMPLEXITY ANALYSIS:")
    
    print("\n1. Recursive Implementation:")
    print("   - Call stack depth: O(log n)")
    print("   - Each call stores: left, right, mid")
    print("   - Space per call: O(1)")
    print("   - Total space: O(log n)")
    
    print("\n2. Iterative Implementation:")
    print("   - No recursive calls")
    print("   - Only local variables: left, right, mid")
    print("   - Total space: O(1)")
    
    print("\n3. Space Optimization:")
    print("   - Tail recursion optimization possible")
    print("   - Iterative version preferred for space efficiency")
    print("   - Recursive version more intuitive for understanding")
    
    def calculate_stack_space(n):
        import math
        max_depth = math.ceil(math.log2(n))
        space_per_call = 3  # left, right, mid variables
        total_space = max_depth * space_per_call
        
        print(f"\nStack space calculation for n={n}:")
        print(f"  Maximum recursion depth: {max_depth}")
        print(f"  Space per recursive call: {space_per_call} units")
        print(f"  Total stack space: {total_space} units")
        print(f"  Iterative space: 3 units (constant)")
    
    for size in [16, 64, 256, 1024]:
        calculate_stack_space(size)

analyze_binary_search_space_complexity()
```

**Binary Search Applications:**
```python
def demonstrate_binary_search_applications():
    """
    Demonstrate various applications of binary search.
    """
    applications = {
        'Standard Search': 'Find target in sorted array',
        'Lower Bound': 'Find first position where target could be inserted',
        'Upper Bound': 'Find last position where target could be inserted',
        'Range Query': 'Find first and last occurrence of target',
        'Peak Finding': 'Find local maximum in array',
        'Square Root': 'Find integer square root using binary search',
        'Search in 2D': 'Search in row and column sorted matrix',
        'Rotated Array': 'Search in rotated sorted array'
    }
    
    print("BINARY SEARCH APPLICATIONS:")
    print("-" * 60)
    
    for application, description in applications.items():
        print(f"{application:<15}: {description}")
    
    # Example: Finding square root using binary search
    def binary_search_sqrt(n):
        """Find integer square root using binary search."""
        print(f"\nFinding integer square root of {n}:")
        
        left, right = 0, n
        result = 0
        
        while left <= right:
            mid = left + (right - left) // 2
            square = mid * mid
            
            print(f"  mid = {mid}, mid² = {square}")
            
            if square == n:
                print(f"  Perfect square: √{n} = {mid}")
                return mid
            elif square < n:
                result = mid  # Potential answer
                left = mid + 1
                print(f"  {square} < {n}: search right, current answer = {result}")
            else:
                right = mid - 1
                print(f"  {square} > {n}: search left")
        
        print(f"  Integer square root: {result}")
        return result
    
    # Examples
    binary_search_sqrt(25)
    binary_search_sqrt(26)

demonstrate_binary_search_applications()
```

**Binary Search vs Linear Search Comparison:**
```python
def compare_binary_vs_linear_search():
    """
    Compare binary search with linear search.
    """
    print("BINARY SEARCH VS LINEAR SEARCH:")
    print("-" * 60)
    
    comparison = {
        'Time Complexity': ['O(log n)', 'O(n)'],
        'Space Complexity': ['O(1) iterative, O(log n) recursive', 'O(1)'],
        'Precondition': ['Array must be sorted', 'No precondition'],
        'Best Case': ['O(1) - target at middle', 'O(1) - target at start'],
        'Average Case': ['O(log n)', 'O(n)'],
        'Worst Case': ['O(log n)', 'O(n)'],
        'When to Use': ['Large sorted datasets', 'Small or unsorted data']
    }
    
    print(f"{'Aspect':<20} {'Binary Search':<30} {'Linear Search':<20}")
    print("-" * 70)
    
    for aspect, values in comparison.items():
        print(f"{aspect:<20} {values[0]:<30} {values[1]:<20}")
    
    # Performance comparison example
    print(f"\nPerformance Example (Array size = 1,000,000):")
    print(f"Binary Search: ~20 comparisons maximum")
    print(f"Linear Search: ~500,000 comparisons average")
    print(f"Binary Search is ~25,000x faster on average!")

compare_binary_vs_linear_search()
```

**Binary Search Best Practices:**
1. **Handle edge cases**: Empty arrays, single elements
2. **Avoid integer overflow**: Use `left + (right - left) // 2`
3. **Choose appropriate variant**: Recursive vs iterative
4. **Verify sorted input**: Binary search requires sorted data
5. **Consider boundary conditions**: Inclusive vs exclusive bounds

---

*Note: These answers complete the divide and conquer section (Questions 49-50) from DSAQns01.md. Each answer provides comprehensive explanations with practical examples, step-by-step analysis, and detailed implementations suitable for technical interviews at companies like Amazon, Microsoft, Zoho, and Facebook.*
