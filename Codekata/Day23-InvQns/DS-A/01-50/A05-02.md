# DSA Questions 44-46 - Answers (Recursive Algorithms & Divide and Conquer)

## 44. What is the Tower of Hanoi problem? (Amazon, Microsoft)

**Answer:** The Tower of Hanoi is a classic mathematical puzzle and recursive algorithm problem that demonstrates the power of divide-and-conquer thinking. It involves moving disks between three pegs following specific rules.

**Problem Description:**
- **Setup**: Three pegs (A, B, C) with n disks of different sizes on peg A
- **Goal**: Move all disks from peg A to peg C
- **Rules**: 
  1. Move only one disk at a time
  2. Only the top disk can be moved
  3. A larger disk cannot be placed on a smaller disk

**Mathematical Foundation:**
- **Minimum moves required**: 2^n - 1
- **Recursive structure**: To move n disks, first move n-1 disks
- **Base case**: Moving 1 disk is trivial (direct move)

**Recursive Solution:**
```python
def tower_of_hanoi(n, source, destination, auxiliary):
    """
    Solve Tower of Hanoi puzzle using recursion.
    
    Args:
        n: Number of disks
        source: Source peg (where disks start)
        destination: Destination peg (where disks should end)
        auxiliary: Auxiliary peg (helper peg)
    
    Time Complexity: O(2^n)
    Space Complexity: O(n) - recursion depth
    """
    # Base case: only one disk
    if n == 1:
        print(f"Move disk 1 from {source} to {destination}")
        return 1  # Return number of moves
    
    # Recursive case:
    # Step 1: Move n-1 disks from source to auxiliary
    moves = tower_of_hanoi(n-1, source, auxiliary, destination)
    
    # Step 2: Move the largest disk from source to destination
    print(f"Move disk {n} from {source} to {destination}")
    moves += 1
    
    # Step 3: Move n-1 disks from auxiliary to destination
    moves += tower_of_hanoi(n-1, auxiliary, destination, source)
    
    return moves

# Example usage
print("Tower of Hanoi with 3 disks:")
total_moves = tower_of_hanoi(3, 'A', 'C', 'B')
print(f"Total moves: {total_moves}")
```

**Step-by-Step Execution for n=3:**
```python
def tower_of_hanoi_detailed(n, source, dest, aux, level=0):
    """
    Tower of Hanoi with detailed step-by-step execution trace.
    """
    indent = "  " * level
    print(f"{indent}tower_of_hanoi({n}, {source}, {dest}, {aux})")
    
    if n == 1:
        print(f"{indent}  -> Move disk 1 from {source} to {dest}")
        return 1
    
    print(f"{indent}  Step 1: Move {n-1} disks from {source} to {aux}")
    moves1 = tower_of_hanoi_detailed(n-1, source, aux, dest, level+1)
    
    print(f"{indent}  Step 2: Move disk {n} from {source} to {dest}")
    moves2 = 1
    
    print(f"{indent}  Step 3: Move {n-1} disks from {aux} to {dest}")
    moves3 = tower_of_hanoi_detailed(n-1, aux, dest, source, level+1)
    
    total = moves1 + moves2 + moves3
    print(f"{indent}  Total moves for {n} disks: {total}")
    return total

# Demonstration
print("Detailed execution for 3 disks:")
tower_of_hanoi_detailed(3, 'A', 'C', 'B')
```

**Visual Representation:**
```python
class TowerOfHanoi:
    """
    Visual representation of Tower of Hanoi state.
    """
    def __init__(self, n):
        self.n = n
        self.pegs = {
            'A': list(range(n, 0, -1)),  # Start with all disks on A
            'B': [],
            'C': []
        }
        self.moves = 0
    
    def display_state(self):
        """Display current state of all pegs."""
        print(f"\nMove {self.moves}:")
        max_height = max(len(peg) for peg in self.pegs.values())
        
        for level in range(max_height-1, -1, -1):
            line = ""
            for peg_name in ['A', 'B', 'C']:
                peg = self.pegs[peg_name]
                if level < len(peg):
                    disk = peg[level]
                    line += f"  {disk}  "
                else:
                    line += "  |  "
            print(line)
        
        print(" A   B   C ")
        print("-----------")
    
    def move_disk(self, source, destination):
        """Move one disk from source to destination."""
        if not self.pegs[source]:
            raise ValueError(f"No disk on peg {source}")
        
        disk = self.pegs[source].pop()
        
        if self.pegs[destination] and self.pegs[destination][-1] < disk:
            raise ValueError(f"Cannot place disk {disk} on smaller disk")
        
        self.pegs[destination].append(disk)
        self.moves += 1
        print(f"Move disk {disk} from {source} to {destination}")
        self.display_state()
    
    def solve(self, n, source, dest, aux):
        """Solve Tower of Hanoi with visual representation."""
        if n == 1:
            self.move_disk(source, dest)
            return
        
        self.solve(n-1, source, aux, dest)
        self.move_disk(source, dest)
        self.solve(n-1, aux, dest, source)

# Visual demonstration
def visual_demo():
    print("Visual Tower of Hanoi Solution (3 disks):")
    tower = TowerOfHanoi(3)
    tower.display_state()
    tower.solve(3, 'A', 'C', 'B')
    print(f"\nPuzzle solved in {tower.moves} moves!")
```

**Mathematical Analysis:**

**1. Recurrence Relation:**
```python
def analyze_tower_complexity():
    """
    Analyze the mathematical complexity of Tower of Hanoi.
    """
    print("Tower of Hanoi Complexity Analysis:")
    print("Let T(n) = number of moves for n disks")
    print()
    print("Recurrence relation:")
    print("T(1) = 1")
    print("T(n) = T(n-1) + 1 + T(n-1) = 2*T(n-1) + 1")
    print()
    print("Solving the recurrence:")
    print("T(n) = 2*T(n-1) + 1")
    print("T(n) = 2*(2*T(n-2) + 1) + 1 = 4*T(n-2) + 2 + 1")
    print("T(n) = 4*(2*T(n-3) + 1) + 3 = 8*T(n-3) + 4 + 2 + 1")
    print("...")
    print("T(n) = 2^(n-1)*T(1) + (2^(n-1) - 1)")
    print("T(n) = 2^(n-1)*1 + 2^(n-1) - 1")
    print("T(n) = 2^n - 1")
    print()
    
    # Verify with examples
    for n in range(1, 8):
        predicted = 2**n - 1
        print(f"n={n}: T(n) = 2^{n} - 1 = {predicted}")

analyze_tower_complexity()
```

**2. Growth Rate Demonstration:**
```python
def demonstrate_exponential_growth():
    """Show exponential growth of moves required."""
    print("Exponential Growth of Tower of Hanoi:")
    print("n\tMoves\tTime (if 1 move/second)")
    print("-" * 35)
    
    for n in range(1, 21):
        moves = 2**n - 1
        
        # Convert to human-readable time
        if moves < 60:
            time_str = f"{moves} seconds"
        elif moves < 3600:
            time_str = f"{moves//60} minutes"
        elif moves < 86400:
            time_str = f"{moves//3600} hours"
        elif moves < 31536000:
            time_str = f"{moves//86400} days"
        else:
            time_str = f"{moves//31536000} years"
        
        print(f"{n}\t{moves}\t{time_str}")

demonstrate_exponential_growth()
```

**Iterative Solution:**
```python
def tower_of_hanoi_iterative(n, source='A', dest='C', aux='B'):
    """
    Iterative solution using stack to simulate recursion.
    
    Time Complexity: O(2^n)
    Space Complexity: O(n) - explicit stack
    """
    # Stack stores (n, source, dest, aux, phase)
    # phase: 0=before moving n-1 to aux, 1=move nth disk, 2=move n-1 from aux to dest
    stack = [(n, source, dest, aux, 0)]
    moves = 0
    
    while stack:
        n, src, dst, aux, phase = stack.pop()
        
        if n == 1:
            print(f"Move disk 1 from {src} to {dst}")
            moves += 1
            continue
        
        if phase == 0:
            # Push phases in reverse order (stack is LIFO)
            stack.append((n, src, dst, aux, 2))  # Phase 2: move n-1 from aux to dest
            stack.append((n, src, dst, aux, 1))  # Phase 1: move nth disk
            stack.append((n-1, src, aux, dst, 0))  # Phase 0: move n-1 to aux
        elif phase == 1:
            print(f"Move disk {n} from {src} to {dst}")
            moves += 1
        elif phase == 2:
            stack.append((n-1, aux, dst, src, 0))  # Move n-1 from aux to dest
    
    return moves

# Compare recursive vs iterative
print("Recursive solution:")
rec_moves = tower_of_hanoi(3, 'A', 'C', 'B')
print("\nIterative solution:")
iter_moves = tower_of_hanoi_iterative(3, 'A', 'C', 'B')
print(f"\nBoth solutions use {rec_moves} moves: {rec_moves == iter_moves}")
```

**Optimized Pattern Recognition:**
```python
def tower_of_hanoi_pattern(n):
    """
    Solve Tower of Hanoi using pattern recognition.
    Pattern: For odd-numbered disks, rotate clockwise; for even, counter-clockwise.
    """
    # Determine rotation direction
    if n % 2 == 1:
        # Odd: A -> C -> B -> A (clockwise)
        sequence = ['A', 'C', 'B']
    else:
        # Even: A -> B -> C -> A (counter-clockwise)
        sequence = ['A', 'B', 'C']
    
    moves = 0
    total_moves = 2**n - 1
    
    # Initialize pegs
    pegs = {
        'A': list(range(n, 0, -1)),
        'B': [],
        'C': []
    }
    
    def get_smallest_disk_peg():
        """Find peg with smallest disk."""
        for peg_name in ['A', 'B', 'C']:
            if pegs[peg_name] and pegs[peg_name][-1] == 1:
                return peg_name
        return None
    
    def move_smallest_disk():
        """Move smallest disk according to pattern."""
        nonlocal moves
        current_peg = get_smallest_disk_peg()
        current_index = sequence.index(current_peg)
        next_index = (current_index + 1) % 3
        next_peg = sequence[next_index]
        
        disk = pegs[current_peg].pop()
        pegs[next_peg].append(disk)
        moves += 1
        print(f"Move disk {disk} from {current_peg} to {next_peg}")
    
    def move_other_disk():
        """Move the only legal move that doesn't involve smallest disk."""
        nonlocal moves
        
        # Find the two pegs that don't have the smallest disk
        smallest_peg = get_smallest_disk_peg()
        other_pegs = [p for p in ['A', 'B', 'C'] if p != smallest_peg]
        
        peg1, peg2 = other_pegs
        
        # Determine which move is legal
        if not pegs[peg1]:
            # peg1 is empty, move from peg2 to peg1
            if pegs[peg2]:
                disk = pegs[peg2].pop()
                pegs[peg1].append(disk)
                print(f"Move disk {disk} from {peg2} to {peg1}")
        elif not pegs[peg2]:
            # peg2 is empty, move from peg1 to peg2
            disk = pegs[peg1].pop()
            pegs[peg2].append(disk)
            print(f"Move disk {disk} from {peg1} to {peg2}")
        else:
            # Both pegs have disks, move smaller on top of larger
            if pegs[peg1][-1] < pegs[peg2][-1]:
                disk = pegs[peg1].pop()
                pegs[peg2].append(disk)
                print(f"Move disk {disk} from {peg1} to {peg2}")
            else:
                disk = pegs[peg2].pop()
                pegs[peg1].append(disk)
                print(f"Move disk {disk} from {peg2} to {peg1}")
        
        moves += 1
    
    # Solve using pattern
    for move_num in range(1, total_moves + 1):
        if move_num % 2 == 1:
            # Odd moves: move smallest disk
            move_smallest_disk()
        else:
            # Even moves: make the only legal move not involving smallest disk
            move_other_disk()
    
    return moves

# Demonstrate pattern-based solution
print("Pattern-based solution for 3 disks:")
pattern_moves = tower_of_hanoi_pattern(3)
print(f"Completed in {pattern_moves} moves")
```

**Real-World Applications:**

**1. Backup Rotation Strategy:**
```python
def backup_rotation_strategy(days):
    """
    Model backup rotation using Tower of Hanoi principle.
    Ensures optimal use of backup media with different retention periods.
    """
    print(f"Backup Rotation Strategy for {days} days:")
    print("Media A: Daily backups")
    print("Media B: Weekly backups") 
    print("Media C: Monthly backups")
    print()
    
    # Simulate backup decisions
    for day in range(1, days + 1):
        # Find highest power of 2 that divides day
        level = 0
        temp_day = day
        while temp_day % 2 == 0:
            temp_day //= 2
            level += 1
        
        if level == 0:
            print(f"Day {day}: Use daily backup media")
        elif level == 1:
            print(f"Day {day}: Use weekly backup media")
        else:
            print(f"Day {day}: Use monthly backup media")

backup_rotation_strategy(15)
```

**2. Algorithm Analysis Tool:**
```python
def compare_recursive_algorithms():
    """
    Compare Tower of Hanoi with other recursive algorithms.
    """
    algorithms = {
        'Tower of Hanoi': lambda n: 2**n - 1,
        'Fibonacci (naive)': lambda n: round(1.618**n / 2.236),  # Approximation
        'Factorial': lambda n: n,
        'Binary Search': lambda n: round(math.log2(n))
    }
    
    print("Recursive Algorithm Complexity Comparison:")
    print("n\tTower\tFib\tFact\tBinSearch")
    print("-" * 40)
    
    import math
    for n in range(1, 11):
        values = []
        for name, func in algorithms.items():
            try:
                values.append(str(func(n)))
            except:
                values.append("N/A")
        
        print(f"{n}\t" + "\t".join(values))

compare_recursive_algorithms()
```

**Variants and Extensions:**

**1. Multiple Pegs (Generalized Tower of Hanoi):**
```python
def multi_peg_hanoi(n, k):
    """
    Calculate minimum moves for Tower of Hanoi with k pegs.
    Uses Frame-Stewart algorithm for optimal solution.
    """
    if n <= 1:
        return n
    if k == 3:
        return 2**n - 1
    
    # For k > 3, use Frame-Stewart algorithm
    min_moves = float('inf')
    
    for i in range(1, n):
        # Move i disks using all k pegs, then move remaining n-i disks using 3 pegs
        moves = 2 * multi_peg_hanoi(i, k) + multi_peg_hanoi(n - i, 3)
        min_moves = min(min_moves, moves)
    
    return min_moves

# Compare different numbers of pegs
print("Multi-peg Tower of Hanoi:")
for n in range(1, 8):
    for k in range(3, 6):
        moves = multi_peg_hanoi(n, k)
        print(f"n={n}, k={k} pegs: {moves} moves")
```

**Interview Questions and Variations:**
```python
def interview_variations():
    """
    Common interview variations of Tower of Hanoi.
    """
    print("Common Interview Variations:")
    print()
    
    print("1. Print only the number of moves (no actual moves):")
    def count_moves_only(n):
        return 2**n - 1
    
    print("2. Count moves without printing:")
    def count_recursive_moves(n):
        if n == 1:
            return 1
        return 2 * count_recursive_moves(n-1) + 1
    
    print("3. Reverse problem - given number of moves, find n:")
    def find_disks_from_moves(moves):
        import math
        return int(math.log2(moves + 1))
    
    print("4. Memory-efficient - track state without printing:")
    def memory_efficient_hanoi(n):
        def solve(n, src, dst, aux):
            if n == 1:
                return 1
            return solve(n-1, src, aux, dst) + 1 + solve(n-1, aux, dst, src)
        return solve(n, 'A', 'C', 'B')
    
    # Test variations
    n = 4
    print(f"\nFor n={n}:")
    print(f"Direct formula: {count_moves_only(n)}")
    print(f"Recursive count: {count_recursive_moves(n)}")
    print(f"Memory efficient: {memory_efficient_hanoi(n)}")
    
    moves = 15
    print(f"\nFor {moves} moves, number of disks: {find_disks_from_moves(moves)}")
```

---

## 45. What is tree traversal using recursion? (Zoho, Facebook)

**Answer:** Tree traversal using recursion is a fundamental technique for visiting all nodes in a tree data structure. Recursive approaches naturally match the hierarchical structure of trees, making the code elegant and easy to understand.

**Tree Node Definition:**
```python
class TreeNode:
    """
    Definition for a binary tree node.
    """
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
    
    def __repr__(self):
        return f"TreeNode({self.val})"

# Helper function to create sample trees
def create_sample_tree():
    """
    Create a sample binary tree:
         1
       /   \
      2     3
     / \   / \
    4   5 6   7
    """
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.left = TreeNode(6)
    root.right.right = TreeNode(7)
    return root
```

**Types of Tree Traversal:**

**1. Inorder Traversal (Left, Root, Right):**
```python
def inorder_traversal(root):
    """
    Inorder traversal: Left -> Root -> Right
    
    For BST, this gives sorted order.
    
    Time Complexity: O(n)
    Space Complexity: O(h) where h is height of tree
    """
    if root is None:
        return []
    
    result = []
    
    # Traverse left subtree
    result.extend(inorder_traversal(root.left))
    
    # Visit root
    result.append(root.val)
    
    # Traverse right subtree
    result.extend(inorder_traversal(root.right))
    
    return result

# Alternative implementation using helper function
def inorder_traversal_helper(root):
    """Inorder traversal using helper function."""
    def inorder_helper(node, result):
        if node is not None:
            inorder_helper(node.left, result)   # Left
            result.append(node.val)             # Root
            inorder_helper(node.right, result)  # Right
    
    result = []
    inorder_helper(root, result)
    return result

# Example usage
tree = create_sample_tree()
print("Inorder traversal:", inorder_traversal(tree))
# Output: [4, 2, 5, 1, 6, 3, 7]
```

**2. Preorder Traversal (Root, Left, Right):**
```python
def preorder_traversal(root):
    """
    Preorder traversal: Root -> Left -> Right
    
    Useful for creating copy of tree, prefix expressions.
    
    Time Complexity: O(n)
    Space Complexity: O(h)
    """
    if root is None:
        return []
    
    result = []
    
    # Visit root
    result.append(root.val)
    
    # Traverse left subtree
    result.extend(preorder_traversal(root.left))
    
    # Traverse right subtree
    result.extend(preorder_traversal(root.right))
    
    return result

# With detailed trace
def preorder_with_trace(root, depth=0):
    """Preorder traversal with execution trace."""
    if root is None:
        return []
    
    indent = "  " * depth
    print(f"{indent}Visiting node {root.val}")
    
    result = [root.val]
    
    print(f"{indent}Going to left child of {root.val}")
    result.extend(preorder_with_trace(root.left, depth + 1))
    
    print(f"{indent}Going to right child of {root.val}")
    result.extend(preorder_with_trace(root.right, depth + 1))
    
    print(f"{indent}Finished processing node {root.val}")
    return result

print("Preorder traversal:", preorder_traversal(tree))
# Output: [1, 2, 4, 5, 3, 6, 7]
```

**3. Postorder Traversal (Left, Right, Root):**
```python
def postorder_traversal(root):
    """
    Postorder traversal: Left -> Right -> Root
    
    Useful for deleting tree, postfix expressions, calculating tree size.
    
    Time Complexity: O(n)
    Space Complexity: O(h)
    """
    if root is None:
        return []
    
    result = []
    
    # Traverse left subtree
    result.extend(postorder_traversal(root.left))
    
    # Traverse right subtree
    result.extend(postorder_traversal(root.right))
    
    # Visit root
    result.append(root.val)
    
    return result

print("Postorder traversal:", postorder_traversal(tree))
# Output: [4, 5, 2, 6, 7, 3, 1]
```

**Practical Applications:**

**1. Tree Size Calculation:**
```python
def tree_size(root):
    """
    Calculate total number of nodes in tree using postorder approach.
    """
    if root is None:
        return 0
    
    # Count nodes in left and right subtrees
    left_size = tree_size(root.left)
    right_size = tree_size(root.right)
    
    # Add 1 for current node
    return left_size + right_size + 1

print(f"Tree size: {tree_size(tree)}")
```

**2. Tree Height Calculation:**
```python
def tree_height(root):
    """
    Calculate height of tree using postorder approach.
    Height = max depth from root to any leaf.
    """
    if root is None:
        return 0
    
    # Calculate height of left and right subtrees
    left_height = tree_height(root.left)
    right_height = tree_height(root.right)
    
    # Height is max of subtree heights + 1
    return max(left_height, right_height) + 1

print(f"Tree height: {tree_height(tree)}")
```

**3. Tree Validation (BST Check):**
```python
def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    """
    Check if tree is a valid Binary Search Tree using preorder approach.
    """
    if root is None:
        return True
    
    # Check current node
    if root.val <= min_val or root.val >= max_val:
        return False
    
    # Recursively validate left and right subtrees
    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))

# Create a BST for testing
def create_bst():
    """Create a valid BST."""
    root = TreeNode(4)
    root.left = TreeNode(2)
    root.right = TreeNode(6)
    root.left.left = TreeNode(1)
    root.left.right = TreeNode(3)
    root.right.left = TreeNode(5)
    root.right.right = TreeNode(7)
    return root

bst = create_bst()
print(f"Is valid BST: {is_valid_bst(bst)}")
```

**4. Tree Serialization and Deserialization:**
```python
def serialize_tree(root):
    """
    Serialize tree to string using preorder traversal.
    """
    def preorder_serialize(node):
        if node is None:
            return "null"
        
        return (str(node.val) + "," + 
                preorder_serialize(node.left) + "," +
                preorder_serialize(node.right))
    
    return preorder_serialize(root)

def deserialize_tree(data):
    """
    Deserialize string back to tree using preorder traversal.
    """
    def preorder_deserialize():
        nonlocal index
        if index >= len(values) or values[index] == "null":
            index += 1
            return None
        
        # Create node with current value
        node = TreeNode(int(values[index]))
        index += 1
        
        # Recursively build left and right subtrees
        node.left = preorder_deserialize()
        node.right = preorder_deserialize()
        
        return node
    
    values = data.split(",")
    index = 0
    return preorder_deserialize()

# Test serialization
serialized = serialize_tree(tree)
print(f"Serialized tree: {serialized}")

deserialized = deserialize_tree(serialized)
print(f"Deserialized inorder: {inorder_traversal(deserialized)}")
```

**Advanced Tree Traversal Applications:**

**1. Level Order Traversal (Recursive):**
```python
def level_order_recursive(root):
    """
    Level order traversal using recursion.
    """
    def get_level_nodes(node, level, target_level):
        if node is None:
            return []
        
        if level == target_level:
            return [node.val]
        
        result = []
        result.extend(get_level_nodes(node.left, level + 1, target_level))
        result.extend(get_level_nodes(node.right, level + 1, target_level))
        return result
    
    if root is None:
        return []
    
    result = []
    height = tree_height(root)
    
    for level in range(height):
        level_nodes = get_level_nodes(root, 0, level)
        result.extend(level_nodes)
    
    return result

print(f"Level order traversal: {level_order_recursive(tree)}")
```

**2. Path Finding:**
```python
def find_path_to_node(root, target):
    """
    Find path from root to target node using preorder traversal.
    """
    def find_path_helper(node, target, path):
        if node is None:
            return False
        
        # Add current node to path
        path.append(node.val)
        
        # Check if current node is target
        if node.val == target:
            return True
        
        # Search in left and right subtrees
        if (find_path_helper(node.left, target, path) or
            find_path_helper(node.right, target, path)):
            return True
        
        # If target not found in subtree, remove current node from path
        path.pop()
        return False
    
    path = []
    if find_path_helper(root, target, path):
        return path
    return []

print(f"Path to node 5: {find_path_to_node(tree, 5)}")
```

**3. Tree Comparison:**
```python
def are_trees_identical(root1, root2):
    """
    Check if two trees are identical using preorder traversal.
    """
    # Base cases
    if root1 is None and root2 is None:
        return True
    
    if root1 is None or root2 is None:
        return False
    
    # Check current nodes and recursively check subtrees
    return (root1.val == root2.val and
            are_trees_identical(root1.left, root2.left) and
            are_trees_identical(root1.right, root2.right))

# Test tree comparison
tree_copy = create_sample_tree()
print(f"Trees are identical: {are_trees_identical(tree, tree_copy)}")
```

**Memory-Efficient Traversals:**

**1. Morris Traversal (Inorder without extra space):**
```python
def morris_inorder(root):
    """
    Morris inorder traversal - O(1) space complexity.
    Uses threading to traverse without recursion or stack.
    """
    result = []
    current = root
    
    while current:
        if current.left is None:
            # No left child, visit current and go right
            result.append(current.val)
            current = current.right
        else:
            # Find inorder predecessor
            predecessor = current.left
            while predecessor.right and predecessor.right != current:
                predecessor = predecessor.right
            
            if predecessor.right is None:
                # Create thread
                predecessor.right = current
                current = current.left
            else:
                # Thread exists, remove it and visit current
                predecessor.right = None
                result.append(current.val)
                current = current.right
    
    return result

print(f"Morris inorder: {morris_inorder(tree)}")
```

**Performance Analysis:**

**1. Time and Space Complexity Comparison:**
```python
def analyze_traversal_complexity():
    """
    Analyze complexity of different traversal methods.
    """
    print("Tree Traversal Complexity Analysis:")
    print("-" * 50)
    print("Method\t\tTime\t\tSpace")
    print("-" * 50)
    print("Recursive\tO(n)\t\tO(h)")
    print("Iterative\tO(n)\t\tO(h)")
    print("Morris\t\tO(n)\t\tO(1)")
    print("-" * 50)
    print("Where n = number of nodes, h = height of tree")
    print("For balanced tree: h = O(log n)")
    print("For skewed tree: h = O(n)")

analyze_traversal_complexity()
```

**2. Benchmark Different Approaches:**
```python
import time
import sys

def benchmark_traversals(tree_size=1000):
    """
    Benchmark different traversal approaches.
    """
    # Create large tree for benchmarking
    def create_large_tree(n):
        if n <= 0:
            return None
        
        root = TreeNode(n)
        root.left = create_large_tree(n - 1)
        root.right = create_large_tree(n - 2) if n > 1 else None
        return root
    
    large_tree = create_large_tree(min(tree_size, 100))  # Limit size for recursion
    
    methods = {
        'Recursive Inorder': lambda: inorder_traversal(large_tree),
        'Morris Inorder': lambda: morris_inorder(large_tree),
    }
    
    print(f"Benchmark Results for tree with ~{tree_size} nodes:")
    print("-" * 50)
    
    for name, method in methods.items():
        try:
            start_time = time.time()
            result = method()
            end_time = time.time()
            
            print(f"{name}: {end_time - start_time:.6f}s ({len(result)} nodes)")
        except RecursionError:
            print(f"{name}: RecursionError (tree too deep)")

benchmark_traversals()
```

**Common Interview Problems:**

**1. Binary Tree Right Side View:**
```python
def right_side_view(root):
    """
    Get right side view of binary tree using recursive level order.
    """
    def right_view_helper(node, level, max_level, result):
        if node is None:
            return max_level
        
        # If this is the first node of current level
        if level > max_level[0]:
            result.append(node.val)
            max_level[0] = level
        
        # Traverse right first, then left
        max_level[0] = right_view_helper(node.right, level + 1, max_level, result)
        max_level[0] = right_view_helper(node.left, level + 1, max_level, result)
        
        return max_level[0]
    
    result = []
    max_level = [0]
    right_view_helper(root, 1, max_level, result)
    return result

print(f"Right side view: {right_side_view(tree)}")
```

**2. Tree Diameter:**
```python
def tree_diameter(root):
    """
    Calculate diameter of tree (longest path between any two nodes).
    """
    def diameter_helper(node):
        if node is None:
            return 0, 0  # height, diameter
        
        # Get height and diameter of left and right subtrees
        left_height, left_diameter = diameter_helper(node.left)
        right_height, right_diameter = diameter_helper(node.right)
        
        # Current height
        current_height = max(left_height, right_height) + 1
        
        # Current diameter (max of: left diameter, right diameter, path through root)
        path_through_root = left_height + right_height + 1
        current_diameter = max(left_diameter, right_diameter, path_through_root)
        
        return current_height, current_diameter
    
    _, diameter = diameter_helper(root)
    return diameter

print(f"Tree diameter: {tree_diameter(tree)}")
```

**Best Practices for Tree Traversal:**
1. **Choose appropriate traversal** based on problem requirements
2. **Handle null nodes** gracefully in base cases
3. **Consider iterative alternatives** for deep trees
4. **Use helper functions** for cleaner interfaces
5. **Optimize space usage** when possible (Morris traversal)
6. **Test with edge cases** (empty tree, single node, skewed trees)

---

## 46. What is the divide and conquer approach? (Google, Amazon)

**Answer:** Divide and conquer is a fundamental algorithmic paradigm that solves complex problems by breaking them into smaller, more manageable subproblems, solving each subproblem independently, and then combining their solutions to solve the original problem.

**Core Principles:**

**1. Three-Step Process:**
```python
def divide_and_conquer_template(problem):
    """
    Generic template for divide and conquer algorithms.
    """
    # Step 1: BASE CASE - If problem is small enough, solve directly
    if is_base_case(problem):
        return solve_directly(problem)
    
    # Step 2: DIVIDE - Break problem into smaller subproblems
    subproblems = divide(problem)
    
    # Step 3: CONQUER - Recursively solve subproblems
    subsolutions = []
    for subproblem in subproblems:
        subsolutions.append(divide_and_conquer_template(subproblem))
    
    # Step 4: COMBINE - Merge subsolutions to get final solution
    return combine(subsolutions)
```

**2. Mathematical Foundation:**
- **Recurrence Relations**: T(n) = aT(n/b) + f(n)
- **Master Theorem**: Provides complexity analysis framework
- **Optimal Substructure**: Solution contains optimal solutions to subproblems

**Classic Divide and Conquer Examples:**

**1. Merge Sort - Complete Implementation:**
```python
def merge_sort(arr):
    """
    Merge sort implementation using divide and conquer.
    
    Time Complexity: O(n log n)
    Space Complexity: O(n)
    """
    # BASE CASE: Array with 0 or 1 element is already sorted
    if len(arr) <= 1:
        return arr
    
    # DIVIDE: Split array into two halves
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    # CONQUER: Recursively sort both halves
    left_sorted = merge_sort(left_half)
    right_sorted = merge_sort(right_half)
    
    # COMBINE: Merge the sorted halves
    return merge(left_sorted, right_sorted)

def merge(left, right):
    """
    Merge two sorted arrays into one sorted array.
    """
    result = []
    i = j = 0
    
    # Compare elements and merge in sorted order
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # Add remaining elements
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# Example with trace
def merge_sort_with_trace(arr, depth=0):
    """Merge sort with execution trace."""
    indent = "  " * depth
    print(f"{indent}merge_sort({arr})")
    
    if len(arr) <= 1:
        print(f"{indent}Base case: returning {arr}")
        return arr
    
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    print(f"{indent}Dividing into {left_half} and {right_half}")
    
    left_sorted = merge_sort_with_trace(left_half, depth + 1)
    right_sorted = merge_sort_with_trace(right_half, depth + 1)
    
    result = merge(left_sorted, right_sorted)
    print(f"{indent}Merged result: {result}")
    
    return result

# Demonstration
arr = [64, 34, 25, 12, 22, 11, 90]
print("Original array:", arr)
sorted_arr = merge_sort_with_trace(arr)
print("Final sorted array:", sorted_arr)
```

**2. Quick Sort Implementation:**
```python
def quick_sort(arr, low=0, high=None):
    """
    Quick sort implementation using divide and conquer.
    
    Time Complexity: O(n log n) average, O(n²) worst case
    Space Complexity: O(log n) average
    """
    if high is None:
        high = len(arr) - 1
    
    # BASE CASE: If low >= high, subarray has 0 or 1 element
    if low < high:
        # DIVIDE: Partition array and get pivot index
        pivot_index = partition(arr, low, high)
        
        # CONQUER: Recursively sort elements before and after partition
        quick_sort(arr, low, pivot_index - 1)   # Left subarray
        quick_sort(arr, pivot_index + 1, high)  # Right subarray
    
    return arr

def partition(arr, low, high):
    """
    Partition function for quick sort.
    Places pivot in correct position and partitions array.
    """
    # Choose rightmost element as pivot
    pivot = arr[high]
    
    # Index of smaller element
    i = low - 1
    
    for j in range(low, high):
        # If current element is smaller than or equal to pivot
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    # Place pivot in correct position
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# Example
arr = [64, 34, 25, 12, 22, 11, 90]
print("Quick sort result:", quick_sort(arr.copy()))
```

**3. Binary Search:**
```python
def binary_search(arr, target, left=0, right=None):
    """
    Binary search using divide and conquer.
    
    Time Complexity: O(log n)
    Space Complexity: O(log n) due to recursion
    """
    if right is None:
        right = len(arr) - 1
    
    # BASE CASE: Search space is empty
    if left > right:
        return -1
    
    # DIVIDE: Find middle element
    mid = (left + right) // 2
    
    # BASE CASE: Target found
    if arr[mid] == target:
        return mid
    
    # CONQUER: Recursively search appropriate half
    elif arr[mid] > target:
        return binary_search(arr, target, left, mid - 1)   # Search left half
    else:
        return binary_search(arr, target, mid + 1, right)  # Search right half

# Example
sorted_arr = [11, 12, 22, 25, 34, 64, 90]
target = 25
result = binary_search(sorted_arr, target)
print(f"Binary search for {target}: index {result}")
```

**Advanced Divide and Conquer Applications:**

**1. Maximum Subarray Problem (Kadane's Algorithm via D&C):**
```python
def max_subarray_divide_conquer(arr, low=0, high=None):
    """
    Find maximum subarray sum using divide and conquer.
    
    Time Complexity: O(n log n)
    Space Complexity: O(log n)
    """
    if high is None:
        high = len(arr) - 1
    
    # BASE CASE: Only one element
    if low == high:
        return arr[low]
    
    # DIVIDE: Find middle point
    mid = (low + high) // 2
    
    # CONQUER: Find maximum subarray sum in left and right halves
    left_max = max_subarray_divide_conquer(arr, low, mid)
    right_max = max_subarray_divide_conquer(arr, mid + 1, high)
    
    # COMBINE: Find maximum subarray sum that crosses the midpoint
    cross_max = max_crossing_subarray(arr, low, mid, high)
    
    # Return maximum of the three
    return max(left_max, right_max, cross_max)

def max_crossing_subarray(arr, low, mid, high):
    """
    Find maximum subarray that crosses the midpoint.
    """
    # Find maximum sum for left side
    left_sum = float('-inf')
    current_sum = 0
    for i in range(mid, low - 1, -1):
        current_sum += arr[i]
        if current_sum > left_sum:
            left_sum = current_sum
    
    # Find maximum sum for right side
    right_sum = float('-inf')
    current_sum = 0
    for i in range(mid + 1, high + 1):
        current_sum += arr[i]
        if current_sum > right_sum:
            right_sum = current_sum
    
    return left_sum + right_sum

# Example
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
max_sum = max_subarray_divide_conquer(arr)
print(f"Maximum subarray sum: {max_sum}")
```

**2. Closest Pair of Points:**
```python
import math

def closest_pair_points(points):
    """
    Find closest pair of points using divide and conquer.
    
    Time Complexity: O(n log n)
    Space Complexity: O(n)
    """
    def distance(p1, p2):
        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)
    
    def brute_force_closest(pts):
        """Brute force for small arrays."""
        min_dist = float('inf')
        closest_pair = None
        
        for i in range(len(pts)):
            for j in range(i + 1, len(pts)):
                dist = distance(pts[i], pts[j])
                if dist < min_dist:
                    min_dist = dist
                    closest_pair = (pts[i], pts[j])
        
        return min_dist, closest_pair
    
    def closest_pair_rec(px, py):
        """Recursive divide and conquer solution."""
        n = len(px)
        
        # BASE CASE: Use brute force for small arrays
        if n <= 3:
            return brute_force_closest(px)
        
        # DIVIDE: Split points into left and right halves
        mid = n // 2
        midpoint = px[mid]
        
        pyl = [point for point in py if point[0] <= midpoint[0]]
        pyr = [point for point in py if point[0] > midpoint[0]]
        
        # CONQUER: Find closest pairs in both halves
        left_dist, left_pair = closest_pair_rec(px[:mid], pyl)
        right_dist, right_pair = closest_pair_rec(px[mid:], pyr)
        
        # Find minimum distance
        min_dist = min(left_dist, right_dist)
        closest_pair = left_pair if left_dist < right_dist else right_pair
        
        # COMBINE: Check for closer pairs across the dividing line
        strip = [point for point in py if abs(point[0] - midpoint[0]) < min_dist]
        
        strip_dist, strip_pair = closest_in_strip(strip, min_dist)
        
        if strip_dist < min_dist:
            return strip_dist, strip_pair
        else:
            return min_dist, closest_pair
    
    def closest_in_strip(strip, min_dist):
        """Find closest pair in strip."""
        min_strip_dist = min_dist
        closest_strip_pair = None
        
        for i in range(len(strip)):
            j = i + 1
            while j < len(strip) and (strip[j][1] - strip[i][1]) < min_strip_dist:
                dist = distance(strip[i], strip[j])
                if dist < min_strip_dist:
                    min_strip_dist = dist
                    closest_strip_pair = (strip[i], strip[j])
                j += 1
        
        return min_strip_dist, closest_strip_pair
    
    # Sort points by x and y coordinates
    px = sorted(points, key=lambda p: p[0])
    py = sorted(points, key=lambda p: p[1])
    
    return closest_pair_rec(px, py)

# Example
points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)]
min_distance, pair = closest_pair_points(points)
print(f"Closest pair: {pair} with distance {min_distance:.2f}")
```

**3. Fast Matrix Multiplication (Strassen's Algorithm):**
```python
def matrix_multiply_strassen(A, B):
    """
    Matrix multiplication using Strassen's algorithm.
    
    Time Complexity: O(n^log₂7) ≈ O(n^2.807)
    Space Complexity: O(n²)
    """
    n = len(A)
    
    # BASE CASE: 1x1 matrices
    if n == 1:
        return [[A[0][0] * B[0][0]]]
    
    # Ensure matrices are even-sized (pad if necessary)
    if n % 2 != 0:
        A = pad_matrix(A)
        B = pad_matrix(B)
        n += 1
    
    # DIVIDE: Split matrices into quadrants
    mid = n // 2
    
    A11 = [[A[i][j] for j in range(mid)] for i in range(mid)]
    A12 = [[A[i][j] for j in range(mid, n)] for i in range(mid)]
    A21 = [[A[i][j] for j in range(mid)] for i in range(mid, n)]
    A22 = [[A[i][j] for j in range(mid, n)] for i in range(mid, n)]
    
    B11 = [[B[i][j] for j in range(mid)] for i in range(mid)]
    B12 = [[B[i][j] for j in range(mid, n)] for i in range(mid)]
    B21 = [[B[i][j] for j in range(mid)] for i in range(mid, n)]
    B22 = [[B[i][j] for j in range(mid, n)] for i in range(mid, n)]
    
    # CONQUER: Compute 7 products recursively
    M1 = matrix_multiply_strassen(matrix_add(A11, A22), matrix_add(B11, B22))
    M2 = matrix_multiply_strassen(matrix_add(A21, A22), B11)
    M3 = matrix_multiply_strassen(A11, matrix_subtract(B12, B22))
    M4 = matrix_multiply_strassen(A22, matrix_subtract(B21, B11))
    M5 = matrix_multiply_strassen(matrix_add(A11, A12), B22)
    M6 = matrix_multiply_strassen(matrix_subtract(A21, A11), matrix_add(B11, B12))
    M7 = matrix_multiply_strassen(matrix_subtract(A12, A22), matrix_add(B21, B22))
    
    # COMBINE: Compute result quadrants
    C11 = matrix_add(matrix_subtract(matrix_add(M1, M4), M5), M7)
    C12 = matrix_add(M3, M5)
    C21 = matrix_add(M2, M4)
    C22 = matrix_add(matrix_subtract(matrix_add(M1, M3), M2), M6)
    
    # Combine quadrants into result matrix
    result = [[0] * n for _ in range(n)]
    for i in range(mid):
        for j in range(mid):
            result[i][j] = C11[i][j]
            result[i][j + mid] = C12[i][j]
            result[i + mid][j] = C21[i][j]
            result[i + mid][j + mid] = C22[i][j]
    
    return result

def matrix_add(A, B):
    """Add two matrices."""
    n = len(A)
    return [[A[i][j] + B[i][j] for j in range(n)] for i in range(n)]

def matrix_subtract(A, B):
    """Subtract matrix B from A."""
    n = len(A)
    return [[A[i][j] - B[i][j] for j in range(n)] for i in range(n)]

def pad_matrix(matrix):
    """Pad matrix to make it even-sized."""
    n = len(matrix)
    padded = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n):
        for j in range(n):
            padded[i][j] = matrix[i][j]
    return padded
```

**Master Theorem Analysis:**
```python
def master_theorem_analysis():
    """
    Analyze common divide and conquer algorithms using Master Theorem.
    
    Master Theorem: T(n) = aT(n/b) + f(n)
    
    Case 1: f(n) = O(n^(log_b(a) - ε)) for some ε > 0
            → T(n) = Θ(n^log_b(a))
    
    Case 2: f(n) = Θ(n^log_b(a))
            → T(n) = Θ(n^log_b(a) * log n)
    
    Case 3: f(n) = Ω(n^(log_b(a) + ε)) for some ε > 0
            → T(n) = Θ(f(n))
    """
    
    algorithms = [
        {
            'name': 'Merge Sort',
            'recurrence': 'T(n) = 2T(n/2) + O(n)',
            'a': 2, 'b': 2, 'f(n)': 'n',
            'log_b_a': 1,
            'case': 2,
            'complexity': 'O(n log n)'
        },
        {
            'name': 'Binary Search',
            'recurrence': 'T(n) = T(n/2) + O(1)',
            'a': 1, 'b': 2, 'f(n)': '1',
            'log_b_a': 0,
            'case': 2,
            'complexity': 'O(log n)'
        },
        {
            'name': 'Strassen Matrix Mult',
            'recurrence': 'T(n) = 7T(n/2) + O(n²)',
            'a': 7, 'b': 2, 'f(n)': 'n²',
            'log_b_a': 2.807,
            'case': 1,
            'complexity': 'O(n^2.807)'
        },
        {
            'name': 'Max Subarray',
            'recurrence': 'T(n) = 2T(n/2) + O(n)',
            'a': 2, 'b': 2, 'f(n)': 'n',
            'log_b_a': 1,
            'case': 2,
            'complexity': 'O(n log n)'
        }
    ]
    
    print("Master Theorem Analysis:")
    print("-" * 80)
    print("Algorithm\t\tRecurrence\t\tCase\tComplexity")
    print("-" * 80)
    
    for algo in algorithms:
        print(f"{algo['name']:<20}\t{algo['recurrence']:<20}\t{algo['case']}\t{algo['complexity']}")

master_theorem_analysis()
```

**When to Use Divide and Conquer:**

**1. Problem Characteristics:**
```python
def should_use_divide_conquer(problem_characteristics):
    """
    Decision framework for using divide and conquer.
    """
    criteria = {
        'can_be_divided': problem_characteristics.get('divisible', False),
        'subproblems_similar': problem_characteristics.get('similar_subproblems', False),
        'optimal_substructure': problem_characteristics.get('optimal_substructure', False),
        'combining_is_efficient': problem_characteristics.get('efficient_combine', False)
    }
    
    if all(criteria.values()):
        return "Excellent candidate for divide and conquer"
    elif sum(criteria.values()) >= 3:
        return "Good candidate for divide and conquer"
    else:
        return "Consider other approaches"

# Examples
problems = [
    {'name': 'Sorting', 'divisible': True, 'similar_subproblems': True, 
     'optimal_substructure': True, 'efficient_combine': True},
    {'name': 'Matrix Multiplication', 'divisible': True, 'similar_subproblems': True,
     'optimal_substructure': True, 'efficient_combine': False},
    {'name': 'Finding Maximum', 'divisible': True, 'similar_subproblems': True,
     'optimal_substructure': True, 'efficient_combine': True}
]

for problem in problems:
    recommendation = should_use_divide_conquer(problem)
    print(f"{problem['name']}: {recommendation}")
```

**Best Practices:**
1. **Identify base cases** carefully to avoid infinite recursion
2. **Ensure subproblems are significantly smaller** to guarantee termination
3. **Optimize the combine step** as it often determines overall efficiency
4. **Consider iterative alternatives** for tail-recursive divide and conquer
5. **Use memoization** when subproblems overlap
6. **Analyze complexity** using Master Theorem when applicable

---

*Note: These answers cover advanced recursive algorithms and divide & conquer fundamentals (Questions 44-46) from DSAQns01.md. Each answer provides comprehensive explanations with practical examples, implementations, and analysis suitable for technical interviews at companies like Google, Amazon, Microsoft, Facebook, and Zoho.*