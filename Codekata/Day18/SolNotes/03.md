# Distinct Substrings Counter using Z Algorithm

## Overview
This program counts the number of distinct substrings in a given string using the Z Algorithm. The Z Algorithm is a linear-time string matching algorithm that computes the Z-array, which contains information about the longest substring starting from position i that matches a prefix of the string.

## Algorithm: Z Algorithm

### What is the Z Algorithm?
The Z Algorithm builds a Z-array where `Z[i]` represents the length of the longest substring starting from position `i` that matches a prefix of the string.

### Z-Array Definition
For a string `S` of length `n`:
- `Z[0]` is undefined (or can be considered as `n`)
- `Z[i]` = length of the longest substring starting from `S[i]` that matches a prefix of `S`

### Example
For string `"ababcab"`:
```
String: a b a b c a b
Index:  0 1 2 3 4 5 6
Z-Array:[- 0 2 0 0 2 0]
```

Explanation:
- `Z[1] = 0`: "b" doesn't match prefix "a"
- `Z[2] = 2`: "ab" matches prefix "ab"
- `Z[3] = 0`: "b" doesn't match prefix "a"
- `Z[4] = 0`: "c" doesn't match prefix "a"
- `Z[5] = 2`: "ab" matches prefix "ab"
- `Z[6] = 0`: "b" doesn't match prefix "a"

## Z Algorithm Implementation

### Key Variables
- `l, r`: Left and right boundaries of the rightmost Z-box found so far
- `Z-box`: A substring that matches a prefix of the string

### Algorithm Steps

```java
private static int[] buildZ(String s) {
    int n = s.length();
    int[] z = new int[n];
    int l = 0, r = 0;  // Z-box boundaries
    
    for (int i = 1; i < n; i++) {
        if (i <= r) {
            // Case 1: i is inside current Z-box
            z[i] = Math.min(r - i + 1, z[i - l]);
        }
        
        // Case 2: Extend comparison from current position
        while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i])) {
            z[i]++;
        }
        
        // Update Z-box if we found a longer match
        if (i + z[i] - 1 > r) {
            l = i;
            r = i + z[i] - 1;
        }
    }
    return z;
}
```

### Algorithm Cases

#### Case 1: i ≤ r (Inside Z-box)
When current position `i` is inside the rightmost Z-box `[l, r]`:
- We can use previously computed information
- `z[i] = min(r - i + 1, z[i - l])`
- This avoids redundant comparisons

#### Case 2: Extension
Regardless of the case, we try to extend the match:
- Compare characters starting from `s[z[i]]` and `s[i + z[i]]`
- Continue while characters match

#### Case 3: Update Z-box
If the new match extends beyond current Z-box:
- Update `l = i` and `r = i + z[i] - 1`

## Step-by-Step Trace

Let's trace `buildZ("ababa")`:

| i | l | r | Inside Z-box? | Initial z[i] | After Extension | Final z[i] | New l,r |
|---|---|---|---------------|--------------|-----------------|------------|---------|
| 1 | 0 | 0 | No (1 > 0)   | 0            | No match        | 0          | 0,0     |
| 2 | 0 | 0 | No (2 > 0)   | 0            | Match "ab"      | 2          | 2,3     |
| 3 | 2 | 3 | Yes (3 ≤ 3)  | min(1,0)=0   | No match        | 0          | 2,3     |
| 4 | 2 | 3 | No (4 > 3)   | 0            | Match "a"       | 1          | 2,3     |

Final Z-array: `[-, 0, 2, 0, 1]`

## Distinct Substrings Algorithm

### Approach
The program uses a brute-force approach combined with HashSet for uniqueness:

```java
public static int countDistinctSubstrings(String s) {
    int n = s.length();
    Set<String> substrings = new HashSet<>();
    
    for (int i = 0; i < n; i++) {
        String suffix = s.substring(i);
        int[] z = buildZ(suffix);  // Build Z-array for each suffix
        
        for (int len = 1; len <= suffix.length(); len++) {
            substrings.add(suffix.substring(0, len));  // Add all prefixes
        }
    }
    
    return substrings.size();
}
```

### Why This Works
1. **All Substrings**: Every substring of the original string is a prefix of some suffix
2. **No Duplicates**: HashSet automatically handles uniqueness
3. **Complete Coverage**: By considering all suffixes and their prefixes, we get all possible substrings

## Example Walkthrough

For string `"abc"`:

### Iteration 1 (i=0): Suffix = "abc"
- Z-array: `[-, 0, 0]`
- Prefixes added: "a", "ab", "abc"
- Set: {"a", "ab", "abc"}

### Iteration 2 (i=1): Suffix = "bc"
- Z-array: `[-, 0]`
- Prefixes added: "b", "bc"
- Set: {"a", "ab", "abc", "b", "bc"}

### Iteration 3 (i=2): Suffix = "c"
- Z-array: `[-]`
- Prefixes added: "c"
- Set: {"a", "ab", "abc", "b", "bc", "c"}

**Result**: 6 distinct substrings

## Time & Space Complexity

### Time Complexity
- **Z Algorithm**: O(n) for each call
- **Total**: O(n²) - Z algorithm called n times
- **Substring operations**: O(n³) due to string creation

### Space Complexity
- **Z-array**: O(n) for each call
- **HashSet**: O(n²) in worst case (all substrings are distinct)
- **Total**: O(n²)

## Optimization Opportunities

### Current Issues
1. **Unused Z-array**: The Z-array is computed but not used for optimization
2. **String creation overhead**: Creating many substring objects
3. **Redundant computations**: Not leveraging Z-array properties

### Potential Optimizations
1. **Use Z-array for duplicate detection**: Avoid adding duplicate substrings
2. **Character array operations**: Avoid string object creation
3. **Suffix array approach**: More efficient for large strings

## Alternative Approach using Z-Array

A more efficient approach would use the Z-array to identify unique substrings:

```java
// Optimized version (conceptual)
public static int countDistinctSubstringsOptimized(String s) {
    Set<String> distinct = new HashSet<>();
    
    for (int i = 0; i < s.length(); i++) {
        String suffix = s.substring(i);
        int[] z = buildZ(suffix);
        
        // Use Z-array to identify unique prefixes
        for (int j = 1; j <= suffix.length(); j++) {
            // Check if this prefix has appeared before using Z-array
            boolean isUnique = true;
            for (int k = 1; k < j; k++) {
                if (z[k] >= j - k) {
                    isUnique = false;
                    break;
                }
            }
            if (isUnique) {
                distinct.add(suffix.substring(0, j));
            }
        }
    }
    
    return distinct.size();
}
```

## Applications

### String Processing
1. **Text Analysis**: Finding unique patterns in documents
2. **Data Compression**: Identifying repeating substrings
3. **Bioinformatics**: DNA sequence analysis
4. **Search Engines**: Indexing unique text patterns

### Related Problems
1. **Longest Common Substring**: Can be solved using Z-algorithm
2. **Pattern Matching**: Z-algorithm is excellent for multiple pattern matching
3. **String Similarity**: Measuring similarity between strings

## Input/Output Examples

### Example 1
```
Input: "abc"
Output: 6
Substrings: "a", "b", "c", "ab", "bc", "abc"
```

### Example 2
```
Input: "aaa"
Output: 3
Substrings: "a", "aa", "aaa"
```

### Example 3
```
Input: "abcab"
Output: 9
Substrings: "a", "b", "c", "ab", "bc", "ca", "abc", "bca", "abcab"
```

## Edge Cases

1. **Empty String**: Returns 0
2. **Single Character**: Returns 1
3. **All Same Characters**: Returns n (length of string)
4. **All Different Characters**: Returns n(n+1)/2

## Code Structure

### Main Function
```java
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int T = Integer.parseInt(sc.nextLine());  // Number of test cases
    
    for (int t = 0; t < T; t++) {
        String s = sc.nextLine().trim();
        System.out.println(countDistinctSubstrings(s));
    }
}
```

### Key Features
1. **Multiple Test Cases**: Handles T test cases
2. **Input Validation**: Trims whitespace
3. **Modular Design**: Separate functions for Z-array and counting

## Comparison with Other Algorithms

| Algorithm | Time Complexity | Space Complexity | Implementation |
|-----------|----------------|------------------|----------------|
| Brute Force | O(n³) | O(n²) | Simple |
| Z Algorithm (current) | O(n³) | O(n²) | Moderate |
| Suffix Array | O(n² log n) | O(n²) | Complex |
| Suffix Tree | O(n²) | O(n²) | Very Complex |

## Conclusion

This implementation provides a solid foundation for counting distinct substrings, though it doesn't fully leverage the power of the Z Algorithm. The Z Algorithm itself is implemented correctly and efficiently, making it a good building block for more advanced string processing algorithms.
